// Generated by Haxe 3.4.7
var $hxClasses = {},$estr = function() { return js_Boot.__string_rec(this,''); };
function $extend(from, fields) {
	function Inherit() {} Inherit.prototype = from; var proto = new Inherit();
	for (var name in fields) proto[name] = fields[name];
	if( fields.toString !== Object.prototype.toString ) proto.toString = fields.toString;
	return proto;
}
var EReg = function(r,opt) {
	this.r = new RegExp(r,opt.split("u").join(""));
};
$hxClasses["EReg"] = EReg;
EReg.__name__ = ["EReg"];
EReg.prototype = {
	r: null
	,match: function(s) {
		if(this.r.global) {
			this.r.lastIndex = 0;
		}
		this.r.m = this.r.exec(s);
		this.r.s = s;
		return this.r.m != null;
	}
	,matched: function(n) {
		if(this.r.m != null && n >= 0 && n < this.r.m.length) {
			return this.r.m[n];
		} else {
			throw new js__$Boot_HaxeError("EReg::matched");
		}
	}
	,matchedLeft: function() {
		if(this.r.m == null) {
			throw new js__$Boot_HaxeError("No string matched");
		}
		return HxOverrides.substr(this.r.s,0,this.r.m.index);
	}
	,matchedRight: function() {
		if(this.r.m == null) {
			throw new js__$Boot_HaxeError("No string matched");
		}
		var sz = this.r.m.index + this.r.m[0].length;
		return HxOverrides.substr(this.r.s,sz,this.r.s.length - sz);
	}
	,matchedPos: function() {
		if(this.r.m == null) {
			throw new js__$Boot_HaxeError("No string matched");
		}
		return { pos : this.r.m.index, len : this.r.m[0].length};
	}
	,matchSub: function(s,pos,len) {
		if(len == null) {
			len = -1;
		}
		if(this.r.global) {
			this.r.lastIndex = pos;
			var tmp = this.r;
			var tmp1 = len < 0 ? s : HxOverrides.substr(s,0,pos + len);
			this.r.m = tmp.exec(tmp1);
			var b = this.r.m != null;
			if(b) {
				this.r.s = s;
			}
			return b;
		} else {
			var b1 = this.match(len < 0 ? HxOverrides.substr(s,pos,null) : HxOverrides.substr(s,pos,len));
			if(b1) {
				this.r.s = s;
				this.r.m.index += pos;
			}
			return b1;
		}
	}
	,split: function(s) {
		var d = "#__delim__#";
		return s.replace(this.r,d).split(d);
	}
	,replace: function(s,by) {
		return s.replace(this.r,by);
	}
	,map: function(s,f) {
		var offset = 0;
		var buf_b = "";
		while(true) {
			if(offset >= s.length) {
				break;
			} else if(!this.matchSub(s,offset)) {
				buf_b += Std.string(HxOverrides.substr(s,offset,null));
				break;
			}
			var p = this.matchedPos();
			buf_b += Std.string(HxOverrides.substr(s,offset,p.pos - offset));
			buf_b += Std.string(f(this));
			if(p.len == 0) {
				buf_b += Std.string(HxOverrides.substr(s,p.pos,1));
				offset = p.pos + 1;
			} else {
				offset = p.pos + p.len;
			}
			if(!this.r.global) {
				break;
			}
		}
		if(!this.r.global && offset > 0 && offset < s.length) {
			buf_b += Std.string(HxOverrides.substr(s,offset,null));
		}
		return buf_b;
	}
	,__class__: EReg
};
var Entry = function(line,name,seq) {
	if(line == null) {
		line = -1;
	}
	this.line = line;
	this.name = name;
	this.seq = seq;
};
$hxClasses["Entry"] = Entry;
Entry.__name__ = ["Entry"];
Entry.prototype = {
	name: null
	,seq: null
	,line: null
	,addToSeq: function(s) {
		if(this.seq == null || this.seq == "") {
			this.seq = s;
		} else {
			this.seq += s;
		}
	}
	,getName: function() {
		return this.name;
	}
	,getSeq: function() {
		if(this.seq == null) {
			return "";
		}
		return this.seq;
	}
	,getLineNo: function() {
		return this.line;
	}
	,__class__: Entry
};
var _$Map_Map_$Impl_$ = {};
$hxClasses["_Map.Map_Impl_"] = _$Map_Map_$Impl_$;
_$Map_Map_$Impl_$.__name__ = ["_Map","Map_Impl_"];
_$Map_Map_$Impl_$.set = function(this1,key,value) {
	this1.set(key,value);
};
_$Map_Map_$Impl_$.get = function(this1,key) {
	return this1.get(key);
};
_$Map_Map_$Impl_$.exists = function(this1,key) {
	return this1.exists(key);
};
_$Map_Map_$Impl_$.remove = function(this1,key) {
	return this1.remove(key);
};
_$Map_Map_$Impl_$.keys = function(this1) {
	return this1.keys();
};
_$Map_Map_$Impl_$.iterator = function(this1) {
	return this1.iterator();
};
_$Map_Map_$Impl_$.toString = function(this1) {
	return this1.toString();
};
_$Map_Map_$Impl_$.arrayWrite = function(this1,k,v) {
	this1.set(k,v);
	return v;
};
_$Map_Map_$Impl_$.toStringMap = function(t) {
	return new haxe_ds_StringMap();
};
_$Map_Map_$Impl_$.toIntMap = function(t) {
	return new haxe_ds_IntMap();
};
_$Map_Map_$Impl_$.toEnumValueMapMap = function(t) {
	return new haxe_ds_EnumValueMap();
};
_$Map_Map_$Impl_$.toObjectMap = function(t) {
	return new haxe_ds_ObjectMap();
};
_$Map_Map_$Impl_$.fromStringMap = function(map) {
	return map;
};
_$Map_Map_$Impl_$.fromIntMap = function(map) {
	return map;
};
_$Map_Map_$Impl_$.fromObjectMap = function(map) {
	return map;
};
var FastaAlignmentParser = function(fileContent,allChecks,allSort,fileNr) {
	this.fastaContent = [];
	this.seqLength = -1;
	if(fileContent == null) {
		return;
	}
	var end = fileContent.length;
	while(true) {
		var tmp;
		if(end > 0) {
			var cCode = HxOverrides.cca(fileContent,end - 1);
			var result = false;
			var _g = 0;
			var _g1 = [9,10,11,12,13,32,133,160,5760,8192,8192,8193,8194,8195,8196,8197,8198,8199,8200,8201,8202,8232,8233,8239,8287,12288,6158,8203,8204,8205,8288,65279];
			while(_g < _g1.length) {
				var ele = _g1[_g];
				++_g;
				if(ele == cCode) {
					result = true;
					break;
				}
			}
			tmp = result;
		} else {
			tmp = false;
		}
		if(!tmp) {
			break;
		}
		--end;
	}
	var s = fileContent.substring(0,end);
	var begin = 0;
	var sLen = s.length;
	while(true) {
		var tmp1;
		if(begin < sLen) {
			var cCode1 = HxOverrides.cca(s,begin);
			var result1 = false;
			var _g2 = 0;
			var _g11 = [9,10,11,12,13,32,133,160,5760,8192,8192,8193,8194,8195,8196,8197,8198,8199,8200,8201,8202,8232,8233,8239,8287,12288,6158,8203,8204,8205,8288,65279];
			while(_g2 < _g11.length) {
				var ele1 = _g11[_g2];
				++_g2;
				if(ele1 == cCode1) {
					result1 = true;
					break;
				}
			}
			tmp1 = result1;
		} else {
			tmp1 = false;
		}
		if(!tmp1) {
			break;
		}
		++begin;
	}
	if(HxOverrides.substr(s,begin,null) == "") {
		SeqPhase1Result.instance().addErr("Empty file!",fileNr);
		return;
	}
	if(HxOverrides.substr(fileContent,0,">".length) != ">" && HxOverrides.substr(fileContent,0,";".length) != ";") {
		SeqPhase1Result.instance().addErr("File does not seem to be a fasta file!",fileNr);
		return;
	}
	var lines = fileContent.split("\n");
	if(lines.length == 0) {
		SeqPhase1Result.instance().addErr("Not a fasta but an empty file!",fileNr);
		return;
	} else if(lines.length == 1) {
		SeqPhase1Result.instance().addErr("Only 1 line detected! Please check data format (opening the alignment in MEGA (http://www.megasoftware.net/) and exporting it as FASTA again may solve the problem; alternatively, there may be a problem with end-of-line characters - see http://en.wikipedia.org/wiki/Newline for details!",fileNr);
		return;
	}
	var entryMap = new haxe_ds_StringMap();
	var current = null;
	var lineNo = 0;
	var underscoreWarningOutputted = false;
	var _g3 = 0;
	while(_g3 < lines.length) {
		var line = lines[_g3];
		++_g3;
		++lineNo;
		var end1 = line.length;
		while(true) {
			var line1;
			if(end1 > 0) {
				var cCode2 = HxOverrides.cca(line,end1 - 1);
				var result2 = false;
				var _g4 = 0;
				var _g12 = [9,10,11,12,13,32,133,160,5760,8192,8192,8193,8194,8195,8196,8197,8198,8199,8200,8201,8202,8232,8233,8239,8287,12288,6158,8203,8204,8205,8288,65279];
				while(_g4 < _g12.length) {
					var ele2 = _g12[_g4];
					++_g4;
					if(ele2 == cCode2) {
						result2 = true;
						break;
					}
				}
				line1 = result2;
			} else {
				line1 = false;
			}
			if(!line1) {
				break;
			}
			--end1;
		}
		var s1 = line.substring(0,end1);
		var begin1 = 0;
		var sLen1 = s1.length;
		while(true) {
			var line2;
			if(begin1 < sLen1) {
				var cCode3 = HxOverrides.cca(s1,begin1);
				var result3 = false;
				var _g5 = 0;
				var _g13 = [9,10,11,12,13,32,133,160,5760,8192,8192,8193,8194,8195,8196,8197,8198,8199,8200,8201,8202,8232,8233,8239,8287,12288,6158,8203,8204,8205,8288,65279];
				while(_g5 < _g13.length) {
					var ele3 = _g13[_g5];
					++_g5;
					if(ele3 == cCode3) {
						result3 = true;
						break;
					}
				}
				line2 = result3;
			} else {
				line2 = false;
			}
			if(!line2) {
				break;
			}
			++begin1;
		}
		line = HxOverrides.substr(s1,begin1,null);
		if(HxOverrides.substr(line,0,";".length) == ";") {
			continue;
		} else if(HxOverrides.substr(line,0,">".length) == ">") {
			var s2 = HxOverrides.substr(line,1,null);
			var end2 = s2.length;
			while(true) {
				var tmp2;
				if(end2 > 0) {
					var cCode4 = HxOverrides.cca(s2,end2 - 1);
					var result4 = false;
					var _g6 = 0;
					var _g14 = [9,10,11,12,13,32,133,160,5760,8192,8192,8193,8194,8195,8196,8197,8198,8199,8200,8201,8202,8232,8233,8239,8287,12288,6158,8203,8204,8205,8288,65279];
					while(_g6 < _g14.length) {
						var ele4 = _g14[_g6];
						++_g6;
						if(ele4 == cCode4) {
							result4 = true;
							break;
						}
					}
					tmp2 = result4;
				} else {
					tmp2 = false;
				}
				if(!tmp2) {
					break;
				}
				--end2;
			}
			var s3 = s2.substring(0,end2);
			var begin2 = 0;
			var sLen2 = s3.length;
			while(true) {
				var tmp3;
				if(begin2 < sLen2) {
					var cCode5 = HxOverrides.cca(s3,begin2);
					var result5 = false;
					var _g7 = 0;
					var _g15 = [9,10,11,12,13,32,133,160,5760,8192,8192,8193,8194,8195,8196,8197,8198,8199,8200,8201,8202,8232,8233,8239,8287,12288,6158,8203,8204,8205,8288,65279];
					while(_g7 < _g15.length) {
						var ele5 = _g15[_g7];
						++_g7;
						if(ele5 == cCode5) {
							result5 = true;
							break;
						}
					}
					tmp3 = result5;
				} else {
					tmp3 = false;
				}
				if(!tmp3) {
					break;
				}
				++begin2;
			}
			var indName = HxOverrides.substr(s3,begin2,null);
			var indNameCor = StringTools.replace(indName," ","_");
			if(indName != indNameCor) {
				if(!underscoreWarningOutputted) {
					SeqPhase1Result.instance().addWrn("Warning: PHASE does not accept spaces in individual names. These spaces got replaced by underscore characters.",fileNr);
					underscoreWarningOutputted = true;
				}
				indName = indNameCor;
			}
			if(__map_reserved[indName] != null ? entryMap.existsReserved(indName) : entryMap.h.hasOwnProperty(indName)) {
				SeqPhase1Result.instance().addErr("Repeat of name " + indName + " encountered in alignment (line " + lineNo + ", line " + (__map_reserved[indName] != null ? entryMap.getReserved(indName) : entryMap.h[indName]).getLineNo() + ")",fileNr);
			}
			current = new Entry(lineNo,indName);
			if(__map_reserved[indName] != null) {
				entryMap.setReserved(indName,current);
			} else {
				entryMap.h[indName] = current;
			}
			if(indName.length == 0) {
				SeqPhase1Result.instance().addErr("Missing sequence name, line " + lineNo,fileNr);
			}
		} else {
			var _g21 = 0;
			var _g16 = line.length;
			while(_g21 < _g16) {
				var i = _g21++;
				var $char = line.charAt(i).toUpperCase();
				var _this = FastaAlignmentParser.authorizedCharacters;
				if(!(__map_reserved[$char] != null ? _this.existsReserved($char) : _this.h.hasOwnProperty($char))) {
					SeqPhase1Result.instance().addErr("Unknown character state " + $char + " in " + current.getName() + ", line " + lineNo,fileNr);
				} else {
					var tmp4;
					if(allChecks) {
						var _this1 = FastaAlignmentParser.authorizedCharacters;
						tmp4 = (__map_reserved[$char] != null ? _this1.getReserved($char) : _this1.h[$char]) == false;
					} else {
						tmp4 = false;
					}
					if(tmp4) {
						SeqPhase1Result.instance().addErr("Unallowed state " + $char + " in " + current.getName() + ", line " + lineNo,fileNr);
					}
				}
			}
			line = line.split("?").join("N");
			current.addToSeq(line.toUpperCase());
		}
	}
	if(current == null) {
		SeqPhase1Result.instance().addErr("Corrupted Fasta File",fileNr);
		return;
	}
	if(current.getSeq() == "") {
		SeqPhase1Result.instance().addErr("Empty sequence " + current.getName() + ", line " + current.getLineNo(),fileNr);
		return;
	}
	this.seqLength = current.getSeq().length;
	var key = entryMap.keys();
	while(key.hasNext()) {
		var key1 = key.next();
		var val = __map_reserved[key1] != null ? entryMap.getReserved(key1) : entryMap.h[key1];
		this.fastaContent.push(val);
		if(val.getSeq().length != current.getSeq().length) {
			SeqPhase1Result.instance().addErr("Not all sequences in this file have equal lengths. E.g. sequence " + val.getName() + " (line " + val.getLineNo() + ") is of length " + val.getSeq().length + " while sequence " + current.getName() + " (line " + current.getLineNo() + ") is of length " + current.getSeq().length,fileNr);
			return;
		}
		if(HxOverrides.substr(val.getSeq(),0,"-".length) == "-") {
			SeqPhase1Result.instance().addWrn("Sequence " + val.getName() + " (line " + val.getLineNo() + ") starts with '-'. Is it a real indel or did you mean 'N' or '?' (missing data)?",fileNr);
		}
		if(val.getSeq().charAt(val.getSeq().length - 1) == "-") {
			SeqPhase1Result.instance().addWrn("Sequence " + val.getName() + " (line " + val.getLineNo() + ") ends with '-'. Is it a real indel or did you mean 'N' or '?' (missing data)?",fileNr);
		}
	}
	this.fastaContent.sort(function(e1,e2) {
		if(allSort) {
			var nameE1 = e1.getName();
			var nameE2 = e1.getName();
			var aNameE1 = nameE1.substring(0,nameE1.length - 1);
			var aNameE2 = nameE2.substring(0,nameE2.length - 1);
			if(aNameE1 < aNameE2) {
				return -1;
			}
			if(aNameE1 > aNameE2) {
				return 1;
			}
			var lNameE1 = nameE1.charAt(nameE1.length - 1);
			var lNameE2 = nameE2.charAt(nameE2.length - 1);
			if(lNameE1 < lNameE2) {
				return -1;
			}
			if(lNameE1 > lNameE2) {
				return 1;
			}
			return 0;
		} else {
			if(e1.getName() < e2.getName()) {
				return -1;
			}
			if(e1.getName() > e2.getName()) {
				return 1;
			}
			return 0;
		}
	});
	if(allChecks) {
		if(this.fastaContent.length % 2 != 0) {
			SeqPhase1Result.instance().addErr("Uneven number of sequences in alignment: please check data.",fileNr);
		}
		var lastName = null;
		var _g8 = 0;
		var _g17 = this.fastaContent;
		while(_g8 < _g17.length) {
			var entry = _g17[_g8];
			++_g8;
			if(lastName == null) {
				lastName = entry.getName();
				lastName = lastName.substring(0,lastName.length - 1);
			} else {
				var curName = entry.getName();
				curName = curName.substring(0,curName.length - 1);
				if(lastName != curName) {
					SeqPhase1Result.instance().addErr("Only one haplotype sequence found for individual " + entry.getName(),fileNr);
				} else {
					lastName = null;
				}
			}
		}
	}
};
$hxClasses["FastaAlignmentParser"] = FastaAlignmentParser;
FastaAlignmentParser.__name__ = ["FastaAlignmentParser"];
FastaAlignmentParser.startsWith = function(t,s) {
	return HxOverrides.substr(t,0,s.length) == s;
};
FastaAlignmentParser.isWhitespace = function(s,pos) {
	var cCode = HxOverrides.cca(s,pos);
	var result = false;
	var _g = 0;
	var _g1 = [9,10,11,12,13,32,133,160,5760,8192,8192,8193,8194,8195,8196,8197,8198,8199,8200,8201,8202,8232,8233,8239,8287,12288,6158,8203,8204,8205,8288,65279];
	while(_g < _g1.length) {
		var ele = _g1[_g];
		++_g;
		if(ele == cCode) {
			result = true;
			break;
		}
	}
	return result;
};
FastaAlignmentParser.stripStringBegin = function(s) {
	var begin = 0;
	var sLen = s.length;
	while(true) {
		var tmp;
		if(begin < sLen) {
			var cCode = HxOverrides.cca(s,begin);
			var result = false;
			var _g = 0;
			var _g1 = [9,10,11,12,13,32,133,160,5760,8192,8192,8193,8194,8195,8196,8197,8198,8199,8200,8201,8202,8232,8233,8239,8287,12288,6158,8203,8204,8205,8288,65279];
			while(_g < _g1.length) {
				var ele = _g1[_g];
				++_g;
				if(ele == cCode) {
					result = true;
					break;
				}
			}
			tmp = result;
		} else {
			tmp = false;
		}
		if(!tmp) {
			break;
		}
		++begin;
	}
	return HxOverrides.substr(s,begin,null);
};
FastaAlignmentParser.stripStringEnd = function(s) {
	var end = s.length;
	while(true) {
		var tmp;
		if(end > 0) {
			var cCode = HxOverrides.cca(s,end - 1);
			var result = false;
			var _g = 0;
			var _g1 = [9,10,11,12,13,32,133,160,5760,8192,8192,8193,8194,8195,8196,8197,8198,8199,8200,8201,8202,8232,8233,8239,8287,12288,6158,8203,8204,8205,8288,65279];
			while(_g < _g1.length) {
				var ele = _g1[_g];
				++_g;
				if(ele == cCode) {
					result = true;
					break;
				}
			}
			tmp = result;
		} else {
			tmp = false;
		}
		if(!tmp) {
			break;
		}
		--end;
	}
	return s.substring(0,end);
};
FastaAlignmentParser.stripString = function(s) {
	var end = s.length;
	while(true) {
		var tmp;
		if(end > 0) {
			var cCode = HxOverrides.cca(s,end - 1);
			var result = false;
			var _g = 0;
			var _g1 = [9,10,11,12,13,32,133,160,5760,8192,8192,8193,8194,8195,8196,8197,8198,8199,8200,8201,8202,8232,8233,8239,8287,12288,6158,8203,8204,8205,8288,65279];
			while(_g < _g1.length) {
				var ele = _g1[_g];
				++_g;
				if(ele == cCode) {
					result = true;
					break;
				}
			}
			tmp = result;
		} else {
			tmp = false;
		}
		if(!tmp) {
			break;
		}
		--end;
	}
	var s1 = s.substring(0,end);
	var begin = 0;
	var sLen = s1.length;
	while(true) {
		var tmp1;
		if(begin < sLen) {
			var cCode1 = HxOverrides.cca(s1,begin);
			var result1 = false;
			var _g2 = 0;
			var _g11 = [9,10,11,12,13,32,133,160,5760,8192,8192,8193,8194,8195,8196,8197,8198,8199,8200,8201,8202,8232,8233,8239,8287,12288,6158,8203,8204,8205,8288,65279];
			while(_g2 < _g11.length) {
				var ele1 = _g11[_g2];
				++_g2;
				if(ele1 == cCode1) {
					result1 = true;
					break;
				}
			}
			tmp1 = result1;
		} else {
			tmp1 = false;
		}
		if(!tmp1) {
			break;
		}
		++begin;
	}
	return HxOverrides.substr(s1,begin,null);
};
FastaAlignmentParser.prototype = {
	fastaContent: null
	,seqLength: null
	,getSeqLength: function() {
		return this.seqLength;
	}
	,getSequences: function() {
		return this.fastaContent;
	}
	,__class__: FastaAlignmentParser
};
var HxOverrides = function() { };
$hxClasses["HxOverrides"] = HxOverrides;
HxOverrides.__name__ = ["HxOverrides"];
HxOverrides.dateStr = function(date) {
	var m = date.getMonth() + 1;
	var d = date.getDate();
	var h = date.getHours();
	var mi = date.getMinutes();
	var s = date.getSeconds();
	return date.getFullYear() + "-" + (m < 10 ? "0" + m : "" + m) + "-" + (d < 10 ? "0" + d : "" + d) + " " + (h < 10 ? "0" + h : "" + h) + ":" + (mi < 10 ? "0" + mi : "" + mi) + ":" + (s < 10 ? "0" + s : "" + s);
};
HxOverrides.strDate = function(s) {
	var _g = s.length;
	switch(_g) {
	case 8:
		var k = s.split(":");
		var d = new Date();
		d["setTime"](0);
		d["setUTCHours"](k[0]);
		d["setUTCMinutes"](k[1]);
		d["setUTCSeconds"](k[2]);
		return d;
	case 10:
		var k1 = s.split("-");
		return new Date(k1[0],k1[1] - 1,k1[2],0,0,0);
	case 19:
		var k2 = s.split(" ");
		var y = k2[0].split("-");
		var t = k2[1].split(":");
		return new Date(y[0],y[1] - 1,y[2],t[0],t[1],t[2]);
	default:
		throw new js__$Boot_HaxeError("Invalid date format : " + s);
	}
};
HxOverrides.cca = function(s,index) {
	var x = s.charCodeAt(index);
	if(x != x) {
		return undefined;
	}
	return x;
};
HxOverrides.substr = function(s,pos,len) {
	if(len == null) {
		len = s.length;
	} else if(len < 0) {
		if(pos == 0) {
			len = s.length + len;
		} else {
			return "";
		}
	}
	return s.substr(pos,len);
};
HxOverrides.indexOf = function(a,obj,i) {
	var len = a.length;
	if(i < 0) {
		i += len;
		if(i < 0) {
			i = 0;
		}
	}
	while(i < len) {
		if(a[i] === obj) {
			return i;
		}
		++i;
	}
	return -1;
};
HxOverrides.lastIndexOf = function(a,obj,i) {
	var len = a.length;
	if(i >= len) {
		i = len - 1;
	} else if(i < 0) {
		i += len;
	}
	while(i >= 0) {
		if(a[i] === obj) {
			return i;
		}
		--i;
	}
	return -1;
};
HxOverrides.remove = function(a,obj) {
	var i = a.indexOf(obj);
	if(i == -1) {
		return false;
	}
	a.splice(i,1);
	return true;
};
HxOverrides.iter = function(a) {
	return { cur : 0, arr : a, hasNext : function() {
		return this.cur < this.arr.length;
	}, next : function() {
		return this.arr[this.cur++];
	}};
};
var IntIterator = function(min,max) {
	this.min = min;
	this.max = max;
};
$hxClasses["IntIterator"] = IntIterator;
IntIterator.__name__ = ["IntIterator"];
IntIterator.prototype = {
	min: null
	,max: null
	,hasNext: function() {
		return this.min < this.max;
	}
	,next: function() {
		return this.min++;
	}
	,__class__: IntIterator
};
var List = function() {
	this.length = 0;
};
$hxClasses["List"] = List;
List.__name__ = ["List"];
List.prototype = {
	h: null
	,q: null
	,length: null
	,add: function(item) {
		var x = new _$List_ListNode(item,null);
		if(this.h == null) {
			this.h = x;
		} else {
			this.q.next = x;
		}
		this.q = x;
		this.length++;
	}
	,push: function(item) {
		var x = new _$List_ListNode(item,this.h);
		this.h = x;
		if(this.q == null) {
			this.q = x;
		}
		this.length++;
	}
	,first: function() {
		if(this.h == null) {
			return null;
		} else {
			return this.h.item;
		}
	}
	,last: function() {
		if(this.q == null) {
			return null;
		} else {
			return this.q.item;
		}
	}
	,pop: function() {
		if(this.h == null) {
			return null;
		}
		var x = this.h.item;
		this.h = this.h.next;
		if(this.h == null) {
			this.q = null;
		}
		this.length--;
		return x;
	}
	,isEmpty: function() {
		return this.h == null;
	}
	,clear: function() {
		this.h = null;
		this.q = null;
		this.length = 0;
	}
	,remove: function(v) {
		var prev = null;
		var l = this.h;
		while(l != null) {
			if(l.item == v) {
				if(prev == null) {
					this.h = l.next;
				} else {
					prev.next = l.next;
				}
				if(this.q == l) {
					this.q = prev;
				}
				this.length--;
				return true;
			}
			prev = l;
			l = l.next;
		}
		return false;
	}
	,iterator: function() {
		return new _$List_ListIterator(this.h);
	}
	,toString: function() {
		var s_b = "";
		var first = true;
		var l = this.h;
		s_b += "{";
		while(l != null) {
			if(first) {
				first = false;
			} else {
				s_b += ", ";
			}
			s_b += Std.string(Std.string(l.item));
			l = l.next;
		}
		s_b += "}";
		return s_b;
	}
	,join: function(sep) {
		var s_b = "";
		var first = true;
		var l = this.h;
		while(l != null) {
			if(first) {
				first = false;
			} else {
				s_b += sep == null ? "null" : "" + sep;
			}
			s_b += Std.string(l.item);
			l = l.next;
		}
		return s_b;
	}
	,filter: function(f) {
		var l2 = new List();
		var l = this.h;
		while(l != null) {
			var v = l.item;
			l = l.next;
			if(f(v)) {
				l2.add(v);
			}
		}
		return l2;
	}
	,map: function(f) {
		var b = new List();
		var l = this.h;
		while(l != null) {
			var v = l.item;
			l = l.next;
			b.add(f(v));
		}
		return b;
	}
	,__class__: List
};
var _$List_ListNode = function(item,next) {
	this.item = item;
	this.next = next;
};
$hxClasses["_List.ListNode"] = _$List_ListNode;
_$List_ListNode.__name__ = ["_List","ListNode"];
_$List_ListNode.prototype = {
	item: null
	,next: null
	,__class__: _$List_ListNode
};
var _$List_ListIterator = function(head) {
	this.head = head;
};
$hxClasses["_List.ListIterator"] = _$List_ListIterator;
_$List_ListIterator.__name__ = ["_List","ListIterator"];
_$List_ListIterator.prototype = {
	head: null
	,hasNext: function() {
		return this.head != null;
	}
	,next: function() {
		var val = this.head.item;
		this.head = this.head.next;
		return val;
	}
	,__class__: _$List_ListIterator
};
Math.__name__ = ["Math"];
var Reflect = function() { };
$hxClasses["Reflect"] = Reflect;
Reflect.__name__ = ["Reflect"];
Reflect.hasField = function(o,field) {
	return Object.prototype.hasOwnProperty.call(o,field);
};
Reflect.field = function(o,field) {
	try {
		return o[field];
	} catch( e ) {
		return null;
	}
};
Reflect.setField = function(o,field,value) {
	o[field] = value;
};
Reflect.getProperty = function(o,field) {
	var tmp;
	if(o == null) {
		return null;
	} else {
		var tmp1;
		if(o.__properties__) {
			tmp = o.__properties__["get_" + field];
			tmp1 = tmp;
		} else {
			tmp1 = false;
		}
		if(tmp1) {
			return o[tmp]();
		} else {
			return o[field];
		}
	}
};
Reflect.setProperty = function(o,field,value) {
	var tmp;
	var tmp1;
	if(o.__properties__) {
		tmp = o.__properties__["set_" + field];
		tmp1 = tmp;
	} else {
		tmp1 = false;
	}
	if(tmp1) {
		o[tmp](value);
	} else {
		o[field] = value;
	}
};
Reflect.callMethod = function(o,func,args) {
	return func.apply(o,args);
};
Reflect.fields = function(o) {
	var a = [];
	if(o != null) {
		var hasOwnProperty = Object.prototype.hasOwnProperty;
		for( var f in o ) {
		if(f != "__id__" && f != "hx__closures__" && hasOwnProperty.call(o,f)) {
			a.push(f);
		}
		}
	}
	return a;
};
Reflect.isFunction = function(f) {
	if(typeof(f) == "function") {
		return !(f.__name__ || f.__ename__);
	} else {
		return false;
	}
};
Reflect.compare = function(a,b) {
	if(a == b) {
		return 0;
	} else if(a > b) {
		return 1;
	} else {
		return -1;
	}
};
Reflect.compareMethods = function(f1,f2) {
	if(f1 == f2) {
		return true;
	}
	if(!Reflect.isFunction(f1) || !Reflect.isFunction(f2)) {
		return false;
	}
	if(f1.scope == f2.scope && f1.method == f2.method) {
		return f1.method != null;
	} else {
		return false;
	}
};
Reflect.isObject = function(v) {
	if(v == null) {
		return false;
	}
	var t = typeof(v);
	if(!(t == "string" || t == "object" && v.__enum__ == null)) {
		if(t == "function") {
			return (v.__name__ || v.__ename__) != null;
		} else {
			return false;
		}
	} else {
		return true;
	}
};
Reflect.isEnumValue = function(v) {
	if(v != null) {
		return v.__enum__ != null;
	} else {
		return false;
	}
};
Reflect.deleteField = function(o,field) {
	if(!Object.prototype.hasOwnProperty.call(o,field)) {
		return false;
	}
	delete(o[field]);
	return true;
};
Reflect.copy = function(o) {
	var o2 = { };
	var _g = 0;
	var _g1 = Reflect.fields(o);
	while(_g < _g1.length) {
		var f = _g1[_g];
		++_g;
		o2[f] = Reflect.field(o,f);
	}
	return o2;
};
Reflect.makeVarArgs = function(f) {
	return function() {
		var a = Array.prototype.slice.call(arguments);
		return f(a);
	};
};
var SeqPhase1 = function() { };
$hxClasses["SeqPhase1"] = SeqPhase1;
SeqPhase1.__name__ = ["SeqPhase1"];
SeqPhase1.doIt = function(align1,align2,align3) {
	SeqPhase1Result.instance().clear();
	var al1 = new FastaAlignmentParser(align1,false,false,1);
	var al2 = new FastaAlignmentParser(align2,true,true,2);
	var al3 = new FastaAlignmentParser(align3,true,false,3);
	var expectedLength = al1.getSeqLength() > al2.getSeqLength() ? al1.getSeqLength() : al2.getSeqLength();
	if(expectedLength > al3.getSeqLength()) {
		expectedLength = expectedLength;
	} else {
		expectedLength = al3.getSeqLength();
	}
	var diffLength = false;
	if(al1.getSeqLength() != -1 && al1.getSeqLength() != expectedLength) {
		diffLength = true;
	}
	if(al2.getSeqLength() != -1 && al2.getSeqLength() != expectedLength) {
		diffLength = true;
	}
	if(al3.getSeqLength() != -1 && al3.getSeqLength() != expectedLength) {
		diffLength = true;
	}
	if(diffLength) {
		SeqPhase1Result.instance().addGeneralError("Not all input sequences have equal lengths, please check whether this is expected.");
	} else if(expectedLength == -1 || expectedLength == 0) {
		SeqPhase1Result.instance().addGeneralError("It seems that all given sequences are empty ...");
	}
	if(SeqPhase1Result.instance().hasErrors()) {
		return SeqPhase1Result.instance();
	}
	var al1a = new List();
	var al1b = new List();
	var _g = 0;
	var _g1 = al1.getSequences();
	while(_g < _g1.length) {
		var entry = _g1[_g];
		++_g;
		var seq1a = new List();
		var seq1b = new List();
		var _g3 = 0;
		var _g2 = entry.getSeq().length;
		while(_g3 < _g2) {
			var i = _g3++;
			var c = entry.getSeq().charAt(i);
			var _this = SeqPhase1.map1;
			if(__map_reserved[c] != null ? _this.existsReserved(c) : _this.h.hasOwnProperty(c)) {
				var _this1 = SeqPhase1.map1;
				seq1a.add(__map_reserved[c] != null ? _this1.getReserved(c) : _this1.h[c]);
				var _this2 = SeqPhase1.map2;
				seq1b.add(__map_reserved[c] != null ? _this2.getReserved(c) : _this2.h[c]);
			} else {
				seq1a.add(c);
				seq1b.add(c);
			}
		}
		al1a.add(new Entry(entry.getLineNo(),entry.getName(),seq1a.join("")));
		al1b.add(new Entry(entry.getLineNo(),entry.getName(),seq1b.join("")));
	}
	var varpos = new List();
	var multipos = new List();
	var multiposMap_h = { };
	var constFileContent = new List();
	var _g11 = 0;
	var _g4 = expectedLength;
	while(_g11 < _g4) {
		var i1 = _g11++;
		var m = new haxe_ds_StringMap();
		var _g2_head = al1a.h;
		while(_g2_head != null) {
			var val = _g2_head.item;
			_g2_head = _g2_head.next;
			var entry1 = val;
			var key = entry1.getSeq().charAt(i1);
			if(__map_reserved[key] != null) {
				m.setReserved(key,false);
			} else {
				m.h[key] = false;
			}
		}
		var _g2_head1 = al1b.h;
		while(_g2_head1 != null) {
			var val1 = _g2_head1.item;
			_g2_head1 = _g2_head1.next;
			var entry2 = val1;
			var key1 = entry2.getSeq().charAt(i1);
			if(__map_reserved[key1] != null) {
				m.setReserved(key1,false);
			} else {
				m.h[key1] = false;
			}
		}
		var _g21 = 0;
		var _g31 = al2.getSequences();
		while(_g21 < _g31.length) {
			var entry3 = _g31[_g21];
			++_g21;
			var key2 = entry3.getSeq().charAt(i1);
			if(__map_reserved[key2] != null) {
				m.setReserved(key2,false);
			} else {
				m.h[key2] = false;
			}
		}
		var _g22 = 0;
		var _g32 = al3.getSequences();
		while(_g22 < _g32.length) {
			var entry4 = _g32[_g22];
			++_g22;
			var key3 = entry4.getSeq().charAt(i1);
			if(__map_reserved[key3] != null) {
				m.setReserved(key3,false);
			} else {
				m.h[key3] = false;
			}
		}
		var mapLen = 0;
		var mapLenWithoutNs = 0;
		var lastKey;
		var key4 = m.keys();
		while(key4.hasNext()) {
			var key5 = key4.next();
			lastKey = key5;
			++mapLen;
			if(key5 != "N") {
				++mapLenWithoutNs;
			}
		}
		if(mapLen == 0) {
			SeqPhase1Result.instance().addGeneralError("Bug detected: There seems to be a bug in this implementation of SeqPHASE. Please contact the author so that they can fix this bug.");
			constFileContent.add("X");
		} else if(mapLen == 1) {
			if(lastKey == "N") {
				SeqPhase1Result.instance().addGeneralWarn("Found only N/? s at position " + (i1 + 1) + ".");
			} else if(lastKey == "-") {
				SeqPhase1Result.instance().addGeneralWarn("Found only -'s at position " + (i1 + 1) + ". This may indicate an alignment problem. Consider to recheck your input data!");
			}
			constFileContent.add(lastKey);
		} else {
			constFileContent.add(".");
			varpos.add(i1);
			if(mapLenWithoutNs > 2) {
				multipos.add(i1);
				multiposMap_h[i1] = true;
			} else {
				multiposMap_h[i1] = false;
			}
		}
	}
	if(varpos.length == 0) {
		SeqPhase1Result.instance().addGeneralError("Not a single variable position detected in dataset! Please check data.");
	} else {
		SeqPhase1Result.instance().addNote("There are " + varpos.length + " variable positions in your dataset, including " + multipos.length + " position(s) with more than two different states.");
	}
	SeqPhase1Result.instance().setConstFile(constFileContent.join(""));
	var lines = new List();
	lines.add("" + (al1a.length + al2.getSequences().length / 2 + al3.getSequences().length / 2 | 0));
	lines.add("" + varpos.length);
	var l1 = new List();
	var l2 = new List();
	var _g_head = varpos.h;
	while(_g_head != null) {
		var val2 = _g_head.item;
		_g_head = _g_head.next;
		var pos = val2;
		l1.add("" + (pos + 1));
		if(multiposMap_h[pos]) {
			l2.add("M");
		} else {
			l2.add("S");
		}
	}
	lines.add("P " + l1.join(" "));
	lines.add(l2.join(" ") + " ");
	var it1 = new _$List_ListIterator(al1a.h);
	var it2 = new _$List_ListIterator(al1b.h);
	while(it1.hasNext()) {
		var e1 = it1.next();
		var e2 = it2.next();
		lines.add(e1.getName());
		var line1 = new List();
		var line2 = new List();
		var _g_head1 = varpos.h;
		while(_g_head1 != null) {
			var val3 = _g_head1.item;
			_g_head1 = _g_head1.next;
			var i2 = val3;
			var $char = e1.getSeq().charAt(i2);
			if($char == "N" && !multiposMap_h.hasOwnProperty(i2)) {
				line1.add("-1");
			} else {
				var _this3 = SeqPhase1.code;
				line1.add(__map_reserved[$char] != null ? _this3.getReserved($char) : _this3.h[$char]);
			}
		}
		var _g_head2 = varpos.h;
		while(_g_head2 != null) {
			var val4 = _g_head2.item;
			_g_head2 = _g_head2.next;
			var i3 = val4;
			var char1 = e2.getSeq().charAt(i3);
			if(char1 == "N" && !multiposMap_h.hasOwnProperty(i3)) {
				line2.add("-1");
			} else {
				var _this4 = SeqPhase1.code;
				line2.add(__map_reserved[char1] != null ? _this4.getReserved(char1) : _this4.h[char1]);
			}
		}
		lines.add(line1.join(" ") + " ");
		lines.add(line2.join(" ") + " ");
	}
	var isOdd = false;
	var _g5 = 0;
	var _g12 = al2.getSequences();
	while(_g5 < _g12.length) {
		var entry5 = _g12[_g5];
		++_g5;
		isOdd = !isOdd;
		if(isOdd) {
			var name = entry5.getName();
			lines.add(HxOverrides.substr(name,0,name.length - 1));
		}
		var line = new List();
		var _g2_head2 = varpos.h;
		while(_g2_head2 != null) {
			var val5 = _g2_head2.item;
			_g2_head2 = _g2_head2.next;
			var i4 = val5;
			var char2 = entry5.getSeq().charAt(i4);
			if(char2 == "N" && !multiposMap_h.hasOwnProperty(i4)) {
				line.add("-1");
			} else {
				var _this5 = SeqPhase1.code;
				line.add(__map_reserved[char2] != null ? _this5.getReserved(char2) : _this5.h[char2]);
			}
		}
		lines.add(line.join(" ") + " ");
	}
	isOdd = false;
	var _g6 = 0;
	var _g13 = al3.getSequences();
	while(_g6 < _g13.length) {
		var entry6 = _g13[_g6];
		++_g6;
		isOdd = !isOdd;
		if(isOdd) {
			var name1 = entry6.getName();
			lines.add(HxOverrides.substr(name1,0,name1.length - 1));
		}
		var line3 = new List();
		var _g2_head3 = varpos.h;
		while(_g2_head3 != null) {
			var val6 = _g2_head3.item;
			_g2_head3 = _g2_head3.next;
			var i5 = val6;
			var char3 = entry6.getSeq().charAt(i5);
			if(char3 == "N" && !multiposMap_h.hasOwnProperty(i5)) {
				line3.add("-1");
			} else {
				var _this6 = SeqPhase1.code;
				line3.add(__map_reserved[char3] != null ? _this6.getReserved(char3) : _this6.h[char3]);
			}
		}
		lines.add(line3.join(" ") + " ");
	}
	lines.add("");
	SeqPhase1Result.instance().setInpFile(lines.join("\n"));
	var knownLines = new List();
	var i6 = varpos.length;
	var result = new List();
	var _g14 = 0;
	var _g7 = i6;
	while(_g14 < _g7) {
		var nnn = _g14++;
		result.add("*");
	}
	var nStr = result.join("");
	var i7 = varpos.length;
	var result1 = new List();
	var _g15 = 0;
	var _g8 = i7;
	while(_g15 < _g8) {
		var nnn1 = _g15++;
		result1.add("0");
	}
	var oStr = result1.join("");
	var _g16 = 0;
	var _g9 = al1.getSequences().length;
	while(_g16 < _g9) {
		var i8 = _g16++;
		knownLines.add(nStr);
	}
	var lll1 = al2.getSequences().length / 2 | 0;
	var _g17 = 0;
	var _g10 = lll1;
	while(_g17 < _g10) {
		var i9 = _g17++;
		knownLines.add(nStr);
	}
	var lll2 = al3.getSequences().length / 2 | 0;
	var _g18 = 0;
	var _g19 = lll2;
	while(_g18 < _g19) {
		var i10 = _g18++;
		knownLines.add(oStr);
	}
	SeqPhase1Result.instance().setKnownFile(knownLines.join("\n"));
	if(al3.getSequences().length == 0) {
		if(multipos.length == 0) {
			SeqPhase1Result.instance().setSuggestedPhaseCommand("PHASE seqphase.inp seqphase.out");
		} else {
			SeqPhase1Result.instance().setSuggestedPhaseCommand("PHASE -d1 seqphase.inp seqphase.out");
		}
	} else if(multipos.length == 0) {
		SeqPhase1Result.instance().setSuggestedPhaseCommand("PHASE -kseqphase.known seqphase.inp seqphase.out");
	} else {
		SeqPhase1Result.instance().setSuggestedPhaseCommand("PHASE -d1 -kseqphase.known seqphase.inp seqphase.out");
	}
	return SeqPhase1Result.instance();
};
SeqPhase1.makeStr = function(c,i) {
	var result = new List();
	var _g1 = 0;
	var _g = i;
	while(_g1 < _g) {
		var nnn = _g1++;
		result.add(c);
	}
	return result.join("");
};
SeqPhase1.main = function() {
};
var SeqPhase1Result = function() {
	this.clear();
};
$hxClasses["SeqPhase1Result"] = SeqPhase1Result;
SeqPhase1Result.__name__ = ["SeqPhase1Result"];
SeqPhase1Result.inst = null;
SeqPhase1Result.instance = function() {
	if(SeqPhase1Result.inst == null) {
		SeqPhase1Result.inst = new SeqPhase1Result();
	}
	return SeqPhase1Result.inst;
};
SeqPhase1Result.prototype = {
	errorsAlign1: null
	,warningsAlign1: null
	,errorsAlign2: null
	,warningsAlign2: null
	,errorsAlign3: null
	,warningsAlign3: null
	,errorsGeneral: null
	,warningsGeneral: null
	,notes: null
	,suggestedPhaseCommand: null
	,varPos: null
	,nbVarPos: null
	,inpFile: null
	,knownFile: null
	,constFile: null
	,clear: function() {
		this.errorsAlign1 = new List();
		this.warningsAlign1 = new List();
		this.errorsAlign2 = new List();
		this.warningsAlign2 = new List();
		this.errorsAlign3 = new List();
		this.warningsAlign3 = new List();
		this.errorsGeneral = new List();
		this.warningsGeneral = new List();
		this.notes = new List();
		this.suggestedPhaseCommand = null;
		this.varPos = null;
		this.nbVarPos = null;
		this.inpFile = null;
		this.knownFile = null;
		this.constFile = null;
	}
	,addErr: function(err,nr) {
		if(nr == 1) {
			this.addAlign1Error(err);
		} else if(nr == 2) {
			this.addAlign2Error(err);
		} else if(nr == 3) {
			this.addAlign3Error(err);
		} else {
			throw new js__$Boot_HaxeError("Illegal nr " + nr);
		}
	}
	,addWrn: function(wrn,nr) {
		if(nr == 1) {
			this.addAlign1Warn(wrn);
		} else if(nr == 2) {
			this.addAlign2Warn(wrn);
		} else if(nr == 3) {
			this.addAlign3Warn(wrn);
		} else {
			throw new js__$Boot_HaxeError("Illegal nr " + nr);
		}
	}
	,addAlign1Error: function(err) {
		this.errorsAlign1.add(err);
	}
	,hasAlign1Errors: function() {
		return this.errorsAlign1.length != 0;
	}
	,getAlign1Errors: function() {
		var length = this.errorsAlign1.length;
		var this1 = new Array(length);
		var result = this1;
		var i = 0;
		var _g_head = this.errorsAlign1.h;
		while(_g_head != null) {
			var val = _g_head.item;
			_g_head = _g_head.next;
			var item = val;
			result[i++] = item;
		}
		return result;
	}
	,addAlign1Warn: function(wrn) {
		this.warningsAlign1.add(wrn);
	}
	,hasAlign1Warn: function() {
		return this.warningsAlign1.length != 0;
	}
	,getAlign1Warn: function() {
		var length = this.warningsAlign1.length;
		var this1 = new Array(length);
		var result = this1;
		var i = 0;
		var _g_head = this.warningsAlign1.h;
		while(_g_head != null) {
			var val = _g_head.item;
			_g_head = _g_head.next;
			var item = val;
			result[i++] = item;
		}
		return result;
	}
	,addAlign2Error: function(err) {
		this.errorsAlign2.add(err);
	}
	,hasAlign2Errors: function() {
		return this.errorsAlign2.length != 0;
	}
	,getAlign2Errors: function() {
		var length = this.errorsAlign2.length;
		var this1 = new Array(length);
		var result = this1;
		var i = 0;
		var _g_head = this.errorsAlign2.h;
		while(_g_head != null) {
			var val = _g_head.item;
			_g_head = _g_head.next;
			var item = val;
			result[i++] = item;
		}
		return result;
	}
	,addAlign2Warn: function(wrn) {
		this.warningsAlign2.add(wrn);
	}
	,hasAlign2Warn: function() {
		return this.warningsAlign2.length != 0;
	}
	,getAlign2Warn: function() {
		var length = this.warningsAlign2.length;
		var this1 = new Array(length);
		var result = this1;
		var i = 0;
		var _g_head = this.warningsAlign2.h;
		while(_g_head != null) {
			var val = _g_head.item;
			_g_head = _g_head.next;
			var item = val;
			result[i++] = item;
		}
		return result;
	}
	,addAlign3Error: function(err) {
		this.errorsAlign3.add(err);
	}
	,hasAlign3Errors: function() {
		return this.errorsAlign3.length != 0;
	}
	,getAlign3Errors: function() {
		var length = this.errorsAlign3.length;
		var this1 = new Array(length);
		var result = this1;
		var i = 0;
		var _g_head = this.errorsAlign3.h;
		while(_g_head != null) {
			var val = _g_head.item;
			_g_head = _g_head.next;
			var item = val;
			result[i++] = item;
		}
		return result;
	}
	,addAlign3Warn: function(wrn) {
		this.warningsAlign3.add(wrn);
	}
	,hasAlign3Warn: function() {
		return this.warningsAlign3.length != 0;
	}
	,getAlign3Warn: function() {
		var length = this.warningsAlign3.length;
		var this1 = new Array(length);
		var result = this1;
		var i = 0;
		var _g_head = this.warningsAlign3.h;
		while(_g_head != null) {
			var val = _g_head.item;
			_g_head = _g_head.next;
			var item = val;
			result[i++] = item;
		}
		return result;
	}
	,addGeneralError: function(err) {
		this.errorsGeneral.add(err);
	}
	,hasGeneralErrors: function() {
		return this.errorsGeneral.length != 0;
	}
	,getGeneralErrors: function() {
		var length = this.errorsGeneral.length;
		var this1 = new Array(length);
		var result = this1;
		var i = 0;
		var _g_head = this.errorsGeneral.h;
		while(_g_head != null) {
			var val = _g_head.item;
			_g_head = _g_head.next;
			var item = val;
			result[i++] = item;
		}
		return result;
	}
	,addGeneralWarn: function(wrn) {
		this.warningsGeneral.add(wrn);
	}
	,hasGeneralWarn: function() {
		return this.warningsGeneral.length != 0;
	}
	,getGeneralWarn: function() {
		var length = this.warningsGeneral.length;
		var this1 = new Array(length);
		var result = this1;
		var i = 0;
		var _g_head = this.warningsGeneral.h;
		while(_g_head != null) {
			var val = _g_head.item;
			_g_head = _g_head.next;
			var item = val;
			result[i++] = item;
		}
		return result;
	}
	,hasErrors: function() {
		if(!(this.errorsAlign1.length > 0 || this.errorsAlign2.length > 0 || this.errorsAlign3.length > 0)) {
			return this.errorsGeneral.length > 0;
		} else {
			return true;
		}
	}
	,addNote: function(note) {
		this.notes.add(note);
	}
	,hasNotes: function() {
		return this.notes.length != 0;
	}
	,getNotes: function() {
		var length = this.notes.length;
		var this1 = new Array(length);
		var result = this1;
		var i = 0;
		var _g_head = this.notes.h;
		while(_g_head != null) {
			var val = _g_head.item;
			_g_head = _g_head.next;
			var item = val;
			result[i++] = item;
		}
		return result;
	}
	,setSuggestedPhaseCommand: function(ph) {
		this.suggestedPhaseCommand = ph;
	}
	,hasSuggestedCommand: function() {
		return this.suggestedPhaseCommand != null;
	}
	,getSuggestedPhaseCommand: function() {
		return this.suggestedPhaseCommand;
	}
	,setNrVarPos: function(nr) {
		this.varPos = nr;
	}
	,getNrVarPos: function() {
		return this.varPos;
	}
	,setNrNbVarPos: function(nr) {
		this.nbVarPos = nr;
	}
	,getNrNbVarPos: function() {
		return this.nbVarPos;
	}
	,setInpFile: function(content) {
		this.inpFile = content;
	}
	,hasInpFile: function() {
		return this.inpFile != null;
	}
	,getInpFile: function() {
		return this.inpFile;
	}
	,setKnownFile: function(content) {
		this.knownFile = content;
	}
	,hasKnownFile: function() {
		return this.knownFile != null;
	}
	,getKnownFile: function() {
		return this.knownFile;
	}
	,setConstFile: function(content) {
		this.constFile = content;
	}
	,hasConstFile: function() {
		return this.constFile != null;
	}
	,getConstFile: function() {
		return this.constFile;
	}
	,__class__: SeqPhase1Result
};
var Std = function() { };
$hxClasses["Std"] = Std;
Std.__name__ = ["Std"];
Std["is"] = function(v,t) {
	return js_Boot.__instanceof(v,t);
};
Std.instance = function(value,c) {
	if((value instanceof c)) {
		return value;
	} else {
		return null;
	}
};
Std.string = function(s) {
	return js_Boot.__string_rec(s,"");
};
Std["int"] = function(x) {
	return x | 0;
};
Std.parseInt = function(x) {
	var v = parseInt(x,10);
	if(v == 0 && (HxOverrides.cca(x,1) == 120 || HxOverrides.cca(x,1) == 88)) {
		v = parseInt(x);
	}
	if(isNaN(v)) {
		return null;
	}
	return v;
};
Std.parseFloat = function(x) {
	return parseFloat(x);
};
Std.random = function(x) {
	if(x <= 0) {
		return 0;
	} else {
		return Math.floor(Math.random() * x);
	}
};
var StringBuf = function() {
	this.b = "";
};
$hxClasses["StringBuf"] = StringBuf;
StringBuf.__name__ = ["StringBuf"];
StringBuf.prototype = {
	b: null
	,get_length: function() {
		return this.b.length;
	}
	,add: function(x) {
		this.b += Std.string(x);
	}
	,addChar: function(c) {
		this.b += String.fromCharCode(c);
	}
	,addSub: function(s,pos,len) {
		this.b += len == null ? HxOverrides.substr(s,pos,null) : HxOverrides.substr(s,pos,len);
	}
	,toString: function() {
		return this.b;
	}
	,__class__: StringBuf
	,__properties__: {get_length:"get_length"}
};
var StringTools = function() { };
$hxClasses["StringTools"] = StringTools;
StringTools.__name__ = ["StringTools"];
StringTools.urlEncode = function(s) {
	return encodeURIComponent(s);
};
StringTools.urlDecode = function(s) {
	return decodeURIComponent(s.split("+").join(" "));
};
StringTools.htmlEscape = function(s,quotes) {
	s = s.split("&").join("&amp;").split("<").join("&lt;").split(">").join("&gt;");
	if(quotes) {
		return s.split("\"").join("&quot;").split("'").join("&#039;");
	} else {
		return s;
	}
};
StringTools.htmlUnescape = function(s) {
	return s.split("&gt;").join(">").split("&lt;").join("<").split("&quot;").join("\"").split("&#039;").join("'").split("&amp;").join("&");
};
StringTools.startsWith = function(s,start) {
	if(s.length >= start.length) {
		return HxOverrides.substr(s,0,start.length) == start;
	} else {
		return false;
	}
};
StringTools.endsWith = function(s,end) {
	var elen = end.length;
	var slen = s.length;
	if(slen >= elen) {
		return HxOverrides.substr(s,slen - elen,elen) == end;
	} else {
		return false;
	}
};
StringTools.isSpace = function(s,pos) {
	var c = HxOverrides.cca(s,pos);
	if(!(c > 8 && c < 14)) {
		return c == 32;
	} else {
		return true;
	}
};
StringTools.ltrim = function(s) {
	var l = s.length;
	var r = 0;
	while(r < l && StringTools.isSpace(s,r)) ++r;
	if(r > 0) {
		return HxOverrides.substr(s,r,l - r);
	} else {
		return s;
	}
};
StringTools.rtrim = function(s) {
	var l = s.length;
	var r = 0;
	while(r < l && StringTools.isSpace(s,l - r - 1)) ++r;
	if(r > 0) {
		return HxOverrides.substr(s,0,l - r);
	} else {
		return s;
	}
};
StringTools.trim = function(s) {
	return StringTools.ltrim(StringTools.rtrim(s));
};
StringTools.lpad = function(s,c,l) {
	if(c.length <= 0) {
		return s;
	}
	while(s.length < l) s = c + s;
	return s;
};
StringTools.rpad = function(s,c,l) {
	if(c.length <= 0) {
		return s;
	}
	while(s.length < l) s += c;
	return s;
};
StringTools.replace = function(s,sub,by) {
	return s.split(sub).join(by);
};
StringTools.hex = function(n,digits) {
	var s = "";
	var hexChars = "0123456789ABCDEF";
	while(true) {
		s = hexChars.charAt(n & 15) + s;
		n >>>= 4;
		if(!(n > 0)) {
			break;
		}
	}
	if(digits != null) {
		while(s.length < digits) s = "0" + s;
	}
	return s;
};
StringTools.fastCodeAt = function(s,index) {
	return s.charCodeAt(index);
};
StringTools.isEof = function(c) {
	return c != c;
};
StringTools.quoteUnixArg = function(argument) {
	if(argument == "") {
		return "''";
	}
	if(!new EReg("[^a-zA-Z0-9_@%+=:,./-]","").match(argument)) {
		return argument;
	}
	return "'" + StringTools.replace(argument,"'","'\"'\"'") + "'";
};
StringTools.quoteWinArg = function(argument,escapeMetaCharacters) {
	if(!new EReg("^[^ \t\\\\\"]+$","").match(argument)) {
		var result_b = "";
		var needquote = argument.indexOf(" ") != -1 || argument.indexOf("\t") != -1 || argument == "";
		if(needquote) {
			result_b += "\"";
		}
		var bs_buf = new StringBuf();
		var _g1 = 0;
		var _g = argument.length;
		while(_g1 < _g) {
			var i = _g1++;
			var _g2 = HxOverrides.cca(argument,i);
			if(_g2 == null) {
				var c = _g2;
				if(bs_buf.b.length > 0) {
					result_b += Std.string(bs_buf.b);
					bs_buf = new StringBuf();
				}
				result_b += String.fromCharCode(c);
			} else {
				switch(_g2) {
				case 34:
					var bs = bs_buf.b;
					result_b += bs == null ? "null" : "" + bs;
					result_b += bs == null ? "null" : "" + bs;
					bs_buf = new StringBuf();
					result_b += "\\\"";
					break;
				case 92:
					bs_buf.b += "\\";
					break;
				default:
					var c1 = _g2;
					if(bs_buf.b.length > 0) {
						result_b += Std.string(bs_buf.b);
						bs_buf = new StringBuf();
					}
					result_b += String.fromCharCode(c1);
				}
			}
		}
		result_b += Std.string(bs_buf.b);
		if(needquote) {
			result_b += Std.string(bs_buf.b);
			result_b += "\"";
		}
		argument = result_b;
	}
	if(escapeMetaCharacters) {
		var result_b1 = "";
		var _g11 = 0;
		var _g3 = argument.length;
		while(_g11 < _g3) {
			var i1 = _g11++;
			var c2 = HxOverrides.cca(argument,i1);
			if(StringTools.winMetaCharacters.indexOf(c2) >= 0) {
				result_b1 += "^";
			}
			result_b1 += String.fromCharCode(c2);
		}
		return result_b1;
	} else {
		return argument;
	}
};
var ValueType = $hxClasses["ValueType"] = { __ename__ : ["ValueType"], __constructs__ : ["TNull","TInt","TFloat","TBool","TObject","TFunction","TClass","TEnum","TUnknown"] };
ValueType.TNull = ["TNull",0];
ValueType.TNull.toString = $estr;
ValueType.TNull.__enum__ = ValueType;
ValueType.TInt = ["TInt",1];
ValueType.TInt.toString = $estr;
ValueType.TInt.__enum__ = ValueType;
ValueType.TFloat = ["TFloat",2];
ValueType.TFloat.toString = $estr;
ValueType.TFloat.__enum__ = ValueType;
ValueType.TBool = ["TBool",3];
ValueType.TBool.toString = $estr;
ValueType.TBool.__enum__ = ValueType;
ValueType.TObject = ["TObject",4];
ValueType.TObject.toString = $estr;
ValueType.TObject.__enum__ = ValueType;
ValueType.TFunction = ["TFunction",5];
ValueType.TFunction.toString = $estr;
ValueType.TFunction.__enum__ = ValueType;
ValueType.TClass = function(c) { var $x = ["TClass",6,c]; $x.__enum__ = ValueType; $x.toString = $estr; return $x; };
ValueType.TEnum = function(e) { var $x = ["TEnum",7,e]; $x.__enum__ = ValueType; $x.toString = $estr; return $x; };
ValueType.TUnknown = ["TUnknown",8];
ValueType.TUnknown.toString = $estr;
ValueType.TUnknown.__enum__ = ValueType;
ValueType.__empty_constructs__ = [ValueType.TNull,ValueType.TInt,ValueType.TFloat,ValueType.TBool,ValueType.TObject,ValueType.TFunction,ValueType.TUnknown];
var Type = function() { };
$hxClasses["Type"] = Type;
Type.__name__ = ["Type"];
Type.getClass = function(o) {
	if(o == null) {
		return null;
	} else {
		return js_Boot.getClass(o);
	}
};
Type.getEnum = function(o) {
	if(o == null) {
		return null;
	}
	return o.__enum__;
};
Type.getSuperClass = function(c) {
	return c.__super__;
};
Type.getClassName = function(c) {
	var a = c.__name__;
	if(a == null) {
		return null;
	}
	return a.join(".");
};
Type.getEnumName = function(e) {
	var a = e.__ename__;
	return a.join(".");
};
Type.resolveClass = function(name) {
	var cl = $hxClasses[name];
	if(cl == null || !cl.__name__) {
		return null;
	}
	return cl;
};
Type.resolveEnum = function(name) {
	var e = $hxClasses[name];
	if(e == null || !e.__ename__) {
		return null;
	}
	return e;
};
Type.createInstance = function(cl,args) {
	var _g = args.length;
	switch(_g) {
	case 0:
		return new cl();
	case 1:
		return new cl(args[0]);
	case 2:
		return new cl(args[0],args[1]);
	case 3:
		return new cl(args[0],args[1],args[2]);
	case 4:
		return new cl(args[0],args[1],args[2],args[3]);
	case 5:
		return new cl(args[0],args[1],args[2],args[3],args[4]);
	case 6:
		return new cl(args[0],args[1],args[2],args[3],args[4],args[5]);
	case 7:
		return new cl(args[0],args[1],args[2],args[3],args[4],args[5],args[6]);
	case 8:
		return new cl(args[0],args[1],args[2],args[3],args[4],args[5],args[6],args[7]);
	case 9:
		return new cl(args[0],args[1],args[2],args[3],args[4],args[5],args[6],args[7],args[8]);
	case 10:
		return new cl(args[0],args[1],args[2],args[3],args[4],args[5],args[6],args[7],args[8],args[9]);
	case 11:
		return new cl(args[0],args[1],args[2],args[3],args[4],args[5],args[6],args[7],args[8],args[9],args[10]);
	case 12:
		return new cl(args[0],args[1],args[2],args[3],args[4],args[5],args[6],args[7],args[8],args[9],args[10],args[11]);
	case 13:
		return new cl(args[0],args[1],args[2],args[3],args[4],args[5],args[6],args[7],args[8],args[9],args[10],args[11],args[12]);
	case 14:
		return new cl(args[0],args[1],args[2],args[3],args[4],args[5],args[6],args[7],args[8],args[9],args[10],args[11],args[12],args[13]);
	default:
		throw new js__$Boot_HaxeError("Too many arguments");
	}
};
Type.createEmptyInstance = function(cl) {
	function empty() {}; empty.prototype = cl.prototype;
	return new empty();
};
Type.createEnum = function(e,constr,params) {
	var f = Reflect.field(e,constr);
	if(f == null) {
		throw new js__$Boot_HaxeError("No such constructor " + constr);
	}
	if(Reflect.isFunction(f)) {
		if(params == null) {
			throw new js__$Boot_HaxeError("Constructor " + constr + " need parameters");
		}
		return f.apply(e,params);
	}
	if(params != null && params.length != 0) {
		throw new js__$Boot_HaxeError("Constructor " + constr + " does not need parameters");
	}
	return f;
};
Type.createEnumIndex = function(e,index,params) {
	var c = e.__constructs__[index];
	if(c == null) {
		throw new js__$Boot_HaxeError(index + " is not a valid enum constructor index");
	}
	return Type.createEnum(e,c,params);
};
Type.getInstanceFields = function(c) {
	var a = [];
	for(var i in c.prototype) a.push(i);
	HxOverrides.remove(a,"__class__");
	HxOverrides.remove(a,"__properties__");
	return a;
};
Type.getClassFields = function(c) {
	var a = Reflect.fields(c);
	HxOverrides.remove(a,"__name__");
	HxOverrides.remove(a,"__interfaces__");
	HxOverrides.remove(a,"__properties__");
	HxOverrides.remove(a,"__super__");
	HxOverrides.remove(a,"__meta__");
	HxOverrides.remove(a,"prototype");
	return a;
};
Type.getEnumConstructs = function(e) {
	return e.__constructs__.slice();
};
Type["typeof"] = function(v) {
	var _g = typeof(v);
	switch(_g) {
	case "boolean":
		return ValueType.TBool;
	case "function":
		if(v.__name__ || v.__ename__) {
			return ValueType.TObject;
		}
		return ValueType.TFunction;
	case "number":
		if(Math.ceil(v) == v % 2147483648.0) {
			return ValueType.TInt;
		}
		return ValueType.TFloat;
	case "object":
		if(v == null) {
			return ValueType.TNull;
		}
		var e = v.__enum__;
		if(e != null) {
			return ValueType.TEnum(e);
		}
		var c = js_Boot.getClass(v);
		if(c != null) {
			return ValueType.TClass(c);
		}
		return ValueType.TObject;
	case "string":
		return ValueType.TClass(String);
	case "undefined":
		return ValueType.TNull;
	default:
		return ValueType.TUnknown;
	}
};
Type.enumEq = function(a,b) {
	if(a == b) {
		return true;
	}
	try {
		if(a[0] != b[0]) {
			return false;
		}
		var _g1 = 2;
		var _g = a.length;
		while(_g1 < _g) {
			var i = _g1++;
			if(!Type.enumEq(a[i],b[i])) {
				return false;
			}
		}
		var e = a.__enum__;
		if(e != b.__enum__ || e == null) {
			return false;
		}
	} catch( e1 ) {
		return false;
	}
	return true;
};
Type.enumConstructor = function(e) {
	return e[0];
};
Type.enumParameters = function(e) {
	return e.slice(2);
};
Type.enumIndex = function(e) {
	return e[1];
};
Type.allEnums = function(e) {
	return e.__empty_constructs__;
};
var haxe_IMap = function() { };
$hxClasses["haxe.IMap"] = haxe_IMap;
haxe_IMap.__name__ = ["haxe","IMap"];
haxe_IMap.prototype = {
	get: null
	,set: null
	,exists: null
	,remove: null
	,keys: null
	,iterator: null
	,toString: null
	,__class__: haxe_IMap
};
var haxe_ds_ArraySort = function() { };
$hxClasses["haxe.ds.ArraySort"] = haxe_ds_ArraySort;
haxe_ds_ArraySort.__name__ = ["haxe","ds","ArraySort"];
haxe_ds_ArraySort.sort = function(a,cmp) {
	haxe_ds_ArraySort.rec(a,cmp,0,a.length);
};
haxe_ds_ArraySort.rec = function(a,cmp,from,to) {
	var middle = from + to >> 1;
	if(to - from < 12) {
		if(to <= from) {
			return;
		}
		var _g1 = from + 1;
		var _g = to;
		while(_g1 < _g) {
			var i = _g1++;
			var j = i;
			while(j > from) {
				if(cmp(a[j],a[j - 1]) < 0) {
					haxe_ds_ArraySort.swap(a,j - 1,j);
				} else {
					break;
				}
				--j;
			}
		}
		return;
	}
	haxe_ds_ArraySort.rec(a,cmp,from,middle);
	haxe_ds_ArraySort.rec(a,cmp,middle,to);
	haxe_ds_ArraySort.doMerge(a,cmp,from,middle,to,middle - from,to - middle);
};
haxe_ds_ArraySort.doMerge = function(a,cmp,from,pivot,to,len1,len2) {
	var first_cut;
	var second_cut;
	var len11;
	var len22;
	var new_mid;
	if(len1 == 0 || len2 == 0) {
		return;
	}
	if(len1 + len2 == 2) {
		if(cmp(a[pivot],a[from]) < 0) {
			haxe_ds_ArraySort.swap(a,pivot,from);
		}
		return;
	}
	if(len1 > len2) {
		len11 = len1 >> 1;
		first_cut = from + len11;
		second_cut = haxe_ds_ArraySort.lower(a,cmp,pivot,to,first_cut);
		len22 = second_cut - pivot;
	} else {
		len22 = len2 >> 1;
		second_cut = pivot + len22;
		first_cut = haxe_ds_ArraySort.upper(a,cmp,from,pivot,second_cut);
		len11 = first_cut - from;
	}
	haxe_ds_ArraySort.rotate(a,cmp,first_cut,pivot,second_cut);
	new_mid = first_cut + len22;
	haxe_ds_ArraySort.doMerge(a,cmp,from,first_cut,new_mid,len11,len22);
	haxe_ds_ArraySort.doMerge(a,cmp,new_mid,second_cut,to,len1 - len11,len2 - len22);
};
haxe_ds_ArraySort.rotate = function(a,cmp,from,mid,to) {
	var n;
	if(from == mid || mid == to) {
		return;
	}
	n = haxe_ds_ArraySort.gcd(to - from,mid - from);
	while(n-- != 0) {
		var val = a[from + n];
		var shift = mid - from;
		var p1 = from + n;
		var p2 = from + n + shift;
		while(p2 != from + n) {
			a[p1] = a[p2];
			p1 = p2;
			if(to - p2 > shift) {
				p2 += shift;
			} else {
				p2 = from + (shift - (to - p2));
			}
		}
		a[p1] = val;
	}
};
haxe_ds_ArraySort.gcd = function(m,n) {
	while(n != 0) {
		var t = m % n;
		m = n;
		n = t;
	}
	return m;
};
haxe_ds_ArraySort.upper = function(a,cmp,from,to,val) {
	var len = to - from;
	var half;
	var mid;
	while(len > 0) {
		half = len >> 1;
		mid = from + half;
		if(cmp(a[val],a[mid]) < 0) {
			len = half;
		} else {
			from = mid + 1;
			len = len - half - 1;
		}
	}
	return from;
};
haxe_ds_ArraySort.lower = function(a,cmp,from,to,val) {
	var len = to - from;
	var half;
	var mid;
	while(len > 0) {
		half = len >> 1;
		mid = from + half;
		if(cmp(a[mid],a[val]) < 0) {
			from = mid + 1;
			len = len - half - 1;
		} else {
			len = half;
		}
	}
	return from;
};
haxe_ds_ArraySort.swap = function(a,i,j) {
	var tmp = a[i];
	a[i] = a[j];
	a[j] = tmp;
};
haxe_ds_ArraySort.compare = function(a,cmp,i,j) {
	return cmp(a[i],a[j]);
};
var haxe_ds_BalancedTree = function() {
};
$hxClasses["haxe.ds.BalancedTree"] = haxe_ds_BalancedTree;
haxe_ds_BalancedTree.__name__ = ["haxe","ds","BalancedTree"];
haxe_ds_BalancedTree.prototype = {
	root: null
	,set: function(key,value) {
		this.root = this.setLoop(key,value,this.root);
	}
	,get: function(key) {
		var node = this.root;
		while(node != null) {
			var c = this.compare(key,node.key);
			if(c == 0) {
				return node.value;
			}
			if(c < 0) {
				node = node.left;
			} else {
				node = node.right;
			}
		}
		return null;
	}
	,remove: function(key) {
		try {
			this.root = this.removeLoop(key,this.root);
			return true;
		} catch( e ) {
			if (e instanceof js__$Boot_HaxeError) e = e.val;
			if( js_Boot.__instanceof(e,String) ) {
				return false;
			} else throw(e);
		}
	}
	,exists: function(key) {
		var node = this.root;
		while(node != null) {
			var c = this.compare(key,node.key);
			if(c == 0) {
				return true;
			} else if(c < 0) {
				node = node.left;
			} else {
				node = node.right;
			}
		}
		return false;
	}
	,iterator: function() {
		var ret = [];
		this.iteratorLoop(this.root,ret);
		return HxOverrides.iter(ret);
	}
	,keys: function() {
		var ret = [];
		this.keysLoop(this.root,ret);
		return HxOverrides.iter(ret);
	}
	,setLoop: function(k,v,node) {
		if(node == null) {
			return new haxe_ds_TreeNode(null,k,v,null);
		}
		var c = this.compare(k,node.key);
		if(c == 0) {
			return new haxe_ds_TreeNode(node.left,k,v,node.right,node == null ? 0 : node._height);
		} else if(c < 0) {
			var nl = this.setLoop(k,v,node.left);
			return this.balance(nl,node.key,node.value,node.right);
		} else {
			var nr = this.setLoop(k,v,node.right);
			return this.balance(node.left,node.key,node.value,nr);
		}
	}
	,removeLoop: function(k,node) {
		if(node == null) {
			throw new js__$Boot_HaxeError("Not_found");
		}
		var c = this.compare(k,node.key);
		if(c == 0) {
			return this.merge(node.left,node.right);
		} else if(c < 0) {
			return this.balance(this.removeLoop(k,node.left),node.key,node.value,node.right);
		} else {
			return this.balance(node.left,node.key,node.value,this.removeLoop(k,node.right));
		}
	}
	,iteratorLoop: function(node,acc) {
		if(node != null) {
			this.iteratorLoop(node.left,acc);
			acc.push(node.value);
			this.iteratorLoop(node.right,acc);
		}
	}
	,keysLoop: function(node,acc) {
		if(node != null) {
			this.keysLoop(node.left,acc);
			acc.push(node.key);
			this.keysLoop(node.right,acc);
		}
	}
	,merge: function(t1,t2) {
		if(t1 == null) {
			return t2;
		}
		if(t2 == null) {
			return t1;
		}
		var t = this.minBinding(t2);
		return this.balance(t1,t.key,t.value,this.removeMinBinding(t2));
	}
	,minBinding: function(t) {
		if(t == null) {
			throw new js__$Boot_HaxeError("Not_found");
		} else if(t.left == null) {
			return t;
		} else {
			return this.minBinding(t.left);
		}
	}
	,removeMinBinding: function(t) {
		if(t.left == null) {
			return t.right;
		} else {
			return this.balance(this.removeMinBinding(t.left),t.key,t.value,t.right);
		}
	}
	,balance: function(l,k,v,r) {
		var hl = l == null ? 0 : l._height;
		var hr = r == null ? 0 : r._height;
		if(hl > hr + 2) {
			var _this = l.left;
			var _this1 = l.right;
			if((_this == null ? 0 : _this._height) >= (_this1 == null ? 0 : _this1._height)) {
				return new haxe_ds_TreeNode(l.left,l.key,l.value,new haxe_ds_TreeNode(l.right,k,v,r));
			} else {
				return new haxe_ds_TreeNode(new haxe_ds_TreeNode(l.left,l.key,l.value,l.right.left),l.right.key,l.right.value,new haxe_ds_TreeNode(l.right.right,k,v,r));
			}
		} else if(hr > hl + 2) {
			var _this2 = r.right;
			var _this3 = r.left;
			if((_this2 == null ? 0 : _this2._height) > (_this3 == null ? 0 : _this3._height)) {
				return new haxe_ds_TreeNode(new haxe_ds_TreeNode(l,k,v,r.left),r.key,r.value,r.right);
			} else {
				return new haxe_ds_TreeNode(new haxe_ds_TreeNode(l,k,v,r.left.left),r.left.key,r.left.value,new haxe_ds_TreeNode(r.left.right,r.key,r.value,r.right));
			}
		} else {
			return new haxe_ds_TreeNode(l,k,v,r,(hl > hr ? hl : hr) + 1);
		}
	}
	,compare: function(k1,k2) {
		return Reflect.compare(k1,k2);
	}
	,toString: function() {
		if(this.root == null) {
			return "{}";
		} else {
			return "{" + this.root.toString() + "}";
		}
	}
	,__class__: haxe_ds_BalancedTree
};
var haxe_ds_TreeNode = function(l,k,v,r,h) {
	if(h == null) {
		h = -1;
	}
	this.left = l;
	this.key = k;
	this.value = v;
	this.right = r;
	if(h == -1) {
		var tmp;
		var _this = this.left;
		var _this1 = this.right;
		if((_this == null ? 0 : _this._height) > (_this1 == null ? 0 : _this1._height)) {
			var _this2 = this.left;
			if(_this2 == null) {
				tmp = 0;
			} else {
				tmp = _this2._height;
			}
		} else {
			var _this3 = this.right;
			if(_this3 == null) {
				tmp = 0;
			} else {
				tmp = _this3._height;
			}
		}
		this._height = tmp + 1;
	} else {
		this._height = h;
	}
};
$hxClasses["haxe.ds.TreeNode"] = haxe_ds_TreeNode;
haxe_ds_TreeNode.__name__ = ["haxe","ds","TreeNode"];
haxe_ds_TreeNode.prototype = {
	left: null
	,right: null
	,key: null
	,value: null
	,_height: null
	,toString: function() {
		return (this.left == null ? "" : this.left.toString() + ", ") + ("" + Std.string(this.key) + "=" + Std.string(this.value)) + (this.right == null ? "" : ", " + this.right.toString());
	}
	,__class__: haxe_ds_TreeNode
};
var haxe_ds_EnumValueMap = function() {
	haxe_ds_BalancedTree.call(this);
};
$hxClasses["haxe.ds.EnumValueMap"] = haxe_ds_EnumValueMap;
haxe_ds_EnumValueMap.__name__ = ["haxe","ds","EnumValueMap"];
haxe_ds_EnumValueMap.__interfaces__ = [haxe_IMap];
haxe_ds_EnumValueMap.__super__ = haxe_ds_BalancedTree;
haxe_ds_EnumValueMap.prototype = $extend(haxe_ds_BalancedTree.prototype,{
	compare: function(k1,k2) {
		var d = k1[1] - k2[1];
		if(d != 0) {
			return d;
		}
		var p1 = k1.slice(2);
		var p2 = k2.slice(2);
		if(p1.length == 0 && p2.length == 0) {
			return 0;
		}
		return this.compareArgs(p1,p2);
	}
	,compareArgs: function(a1,a2) {
		var ld = a1.length - a2.length;
		if(ld != 0) {
			return ld;
		}
		var _g1 = 0;
		var _g = a1.length;
		while(_g1 < _g) {
			var i = _g1++;
			var d = this.compareArg(a1[i],a2[i]);
			if(d != 0) {
				return d;
			}
		}
		return 0;
	}
	,compareArg: function(v1,v2) {
		if(Reflect.isEnumValue(v1) && Reflect.isEnumValue(v2)) {
			return this.compare(v1,v2);
		} else if((v1 instanceof Array) && v1.__enum__ == null && ((v2 instanceof Array) && v2.__enum__ == null)) {
			return this.compareArgs(v1,v2);
		} else {
			return Reflect.compare(v1,v2);
		}
	}
	,__class__: haxe_ds_EnumValueMap
});
var haxe_ds__$HashMap_HashMap_$Impl_$ = {};
$hxClasses["haxe.ds._HashMap.HashMap_Impl_"] = haxe_ds__$HashMap_HashMap_$Impl_$;
haxe_ds__$HashMap_HashMap_$Impl_$.__name__ = ["haxe","ds","_HashMap","HashMap_Impl_"];
haxe_ds__$HashMap_HashMap_$Impl_$._new = function() {
	var this1 = new haxe_ds__$HashMap_HashMapData();
	return this1;
};
haxe_ds__$HashMap_HashMap_$Impl_$.set = function(this1,k,v) {
	var _this = this1.keys;
	var key = k.hashCode();
	_this.h[key] = k;
	var _this1 = this1.values;
	var key1 = k.hashCode();
	_this1.h[key1] = v;
};
haxe_ds__$HashMap_HashMap_$Impl_$.get = function(this1,k) {
	var _this = this1.values;
	var key = k.hashCode();
	return _this.h[key];
};
haxe_ds__$HashMap_HashMap_$Impl_$.exists = function(this1,k) {
	var _this = this1.values;
	var key = k.hashCode();
	return _this.h.hasOwnProperty(key);
};
haxe_ds__$HashMap_HashMap_$Impl_$.remove = function(this1,k) {
	this1.values.remove(k.hashCode());
	return this1.keys.remove(k.hashCode());
};
haxe_ds__$HashMap_HashMap_$Impl_$.keys = function(this1) {
	return this1.keys.iterator();
};
haxe_ds__$HashMap_HashMap_$Impl_$.iterator = function(this1) {
	return this1.values.iterator();
};
var haxe_ds__$HashMap_HashMapData = function() {
	this.keys = new haxe_ds_IntMap();
	this.values = new haxe_ds_IntMap();
};
$hxClasses["haxe.ds._HashMap.HashMapData"] = haxe_ds__$HashMap_HashMapData;
haxe_ds__$HashMap_HashMapData.__name__ = ["haxe","ds","_HashMap","HashMapData"];
haxe_ds__$HashMap_HashMapData.prototype = {
	keys: null
	,values: null
	,__class__: haxe_ds__$HashMap_HashMapData
};
var haxe_ds_IntMap = function() {
	this.h = { };
};
$hxClasses["haxe.ds.IntMap"] = haxe_ds_IntMap;
haxe_ds_IntMap.__name__ = ["haxe","ds","IntMap"];
haxe_ds_IntMap.__interfaces__ = [haxe_IMap];
haxe_ds_IntMap.prototype = {
	h: null
	,set: function(key,value) {
		this.h[key] = value;
	}
	,get: function(key) {
		return this.h[key];
	}
	,exists: function(key) {
		return this.h.hasOwnProperty(key);
	}
	,remove: function(key) {
		if(!this.h.hasOwnProperty(key)) {
			return false;
		}
		delete(this.h[key]);
		return true;
	}
	,keys: function() {
		var a = [];
		for( var key in this.h ) if(this.h.hasOwnProperty(key)) {
			a.push(key | 0);
		}
		return HxOverrides.iter(a);
	}
	,iterator: function() {
		return { ref : this.h, it : this.keys(), hasNext : function() {
			return this.it.hasNext();
		}, next : function() {
			var i = this.it.next();
			return this.ref[i];
		}};
	}
	,toString: function() {
		var s_b = "";
		s_b += "{";
		var it = this.keys();
		var i = it;
		while(i.hasNext()) {
			var i1 = i.next();
			s_b += i1 == null ? "null" : "" + i1;
			s_b += " => ";
			s_b += Std.string(Std.string(this.h[i1]));
			if(it.hasNext()) {
				s_b += ", ";
			}
		}
		s_b += "}";
		return s_b;
	}
	,__class__: haxe_ds_IntMap
};
var haxe_ds_ObjectMap = function() {
	this.h = { __keys__ : { }};
};
$hxClasses["haxe.ds.ObjectMap"] = haxe_ds_ObjectMap;
haxe_ds_ObjectMap.__name__ = ["haxe","ds","ObjectMap"];
haxe_ds_ObjectMap.__interfaces__ = [haxe_IMap];
haxe_ds_ObjectMap.assignId = function(obj) {
	return obj.__id__ = ++haxe_ds_ObjectMap.count;
};
haxe_ds_ObjectMap.getId = function(obj) {
	return obj.__id__;
};
haxe_ds_ObjectMap.prototype = {
	h: null
	,set: function(key,value) {
		var id = key.__id__ || (key.__id__ = ++haxe_ds_ObjectMap.count);
		this.h[id] = value;
		this.h.__keys__[id] = key;
	}
	,get: function(key) {
		return this.h[key.__id__];
	}
	,exists: function(key) {
		return this.h.__keys__[key.__id__] != null;
	}
	,remove: function(key) {
		var id = key.__id__;
		if(this.h.__keys__[id] == null) {
			return false;
		}
		delete(this.h[id]);
		delete(this.h.__keys__[id]);
		return true;
	}
	,keys: function() {
		var a = [];
		for( var key in this.h.__keys__ ) {
		if(this.h.hasOwnProperty(key)) {
			a.push(this.h.__keys__[key]);
		}
		}
		return HxOverrides.iter(a);
	}
	,iterator: function() {
		return { ref : this.h, it : this.keys(), hasNext : function() {
			return this.it.hasNext();
		}, next : function() {
			var i = this.it.next();
			return this.ref[i.__id__];
		}};
	}
	,toString: function() {
		var s_b = "";
		s_b += "{";
		var it = this.keys();
		var i = it;
		while(i.hasNext()) {
			var i1 = i.next();
			s_b += Std.string(Std.string(i1));
			s_b += " => ";
			s_b += Std.string(Std.string(this.h[i1.__id__]));
			if(it.hasNext()) {
				s_b += ", ";
			}
		}
		s_b += "}";
		return s_b;
	}
	,__class__: haxe_ds_ObjectMap
};
var haxe_ds__$StringMap_StringMapIterator = function(map,keys) {
	this.map = map;
	this.keys = keys;
	this.index = 0;
	this.count = keys.length;
};
$hxClasses["haxe.ds._StringMap.StringMapIterator"] = haxe_ds__$StringMap_StringMapIterator;
haxe_ds__$StringMap_StringMapIterator.__name__ = ["haxe","ds","_StringMap","StringMapIterator"];
haxe_ds__$StringMap_StringMapIterator.prototype = {
	map: null
	,keys: null
	,index: null
	,count: null
	,hasNext: function() {
		return this.index < this.count;
	}
	,next: function() {
		var _this = this.map;
		var key = this.keys[this.index++];
		if(__map_reserved[key] != null) {
			return _this.getReserved(key);
		} else {
			return _this.h[key];
		}
	}
	,__class__: haxe_ds__$StringMap_StringMapIterator
};
var haxe_ds_StringMap = function() {
	this.h = { };
};
$hxClasses["haxe.ds.StringMap"] = haxe_ds_StringMap;
haxe_ds_StringMap.__name__ = ["haxe","ds","StringMap"];
haxe_ds_StringMap.__interfaces__ = [haxe_IMap];
haxe_ds_StringMap.prototype = {
	h: null
	,rh: null
	,isReserved: function(key) {
		return __map_reserved[key] != null;
	}
	,set: function(key,value) {
		if(__map_reserved[key] != null) {
			this.setReserved(key,value);
		} else {
			this.h[key] = value;
		}
	}
	,get: function(key) {
		if(__map_reserved[key] != null) {
			return this.getReserved(key);
		}
		return this.h[key];
	}
	,exists: function(key) {
		if(__map_reserved[key] != null) {
			return this.existsReserved(key);
		}
		return this.h.hasOwnProperty(key);
	}
	,setReserved: function(key,value) {
		if(this.rh == null) {
			this.rh = { };
		}
		this.rh["$" + key] = value;
	}
	,getReserved: function(key) {
		if(this.rh == null) {
			return null;
		} else {
			return this.rh["$" + key];
		}
	}
	,existsReserved: function(key) {
		if(this.rh == null) {
			return false;
		}
		return this.rh.hasOwnProperty("$" + key);
	}
	,remove: function(key) {
		if(__map_reserved[key] != null) {
			key = "$" + key;
			if(this.rh == null || !this.rh.hasOwnProperty(key)) {
				return false;
			}
			delete(this.rh[key]);
			return true;
		} else {
			if(!this.h.hasOwnProperty(key)) {
				return false;
			}
			delete(this.h[key]);
			return true;
		}
	}
	,keys: function() {
		return HxOverrides.iter(this.arrayKeys());
	}
	,arrayKeys: function() {
		var out = [];
		for( var key in this.h ) {
		if(this.h.hasOwnProperty(key)) {
			out.push(key);
		}
		}
		if(this.rh != null) {
			for( var key in this.rh ) {
			if(key.charCodeAt(0) == 36) {
				out.push(key.substr(1));
			}
			}
		}
		return out;
	}
	,iterator: function() {
		return new haxe_ds__$StringMap_StringMapIterator(this,this.arrayKeys());
	}
	,toString: function() {
		var s_b = "";
		s_b += "{";
		var keys = this.arrayKeys();
		var _g1 = 0;
		var _g = keys.length;
		while(_g1 < _g) {
			var i = _g1++;
			var k = keys[i];
			s_b += k == null ? "null" : "" + k;
			s_b += " => ";
			s_b += Std.string(Std.string(__map_reserved[k] != null ? this.getReserved(k) : this.h[k]));
			if(i < keys.length - 1) {
				s_b += ", ";
			}
		}
		s_b += "}";
		return s_b;
	}
	,__class__: haxe_ds_StringMap
};
var haxe_ds__$Vector_Vector_$Impl_$ = {};
$hxClasses["haxe.ds._Vector.Vector_Impl_"] = haxe_ds__$Vector_Vector_$Impl_$;
haxe_ds__$Vector_Vector_$Impl_$.__name__ = ["haxe","ds","_Vector","Vector_Impl_"];
haxe_ds__$Vector_Vector_$Impl_$.__properties__ = {get_length:"get_length"};
haxe_ds__$Vector_Vector_$Impl_$._new = function(length) {
	var this1 = new Array(length);
	return this1;
};
haxe_ds__$Vector_Vector_$Impl_$.get = function(this1,index) {
	return this1[index];
};
haxe_ds__$Vector_Vector_$Impl_$.set = function(this1,index,val) {
	return this1[index] = val;
};
haxe_ds__$Vector_Vector_$Impl_$.get_length = function(this1) {
	return this1.length;
};
haxe_ds__$Vector_Vector_$Impl_$.blit = function(src,srcPos,dest,destPos,len) {
	if(src == dest) {
		if(srcPos < destPos) {
			var i = srcPos + len;
			var j = destPos + len;
			var _g1 = 0;
			var _g = len;
			while(_g1 < _g) {
				var k = _g1++;
				--i;
				--j;
				src[j] = src[i];
			}
		} else if(srcPos > destPos) {
			var i1 = srcPos;
			var j1 = destPos;
			var _g11 = 0;
			var _g2 = len;
			while(_g11 < _g2) {
				var k1 = _g11++;
				src[j1] = src[i1];
				++i1;
				++j1;
			}
		}
	} else {
		var _g12 = 0;
		var _g3 = len;
		while(_g12 < _g3) {
			var i2 = _g12++;
			dest[destPos + i2] = src[srcPos + i2];
		}
	}
};
haxe_ds__$Vector_Vector_$Impl_$.toArray = function(this1) {
	return this1.slice(0);
};
haxe_ds__$Vector_Vector_$Impl_$.toData = function(this1) {
	return this1;
};
haxe_ds__$Vector_Vector_$Impl_$.fromData = function(data) {
	return data;
};
haxe_ds__$Vector_Vector_$Impl_$.fromArrayCopy = function(array) {
	return array.slice(0);
};
haxe_ds__$Vector_Vector_$Impl_$.copy = function(this1) {
	var length = this1.length;
	var this2 = new Array(length);
	var r = this2;
	haxe_ds__$Vector_Vector_$Impl_$.blit(this1,0,r,0,this1.length);
	return r;
};
haxe_ds__$Vector_Vector_$Impl_$.join = function(this1,sep) {
	var b_b = "";
	var i = 0;
	var len = this1.length;
	var _g1 = 0;
	var _g = len;
	while(_g1 < _g) {
		var i1 = _g1++;
		b_b += Std.string(Std.string(this1[i1]));
		if(i1 < len - 1) {
			b_b += sep == null ? "null" : "" + sep;
		}
	}
	return b_b;
};
haxe_ds__$Vector_Vector_$Impl_$.map = function(this1,f) {
	var length = this1.length;
	var this2 = new Array(length);
	var r = this2;
	var i = 0;
	var len = length;
	var _g1 = 0;
	var _g = len;
	while(_g1 < _g) {
		var i1 = _g1++;
		var v = f(this1[i1]);
		r[i1] = v;
	}
	return r;
};
haxe_ds__$Vector_Vector_$Impl_$.sort = function(this1,f) {
	this1.sort(f);
};
var haxe_ds_WeakMap = function() {
	throw new js__$Boot_HaxeError("Not implemented for this platform");
};
$hxClasses["haxe.ds.WeakMap"] = haxe_ds_WeakMap;
haxe_ds_WeakMap.__name__ = ["haxe","ds","WeakMap"];
haxe_ds_WeakMap.__interfaces__ = [haxe_IMap];
haxe_ds_WeakMap.prototype = {
	set: function(key,value) {
	}
	,get: function(key) {
		return null;
	}
	,exists: function(key) {
		return false;
	}
	,remove: function(key) {
		return false;
	}
	,keys: function() {
		return null;
	}
	,iterator: function() {
		return null;
	}
	,toString: function() {
		return null;
	}
	,__class__: haxe_ds_WeakMap
};
var js__$Boot_HaxeError = function(val) {
	Error.call(this);
	this.val = val;
	this.message = String(val);
	if(Error.captureStackTrace) {
		Error.captureStackTrace(this,js__$Boot_HaxeError);
	}
};
$hxClasses["js._Boot.HaxeError"] = js__$Boot_HaxeError;
js__$Boot_HaxeError.__name__ = ["js","_Boot","HaxeError"];
js__$Boot_HaxeError.wrap = function(val) {
	if((val instanceof Error)) {
		return val;
	} else {
		return new js__$Boot_HaxeError(val);
	}
};
js__$Boot_HaxeError.__super__ = Error;
js__$Boot_HaxeError.prototype = $extend(Error.prototype,{
	val: null
	,__class__: js__$Boot_HaxeError
});
var js_Boot = function() { };
$hxClasses["js.Boot"] = js_Boot;
js_Boot.__name__ = ["js","Boot"];
js_Boot.__unhtml = function(s) {
	return s.split("&").join("&amp;").split("<").join("&lt;").split(">").join("&gt;");
};
js_Boot.__trace = function(v,i) {
	var msg = i != null ? i.fileName + ":" + i.lineNumber + ": " : "";
	msg += js_Boot.__string_rec(v,"");
	if(i != null && i.customParams != null) {
		var _g = 0;
		var _g1 = i.customParams;
		while(_g < _g1.length) {
			var v1 = _g1[_g];
			++_g;
			msg += "," + js_Boot.__string_rec(v1,"");
		}
	}
	var d;
	var tmp;
	if(typeof(document) != "undefined") {
		d = document.getElementById("haxe:trace");
		tmp = d != null;
	} else {
		tmp = false;
	}
	if(tmp) {
		d.innerHTML += js_Boot.__unhtml(msg) + "<br/>";
	} else if(typeof console != "undefined" && console.log != null) {
		console.log(msg);
	}
};
js_Boot.__clear_trace = function() {
	var d = document.getElementById("haxe:trace");
	if(d != null) {
		d.innerHTML = "";
	}
};
js_Boot.isClass = function(o) {
	return o.__name__;
};
js_Boot.isEnum = function(e) {
	return e.__ename__;
};
js_Boot.getClass = function(o) {
	if((o instanceof Array) && o.__enum__ == null) {
		return Array;
	} else {
		var cl = o.__class__;
		if(cl != null) {
			return cl;
		}
		var name = js_Boot.__nativeClassName(o);
		if(name != null) {
			return js_Boot.__resolveNativeClass(name);
		}
		return null;
	}
};
js_Boot.__string_rec = function(o,s) {
	if(o == null) {
		return "null";
	}
	if(s.length >= 5) {
		return "<...>";
	}
	var t = typeof(o);
	if(t == "function" && (o.__name__ || o.__ename__)) {
		t = "object";
	}
	switch(t) {
	case "function":
		return "<function>";
	case "object":
		if(o instanceof Array) {
			if(o.__enum__) {
				if(o.length == 2) {
					return o[0];
				}
				var str = o[0] + "(";
				s += "\t";
				var _g1 = 2;
				var _g = o.length;
				while(_g1 < _g) {
					var i = _g1++;
					if(i != 2) {
						str += "," + js_Boot.__string_rec(o[i],s);
					} else {
						str += js_Boot.__string_rec(o[i],s);
					}
				}
				return str + ")";
			}
			var l = o.length;
			var i1;
			var str1 = "[";
			s += "\t";
			var _g11 = 0;
			var _g2 = l;
			while(_g11 < _g2) {
				var i2 = _g11++;
				str1 += (i2 > 0 ? "," : "") + js_Boot.__string_rec(o[i2],s);
			}
			str1 += "]";
			return str1;
		}
		var tostr;
		try {
			tostr = o.toString;
		} catch( e ) {
			return "???";
		}
		if(tostr != null && tostr != Object.toString && typeof(tostr) == "function") {
			var s2 = o.toString();
			if(s2 != "[object Object]") {
				return s2;
			}
		}
		var k = null;
		var str2 = "{\n";
		s += "\t";
		var hasp = o.hasOwnProperty != null;
		for( var k in o ) {
		if(hasp && !o.hasOwnProperty(k)) {
			continue;
		}
		if(k == "prototype" || k == "__class__" || k == "__super__" || k == "__interfaces__" || k == "__properties__") {
			continue;
		}
		if(str2.length != 2) {
			str2 += ", \n";
		}
		str2 += s + k + " : " + js_Boot.__string_rec(o[k],s);
		}
		s = s.substring(1);
		str2 += "\n" + s + "}";
		return str2;
	case "string":
		return o;
	default:
		return String(o);
	}
};
js_Boot.__interfLoop = function(cc,cl) {
	if(cc == null) {
		return false;
	}
	if(cc == cl) {
		return true;
	}
	var intf = cc.__interfaces__;
	if(intf != null) {
		var _g1 = 0;
		var _g = intf.length;
		while(_g1 < _g) {
			var i = _g1++;
			var i1 = intf[i];
			if(i1 == cl || js_Boot.__interfLoop(i1,cl)) {
				return true;
			}
		}
	}
	return js_Boot.__interfLoop(cc.__super__,cl);
};
js_Boot.__instanceof = function(o,cl) {
	if(cl == null) {
		return false;
	}
	switch(cl) {
	case Array:
		if((o instanceof Array)) {
			return o.__enum__ == null;
		} else {
			return false;
		}
		break;
	case Bool:
		return typeof(o) == "boolean";
	case Dynamic:
		return true;
	case Float:
		return typeof(o) == "number";
	case Int:
		if(typeof(o) == "number") {
			return (o|0) === o;
		} else {
			return false;
		}
		break;
	case String:
		return typeof(o) == "string";
	default:
		if(o != null) {
			if(typeof(cl) == "function") {
				if(o instanceof cl) {
					return true;
				}
				if(js_Boot.__interfLoop(js_Boot.getClass(o),cl)) {
					return true;
				}
			} else if(typeof(cl) == "object" && js_Boot.__isNativeObj(cl)) {
				if(o instanceof cl) {
					return true;
				}
			}
		} else {
			return false;
		}
		if(cl == Class ? o.__name__ != null : false) {
			return true;
		}
		if(cl == Enum ? o.__ename__ != null : false) {
			return true;
		}
		return o.__enum__ == cl;
	}
};
js_Boot.__cast = function(o,t) {
	if(js_Boot.__instanceof(o,t)) {
		return o;
	} else {
		throw new js__$Boot_HaxeError("Cannot cast " + Std.string(o) + " to " + Std.string(t));
	}
};
js_Boot.__nativeClassName = function(o) {
	var name = js_Boot.__toStr.call(o).slice(8,-1);
	if(name == "Object" || name == "Function" || name == "Math" || name == "JSON") {
		return null;
	}
	return name;
};
js_Boot.__isNativeObj = function(o) {
	return js_Boot.__nativeClassName(o) != null;
};
js_Boot.__resolveNativeClass = function(name) {
	return $global[name];
};
var js_Lib = function() { };
$hxClasses["js.Lib"] = js_Lib;
js_Lib.__name__ = ["js","Lib"];
js_Lib.__properties__ = {get_undefined:"get_undefined"};
js_Lib.debug = function() {
	debugger;
};
js_Lib.alert = function(v) {
	alert(js_Boot.__string_rec(v,""));
};
js_Lib["eval"] = function(code) {
	return eval(code);
};
js_Lib.get_undefined = function() {
	return undefined;
};
function $iterator(o) { if( o instanceof Array ) return function() { return HxOverrides.iter(o); }; return typeof(o.iterator) == 'function' ? $bind(o,o.iterator) : o.iterator; }
var $_, $fid = 0;
function $bind(o,m) { if( m == null ) return null; if( m.__id__ == null ) m.__id__ = $fid++; var f; if( o.hx__closures__ == null ) o.hx__closures__ = {}; else f = o.hx__closures__[m.__id__]; if( f == null ) { f = function(){ return f.method.apply(f.scope, arguments); }; f.scope = o; f.method = m; o.hx__closures__[m.__id__] = f; } return f; }
function $arrayPush(x) { this.push(x); }
$hxClasses["Math"] = Math;
String.prototype.__class__ = $hxClasses["String"] = String;
String.__name__ = ["String"];
$hxClasses["Array"] = Array;
Array.__name__ = ["Array"];
Date.prototype.__class__ = $hxClasses["Date"] = Date;
Date.__name__ = ["Date"];
var Int = $hxClasses["Int"] = { __name__ : ["Int"]};
var Dynamic = $hxClasses["Dynamic"] = { __name__ : ["Dynamic"]};
var Float = $hxClasses["Float"] = Number;
Float.__name__ = ["Float"];
var Bool = $hxClasses["Bool"] = Boolean;
Bool.__ename__ = ["Bool"];
var Class = $hxClasses["Class"] = { __name__ : ["Class"]};
var Enum = { };
var Void = $hxClasses["Void"] = { __ename__ : ["Void"]};
var __map_reserved = {};
FastaAlignmentParser.authorizedCharacters = (function($this) {
	var $r;
	var _g = new haxe_ds_StringMap();
	if(__map_reserved["A"] != null) {
		_g.setReserved("A",true);
	} else {
		_g.h["A"] = true;
	}
	if(__map_reserved["T"] != null) {
		_g.setReserved("T",true);
	} else {
		_g.h["T"] = true;
	}
	if(__map_reserved["G"] != null) {
		_g.setReserved("G",true);
	} else {
		_g.h["G"] = true;
	}
	if(__map_reserved["C"] != null) {
		_g.setReserved("C",true);
	} else {
		_g.h["C"] = true;
	}
	if(__map_reserved["N"] != null) {
		_g.setReserved("N",true);
	} else {
		_g.h["N"] = true;
	}
	if(__map_reserved["-"] != null) {
		_g.setReserved("-",true);
	} else {
		_g.h["-"] = true;
	}
	if(__map_reserved["?"] != null) {
		_g.setReserved("?",true);
	} else {
		_g.h["?"] = true;
	}
	if(__map_reserved["R"] != null) {
		_g.setReserved("R",false);
	} else {
		_g.h["R"] = false;
	}
	if(__map_reserved["Y"] != null) {
		_g.setReserved("Y",false);
	} else {
		_g.h["Y"] = false;
	}
	if(__map_reserved["M"] != null) {
		_g.setReserved("M",false);
	} else {
		_g.h["M"] = false;
	}
	if(__map_reserved["K"] != null) {
		_g.setReserved("K",false);
	} else {
		_g.h["K"] = false;
	}
	if(__map_reserved["W"] != null) {
		_g.setReserved("W",false);
	} else {
		_g.h["W"] = false;
	}
	if(__map_reserved["S"] != null) {
		_g.setReserved("S",false);
	} else {
		_g.h["S"] = false;
	}
	$r = _g;
	return $r;
}(this));
SeqPhase1.map1 = (function($this) {
	var $r;
	var _g = new haxe_ds_StringMap();
	if(__map_reserved["W"] != null) {
		_g.setReserved("W","A");
	} else {
		_g.h["W"] = "A";
	}
	if(__map_reserved["S"] != null) {
		_g.setReserved("S","C");
	} else {
		_g.h["S"] = "C";
	}
	if(__map_reserved["K"] != null) {
		_g.setReserved("K","T");
	} else {
		_g.h["K"] = "T";
	}
	if(__map_reserved["M"] != null) {
		_g.setReserved("M","A");
	} else {
		_g.h["M"] = "A";
	}
	if(__map_reserved["Y"] != null) {
		_g.setReserved("Y","C");
	} else {
		_g.h["Y"] = "C";
	}
	if(__map_reserved["R"] != null) {
		_g.setReserved("R","A");
	} else {
		_g.h["R"] = "A";
	}
	$r = _g;
	return $r;
}(this));
SeqPhase1.map2 = (function($this) {
	var $r;
	var _g = new haxe_ds_StringMap();
	if(__map_reserved["W"] != null) {
		_g.setReserved("W","T");
	} else {
		_g.h["W"] = "T";
	}
	if(__map_reserved["S"] != null) {
		_g.setReserved("S","G");
	} else {
		_g.h["S"] = "G";
	}
	if(__map_reserved["K"] != null) {
		_g.setReserved("K","G");
	} else {
		_g.h["K"] = "G";
	}
	if(__map_reserved["M"] != null) {
		_g.setReserved("M","C");
	} else {
		_g.h["M"] = "C";
	}
	if(__map_reserved["Y"] != null) {
		_g.setReserved("Y","T");
	} else {
		_g.h["Y"] = "T";
	}
	if(__map_reserved["R"] != null) {
		_g.setReserved("R","G");
	} else {
		_g.h["R"] = "G";
	}
	$r = _g;
	return $r;
}(this));
SeqPhase1.code = (function($this) {
	var $r;
	var _g = new haxe_ds_StringMap();
	if(__map_reserved["A"] != null) {
		_g.setReserved("A","1");
	} else {
		_g.h["A"] = "1";
	}
	if(__map_reserved["C"] != null) {
		_g.setReserved("C","2");
	} else {
		_g.h["C"] = "2";
	}
	if(__map_reserved["G"] != null) {
		_g.setReserved("G","3");
	} else {
		_g.h["G"] = "3";
	}
	if(__map_reserved["T"] != null) {
		_g.setReserved("T","4");
	} else {
		_g.h["T"] = "4";
	}
	if(__map_reserved["?"] != null) {
		_g.setReserved("?","?");
	} else {
		_g.h["?"] = "?";
	}
	if(__map_reserved["N"] != null) {
		_g.setReserved("N","?");
	} else {
		_g.h["N"] = "?";
	}
	if(__map_reserved["-"] != null) {
		_g.setReserved("-","0");
	} else {
		_g.h["-"] = "0";
	}
	$r = _g;
	return $r;
}(this));
StringTools.winMetaCharacters = [32,40,41,37,33,94,34,60,62,38,124,10,13,44,59];
haxe_ds_ObjectMap.count = 0;
js_Boot.__toStr = ({ }).toString;
