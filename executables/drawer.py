# Generated by Haxe 3.4.7
# coding: utf-8

import math as python_lib_Math
import math as Math
from os import path as python_lib_os_Path
import inspect as python_lib_Inspect
import os as python_lib_Os
import builtins as python_lib_Builtins
import functools as python_lib_Functools
try:
    import msvcrt as python_lib_Msvcrt
except:
    pass
import random as python_lib_Random
import subprocess as python_lib_Subprocess
import sys as python_lib_Sys
try:
    import termios as python_lib_Termios
except:
    pass
import time as python_lib_Time
import timeit as python_lib_Timeit
try:
    import tty as python_lib_Tty
except:
    pass
from io import StringIO as python_lib_io_StringIO


class _hx_AnonObject:
    def __init__(self, fields):
        self.__dict__ = fields


class Enum:
    _hx_class_name = "Enum"
    __slots__ = ("tag", "index", "params")
    _hx_fields = ["tag", "index", "params"]
    _hx_methods = ["__str__"]

    def __init__(self,tag,index,params):
        self.tag = tag
        self.index = index
        self.params = params

    def __str__(self):
        if (self.params is None):
            return self.tag
        else:
            _this = self.params
            return (((HxOverrides.stringOrNull(self.tag) + "(") + HxOverrides.stringOrNull(",".join([python_Boot.toString1(x1,'') for x1 in _this]))) + ")")



class EnumValue:
    _hx_class_name = "EnumValue"


class List:
    _hx_class_name = "List"
    __slots__ = ("h", "q", "length")
    _hx_fields = ["h", "q", "length"]
    _hx_methods = ["add", "first", "pop", "isEmpty", "remove", "join", "filter"]

    def __init__(self):
        self.q = None
        self.h = None
        self.length = 0

    def add(self,item):
        x = _List_ListNode(item,None)
        if (self.h is None):
            self.h = x
        else:
            self.q.next = x
        self.q = x
        _hx_local_0 = self
        _hx_local_1 = _hx_local_0.length
        _hx_local_0.length = (_hx_local_1 + 1)
        _hx_local_1

    def first(self):
        if (self.h is None):
            return None
        else:
            return self.h.item

    def pop(self):
        if (self.h is None):
            return None
        x = self.h.item
        self.h = self.h.next
        if (self.h is None):
            self.q = None
        _hx_local_0 = self
        _hx_local_1 = _hx_local_0.length
        _hx_local_0.length = (_hx_local_1 - 1)
        _hx_local_1
        return x

    def isEmpty(self):
        return (self.h is None)

    def remove(self,v):
        prev = None
        l = self.h
        while (l is not None):
            if (l.item == v):
                if (prev is None):
                    self.h = l.next
                else:
                    prev.next = l.next
                if (self.q == l):
                    self.q = prev
                _hx_local_0 = self
                _hx_local_1 = _hx_local_0.length
                _hx_local_0.length = (_hx_local_1 - 1)
                _hx_local_1
                return True
            prev = l
            l = l.next
        return False

    def join(self,sep):
        s_b = python_lib_io_StringIO()
        first = True
        l = self.h
        while (l is not None):
            if first:
                first = False
            else:
                s_b.write(Std.string(sep))
            s_b.write(Std.string(l.item))
            l = l.next
        return s_b.getvalue()

    def filter(self,f):
        l2 = List()
        l = self.h
        while (l is not None):
            v = l.item
            l = l.next
            if f(v):
                l2.add(v)
        return l2



class _List_ListNode:
    _hx_class_name = "_List.ListNode"
    __slots__ = ("item", "next")
    _hx_fields = ["item", "next"]

    def __init__(self,item,next):
        self.item = item
        self.next = next



class Reflect:
    _hx_class_name = "Reflect"
    __slots__ = ()
    _hx_statics = ["field"]

    @staticmethod
    def field(o,field):
        return python_Boot.field(o,field)


class Std:
    _hx_class_name = "Std"
    __slots__ = ()
    _hx_statics = ["string", "parseInt", "shortenPossibleNumber", "parseFloat"]

    @staticmethod
    def string(s):
        return python_Boot.toString1(s,"")

    @staticmethod
    def parseInt(x):
        if (x is None):
            return None
        try:
            return int(x)
        except Exception as _hx_e:
            _hx_e1 = _hx_e.val if isinstance(_hx_e, _HxException) else _hx_e
            e = _hx_e1
            try:
                prefix = HxString.substr(x,0,2).lower()
                if (prefix == "0x"):
                    return int(x,16)
                raise _HxException("fail")
            except Exception as _hx_e:
                _hx_e1 = _hx_e.val if isinstance(_hx_e, _HxException) else _hx_e
                e1 = _hx_e1
                x1 = Std.parseFloat(x)
                r = None
                try:
                    r = int(x1)
                except Exception as _hx_e:
                    _hx_e1 = _hx_e.val if isinstance(_hx_e, _HxException) else _hx_e
                    e2 = _hx_e1
                    r = None
                if (r is None):
                    r1 = Std.shortenPossibleNumber(x)
                    if (r1 != x):
                        return Std.parseInt(r1)
                    else:
                        return None
                return r

    @staticmethod
    def shortenPossibleNumber(x):
        r = ""
        _g1 = 0
        _g = len(x)
        while (_g1 < _g):
            i = _g1
            _g1 = (_g1 + 1)
            c = ("" if (((i < 0) or ((i >= len(x))))) else x[i])
            _g2 = HxString.charCodeAt(c,0)
            if (_g2 is None):
                break
            else:
                _g21 = _g2
                if (((((((((((_g21 == 57) or ((_g21 == 56))) or ((_g21 == 55))) or ((_g21 == 54))) or ((_g21 == 53))) or ((_g21 == 52))) or ((_g21 == 51))) or ((_g21 == 50))) or ((_g21 == 49))) or ((_g21 == 48))) or ((_g21 == 46))):
                    r = (("null" if r is None else r) + ("null" if c is None else c))
                else:
                    break
        return r

    @staticmethod
    def parseFloat(x):
        try:
            return float(x)
        except Exception as _hx_e:
            _hx_e1 = _hx_e.val if isinstance(_hx_e, _HxException) else _hx_e
            e = _hx_e1
            if (x is not None):
                r1 = Std.shortenPossibleNumber(x)
                if (r1 != x):
                    return Std.parseFloat(r1)
            return Math.NaN


class StringTools:
    _hx_class_name = "StringTools"
    __slots__ = ()
    _hx_statics = ["startsWith"]

    @staticmethod
    def startsWith(s,start):
        if (len(s) >= len(start)):
            return (HxString.substr(s,0,len(start)) == start)
        else:
            return False


class sys_FileSystem:
    _hx_class_name = "sys.FileSystem"
    __slots__ = ()
    _hx_statics = ["fullPath"]

    @staticmethod
    def fullPath(relPath):
        return python_lib_os_Path.realpath(relPath)


class haxe_IMap:
    _hx_class_name = "haxe.IMap"
    __slots__ = ()


class haxe_ds_StringMap:
    _hx_class_name = "haxe.ds.StringMap"
    __slots__ = ("h",)
    _hx_fields = ["h"]
    _hx_methods = ["keys"]

    def __init__(self):
        self.h = dict()

    def keys(self):
        return python_HaxeIterator(iter(self.h.keys()))



class python_HaxeIterator:
    _hx_class_name = "python.HaxeIterator"
    __slots__ = ("it", "x", "has", "checked")
    _hx_fields = ["it", "x", "has", "checked"]
    _hx_methods = ["next", "hasNext"]

    def __init__(self,it):
        self.checked = False
        self.has = False
        self.x = None
        self.it = it

    def next(self):
        if (not self.checked):
            self.hasNext()
        self.checked = False
        return self.x

    def hasNext(self):
        if (not self.checked):
            try:
                self.x = self.it.__next__()
                self.has = True
            except Exception as _hx_e:
                _hx_e1 = _hx_e.val if isinstance(_hx_e, _HxException) else _hx_e
                if isinstance(_hx_e1, StopIteration):
                    s = _hx_e1
                    self.has = False
                    self.x = None
                else:
                    raise _hx_e
            self.checked = True
        return self.has



class Sys:
    _hx_class_name = "Sys"
    __slots__ = ()
    _hx_statics = ["environ", "time", "exit", "print", "println", "args", "getEnv", "putEnv", "environment", "sleep", "setTimeLocale", "getCwd", "setCwd", "systemName", "command", "cpuTime", "executablePath", "_programPath", "programPath", "getChar", "stdin", "stdout", "stderr"]

    @staticmethod
    def time():
        return python_lib_Time.time()

    @staticmethod
    def exit(code):
        python_lib_Sys.exit(code)

    @staticmethod
    def print(v):
        python_Lib.print(v)

    @staticmethod
    def println(v):
        python_Lib.println(v)

    @staticmethod
    def args():
        argv = python_lib_Sys.argv
        return argv[1:None]

    @staticmethod
    def getEnv(s):
        return Sys.environ.h.get(s,None)

    @staticmethod
    def putEnv(s,v):
        python_lib_Os.putenv(s,v)
        Sys.environ.h[s] = v

    @staticmethod
    def environment():
        return Sys.environ

    @staticmethod
    def sleep(seconds):
        python_lib_Time.sleep(seconds)

    @staticmethod
    def setTimeLocale(loc):
        return False

    @staticmethod
    def getCwd():
        return python_lib_Os.getcwd()

    @staticmethod
    def setCwd(s):
        python_lib_Os.chdir(s)

    @staticmethod
    def systemName():
        _g = python_lib_Sys.platform
        x = _g
        if StringTools.startsWith(x,"linux"):
            return "Linux"
        else:
            _g1 = _g
            _hx_local_0 = len(_g1)
            if (_hx_local_0 == 5):
                if (_g1 == "win32"):
                    return "Windows"
                else:
                    raise _HxException("not supported platform")
            elif (_hx_local_0 == 6):
                if (_g1 == "cygwin"):
                    return "Windows"
                elif (_g1 == "darwin"):
                    return "Mac"
                else:
                    raise _HxException("not supported platform")
            else:
                raise _HxException("not supported platform")

    @staticmethod
    def command(cmd,args = None):
        if (args is None):
            return python_lib_Subprocess.call(cmd,**python__KwArgs_KwArgs_Impl_.fromT(_hx_AnonObject({'shell': True})))
        else:
            return python_lib_Subprocess.call(([cmd] + args))

    @staticmethod
    def cpuTime():
        return python_lib_Timeit.default_timer()

    @staticmethod
    def executablePath():
        return python_internal_ArrayImpl._get(python_lib_Sys.argv, 0)

    @staticmethod
    def programPath():
        return Sys._programPath

    @staticmethod
    def getChar(echo):
        ch = None
        _g = Sys.systemName()
        _g1 = _g
        _hx_local_0 = len(_g1)
        if (_hx_local_0 == 5):
            if (_g1 == "Linux"):
                fd = python_lib_Sys.stdin.fileno()
                old = python_lib_Termios.tcgetattr(fd)
                a1 = fd
                a2 = python_lib_Termios.TCSADRAIN
                a3 = old
                def _hx_local_1():
                    python_lib_Termios.tcsetattr(a1,a2,a3)
                restore = _hx_local_1
                try:
                    python_lib_Tty.setraw(fd)
                    x = python_lib_Sys.stdin.read(1)
                    restore()
                    ch = HxString.charCodeAt(x,0)
                except Exception as _hx_e:
                    _hx_e1 = _hx_e.val if isinstance(_hx_e, _HxException) else _hx_e
                    e = _hx_e1
                    restore()
                    raise _HxException(e)
            else:
                x1 = _g
                raise _HxException((("platform " + ("null" if x1 is None else x1)) + " not supported"))
        elif (_hx_local_0 == 3):
            if (_g1 == "Mac"):
                fd = python_lib_Sys.stdin.fileno()
                old = python_lib_Termios.tcgetattr(fd)
                a1 = fd
                a2 = python_lib_Termios.TCSADRAIN
                a3 = old
                def _hx_local_2():
                    python_lib_Termios.tcsetattr(a1,a2,a3)
                restore = _hx_local_2
                try:
                    python_lib_Tty.setraw(fd)
                    x = python_lib_Sys.stdin.read(1)
                    restore()
                    ch = HxString.charCodeAt(x,0)
                except Exception as _hx_e:
                    _hx_e1 = _hx_e.val if isinstance(_hx_e, _HxException) else _hx_e
                    e = _hx_e1
                    restore()
                    raise _HxException(e)
            else:
                x1 = _g
                raise _HxException((("platform " + ("null" if x1 is None else x1)) + " not supported"))
        elif (_hx_local_0 == 7):
            if (_g1 == "Windows"):
                ch = HxString.charCodeAt(python_lib_Msvcrt.getch().decode("utf-8"),0)
            else:
                x1 = _g
                raise _HxException((("platform " + ("null" if x1 is None else x1)) + " not supported"))
        else:
            x1 = _g
            raise _HxException((("platform " + ("null" if x1 is None else x1)) + " not supported"))
        if echo:
            python_Lib.print("".join(map(chr,[ch])))
        return ch

    @staticmethod
    def stdin():
        return python_io_IoTools.createFileInputFromText(python_lib_Sys.stdin)

    @staticmethod
    def stdout():
        return python_io_IoTools.createFileOutputFromText(python_lib_Sys.stdout)

    @staticmethod
    def stderr():
        return python_io_IoTools.createFileOutputFromText(python_lib_Sys.stderr)


class draw_Connection:
    _hx_class_name = "draw.Connection"
    __slots__ = ("id", "n1", "n2", "l", "expLength", "strokeColor", "strokeWidth", "dashedArray", "drawMutsByLine", "drawMutsLineStrokeColor", "drawMutsLineWidth", "drawMutsLineLen", "drawMutsLineDashedArray", "drawMutsByText", "drawMutsTextFont", "drawMutsTextSize", "drawMutsTextColor", "drawMutsTextPX", "drawMutsTextPY", "drawMutsByDots", "drawMutsDotsSize", "drawMutsDotsColor", "drawMutsDotsDashedArray")
    _hx_fields = ["id", "n1", "n2", "l", "expLength", "strokeColor", "strokeWidth", "dashedArray", "drawMutsByLine", "drawMutsLineStrokeColor", "drawMutsLineWidth", "drawMutsLineLen", "drawMutsLineDashedArray", "drawMutsByText", "drawMutsTextFont", "drawMutsTextSize", "drawMutsTextColor", "drawMutsTextPX", "drawMutsTextPY", "drawMutsByDots", "drawMutsDotsSize", "drawMutsDotsColor", "drawMutsDotsDashedArray"]
    _hx_methods = ["getNodeSvg"]

    def __init__(self,id,n1,n2,l):
        self.drawMutsDotsDashedArray = None
        self.drawMutsDotsColor = None
        self.drawMutsDotsSize = None
        self.drawMutsByDots = None
        self.drawMutsTextPY = None
        self.drawMutsTextPX = None
        self.drawMutsTextColor = None
        self.drawMutsTextSize = None
        self.drawMutsTextFont = None
        self.drawMutsByText = None
        self.drawMutsLineDashedArray = None
        self.drawMutsLineLen = None
        self.drawMutsLineWidth = None
        self.drawMutsLineStrokeColor = None
        self.drawMutsByLine = None
        self.dashedArray = None
        self.strokeWidth = None
        self.strokeColor = None
        self.expLength = None
        self.id = id
        self.n1 = n1
        self.n2 = n2
        self.l = l
        self.expLength = ((self.n1.radius + self.n2.radius) + ((self.l.length * 100)))
        self.strokeColor = "grey"
        self.strokeWidth = 3
        self.dashedArray = List()
        self.drawMutsByLine = False
        self.drawMutsByText = False
        self.drawMutsByDots = False
        self.drawMutsLineDashedArray = List()
        self.drawMutsDotsDashedArray = List()

    def getNodeSvg(self):
        result = List()
        result.add("<line x1='")
        result.add((Std.string(self.n1.xPos) + "' y1='"))
        result.add((Std.string(self.n1.yPos) + "' x2='"))
        result.add((Std.string(self.n2.xPos) + "' y2='"))
        result.add((Std.string(self.n2.yPos) + "' stroke='"))
        result.add((HxOverrides.stringOrNull(self.strokeColor) + "' stroke-width='"))
        result.add((Std.string(self.strokeWidth) + "' "))
        if (not self.dashedArray.isEmpty()):
            result.add("stroke-dasharray='")
            result.add(self.dashedArray.join(","))
            result.add("' ")
        result.add("/>")
        if ((self.drawMutsByLine or self.drawMutsByText) or self.drawMutsByDots):
            vX = (self.n1.xPos - self.n2.xPos)
            vY = (self.n1.yPos - self.n2.yPos)
            v = ((vX * vX) + ((vY * vY)))
            vL = (Math.NaN if ((v < 0)) else python_lib_Math.sqrt(v))
            eVX = (vX / vL)
            eVY = (vY / vL)
            startX = (self.n2.xPos + ((eVX * self.n2.radius)))
            startY = (self.n2.yPos + ((eVY * self.n2.radius)))
            endX = ((self.n2.xPos + vX) - ((eVX * self.n1.radius)))
            endY = ((self.n2.yPos + vY) - ((eVY * self.n1.radius)))
            vX = (((endX - startX)) / ((self.l.length + 1)))
            vY = (((endY - startY)) / ((self.l.length + 1)))
            iii = 0
            _g_head = self.l.h
            while (_g_head is not None):
                val = _g_head.item
                _g_head = _g_head.next
                text = val
                iii = (iii + 1)
                x = (startX + ((vX * iii)))
                y = (startY + ((vY * iii)))
                if self.drawMutsByDots:
                    result.add("<circle cx='")
                    result.add((Std.string(x) + "' cy='"))
                    result.add((Std.string(y) + "' r='"))
                    result.add((Std.string(self.drawMutsDotsSize) + "' fill='"))
                    result.add(self.drawMutsDotsColor)
                    if (not self.drawMutsDotsDashedArray.isEmpty()):
                        result.add("' stroke-dasharray='")
                        result.add(self.drawMutsDotsDashedArray.join(","))
                        result.add("'")
                    result.add("/>")
                if self.drawMutsByLine:
                    x1 = (x - ((eVY * self.drawMutsLineLen)))
                    y1 = (y + ((eVX * self.drawMutsLineLen)))
                    x2 = (x + ((eVY * self.drawMutsLineLen)))
                    y2 = (y - ((eVX * self.drawMutsLineLen)))
                    result.add("<line x1='")
                    result.add((Std.string(x1) + "' y1='"))
                    result.add((Std.string(y1) + "' x2='"))
                    result.add((Std.string(x2) + "' y2='"))
                    result.add((Std.string(y2) + "' stroke='"))
                    result.add((HxOverrides.stringOrNull(self.drawMutsLineStrokeColor) + "' stroke-width='"))
                    result.add((Std.string(self.drawMutsLineWidth) + "'"))
                    if (not self.drawMutsLineDashedArray.isEmpty()):
                        result.add(" stroke-dasharray='")
                        result.add(self.drawMutsLineDashedArray.join(","))
                        result.add("'")
                    result.add("/>")
                if self.drawMutsByText:
                    result.add("<text x='")
                    result.add((Std.string((x + self.drawMutsTextPX)) + "' y='"))
                    result.add((Std.string(((y + ((self.drawMutsTextSize / 2))) + self.drawMutsTextPY)) + "' fill='"))
                    result.add((HxOverrides.stringOrNull(self.drawMutsTextColor) + "' font-family='"))
                    result.add((HxOverrides.stringOrNull(self.drawMutsTextFont) + "' font-size='"))
                    result.add((Std.string(self.drawMutsTextSize) + "'"))
                    result.add(((">" + Std.string(text)) + "</text>"))
        return result.join("")



class draw_Drawer:
    _hx_class_name = "draw.Drawer"
    __slots__ = ()
    _hx_statics = ["main"]

    @staticmethod
    def main():
        myArgs = Sys.args()
        fileContent = sys_io_File.getContent((myArgs[0] if 0 < len(myArgs) else None))
        lines = fileContent.split("\n")
        result = List()
        lineNo = 0
        currentNode = None
        readNames = False
        readCons = False
        readLinks = False
        _g = 0
        while (_g < len(lines)):
            line = (lines[_g] if _g >= 0 and _g < len(lines) else None)
            _g = (_g + 1)
            lineNo = (lineNo + 1)
            end = len(line)
            while True:
                tmp = None
                if (end > 0):
                    cCode = HxString.charCodeAt(line,(end - 1))
                    result1 = False
                    _g1 = 0
                    _g11 = [9, 10, 11, 12, 13, 32, 133, 160, 5760, 8192, 8192, 8193, 8194, 8195, 8196, 8197, 8198, 8199, 8200, 8201, 8202, 8232, 8233, 8239, 8287, 12288, 6158, 8203, 8204, 8205, 8288, 65279]
                    while (_g1 < len(_g11)):
                        ele = (_g11[_g1] if _g1 >= 0 and _g1 < len(_g11) else None)
                        _g1 = (_g1 + 1)
                        if (ele == cCode):
                            result1 = True
                            break
                    tmp = result1
                else:
                    tmp = False
                if (not tmp):
                    break
                end = (end - 1)
            s = HxString.substring(line,0,end)
            begin = 0
            sLen = len(s)
            while True:
                tmp1 = None
                if (begin < sLen):
                    cCode1 = HxString.charCodeAt(s,begin)
                    result2 = False
                    _g2 = 0
                    _g12 = [9, 10, 11, 12, 13, 32, 133, 160, 5760, 8192, 8192, 8193, 8194, 8195, 8196, 8197, 8198, 8199, 8200, 8201, 8202, 8232, 8233, 8239, 8287, 12288, 6158, 8203, 8204, 8205, 8288, 65279]
                    while (_g2 < len(_g12)):
                        ele1 = (_g12[_g2] if _g2 >= 0 and _g2 < len(_g12) else None)
                        _g2 = (_g2 + 1)
                        if (ele1 == cCode1):
                            result2 = True
                            break
                    tmp1 = result2
                else:
                    tmp1 = False
                if (not tmp1):
                    break
                begin = (begin + 1)
            line_ = HxString.substr(s,begin,None)
            if (((line_ is None) or ((line_ == ""))) or (((("" if ((0 >= len(line_))) else line_[0])) == "#"))):
                continue
            result3 = 0
            while True:
                cCode2 = HxString.charCodeAt(line,result3)
                result4 = False
                _g3 = 0
                _g13 = [9, 10, 11, 12, 13, 32, 133, 160, 5760, 8192, 8192, 8193, 8194, 8195, 8196, 8197, 8198, 8199, 8200, 8201, 8202, 8232, 8233, 8239, 8287, 12288, 6158, 8203, 8204, 8205, 8288, 65279]
                while (_g3 < len(_g13)):
                    ele2 = (_g13[_g3] if _g3 >= 0 and _g3 < len(_g13) else None)
                    _g3 = (_g3 + 1)
                    if (ele2 == cCode2):
                        result4 = True
                        break
                if (not result4):
                    break
                result3 = (result3 + 1)
            indents = result3
            if ((indents == 0) and (((line_ == "SAMPLED_SEQUENCE") or ((line_ == "MEDIAN_VECTOR"))))):
                if (currentNode is not None):
                    result.add(currentNode)
                currentNode = parsing_Node()
                currentNode.type = (parsing_SEQ_TYPE.SAMPLED_SEQUENCE if ((line_ == "SAMPLED_SEQUENCE")) else parsing_SEQ_TYPE.MEDIAN_VECTOR)
                readNames = False
                readCons = False
                readLinks = False
                continue
            if (currentNode is None):
                raise _HxException((("Expected SAMPLED_SEQUENCE or MEDIAN_VECTOR in line " + Std.string(lineNo)) + "!"))
            if ((indents == 2) and ((HxString.substr(line_,0,len("ID")) == "ID"))):
                currentNode.id = Std.parseInt(HxOverrides.arrayGet(line_.split(" "), 1))
            elif ((indents == 2) and ((HxString.substr(line_,0,len("FFR_ID")) == "FFR_ID"))):
                currentNode.spId = Std.parseInt(HxOverrides.arrayGet(line_.split(" "), 1))
            elif ((indents == 2) and ((HxString.substr(line_,0,len("SEQUENCE")) == "SEQUENCE"))):
                currentNode.seq = HxOverrides.arrayGet(line_.split(" "), 1)
            elif (not (((indents == 2) and ((HxString.substr(line_,0,len("NB_NAMES")) == "NB_NAMES"))))):
                if ((indents == 2) and ((HxString.substr(line_,0,len("NAMES")) == "NAMES"))):
                    readNames = True
                    readCons = False
                    readLinks = False
                elif ((indents == 2) and ((HxString.substr(line_,0,len("CONNECTED_TO")) == "CONNECTED_TO"))):
                    readNames = False
                    readCons = True
                    readLinks = False
                elif ((indents == 2) and ((HxString.substr(line_,0,len("LINKED_TO")) == "LINKED_TO"))):
                    readNames = False
                    readCons = False
                    readLinks = True
                elif ((indents == 4) and (((readNames or readCons) or readLinks))):
                    if readNames:
                        currentNode.names.add(line_)
                    elif readCons:
                        d = line_.split(" ")
                        l = List()
                        _g21 = 5
                        _g14 = len(d)
                        while (_g21 < _g14):
                            i = _g21
                            _g21 = (_g21 + 1)
                            l.add(Std.parseInt((d[i] if i >= 0 and i < len(d) else None)))
                        currentNode.cons.add(util_Pair(Std.parseInt((d[1] if 1 < len(d) else None)),l))
                    elif readLinks:
                        d1 = line_.split(" ")
                        currentNode.links.add(util_Pair(Std.parseInt((d1[1] if 1 < len(d1) else None)),Std.parseInt((d1[3] if 3 < len(d1) else None))))
                else:
                    raise _HxException((("Unexpected expression in line " + Std.string(lineNo)) + "!"))
        if (currentNode is not None):
            result.add(currentNode)
        net = result
        g_nodes = None
        g_links = None
        g_lastStretchFact = None
        g_drawCurves = None
        g_drawCons = None
        g_drawCirclesNames = None
        g_drawCirclesMedians = None
        g_drawCircles = None
        g_drawCenter = None
        g_drawBezierPoints = None
        g_drawAngles = None
        g_cons = None
        g_drawCircles = True
        g_drawCirclesNames = False
        g_drawCirclesMedians = False
        g_drawCons = True
        g_drawCurves = True
        g_drawBezierPoints = False
        g_drawCenter = False
        g_drawAngles = False
        g_drawCircles = True
        g_drawCirclesNames = False
        g_drawCirclesMedians = False
        g_drawCons = True
        g_drawCurves = True
        g_drawBezierPoints = False
        g_drawCenter = False
        g_drawAngles = False
        g_nodes = List()
        g_cons = List()
        g_links = List()
        _g_head = net.h
        while (_g_head is not None):
            val = _g_head.item
            _g_head = _g_head.next
            e = val
            g_nodes.add(draw_NodePos(e))
        nextConId = 0
        _g_head1 = g_nodes.h
        while (_g_head1 is not None):
            val1 = _g_head1.item
            _g_head1 = _g_head1.next
            node1 = val1
            _g_head2 = g_nodes.h
            while (_g_head2 is not None):
                val2 = _g_head2.item
                _g_head2 = _g_head2.next
                node2 = val2
                if (node1.node.id > node2.node.id):
                    _g_head3 = node2.node.cons.h
                    while (_g_head3 is not None):
                        val3 = _g_head3.item
                        _g_head3 = _g_head3.next
                        con = val3
                        if (con.first == node1.node.id):
                            tmp2 = nextConId
                            nextConId = (nextConId + 1)
                            g_cons.add(draw_Connection(tmp2,node1,node2,con.second))
                            break
                    _g_head4 = node2.node.links.h
                    while (_g_head4 is not None):
                        val4 = _g_head4.item
                        _g_head4 = _g_head4.next
                        con1 = val4
                        if (con1.first == node1.node.id):
                            g_links.add(draw_Link(node1,node2,con1.second))
                            break
        _g_head5 = g_nodes.h
        while (_g_head5 is not None):
            val5 = _g_head5.item
            _g_head5 = _g_head5.next
            node = val5
            n = ((((-1 if ((python_lib_Random.random() > 0.5)) else 1)) * 1000) * python_lib_Random.random())
            node.valid = False
            node.xPos = n
            n1 = ((((-1 if ((python_lib_Random.random() > 0.5)) else 1)) * 1000) * python_lib_Random.random())
            node.valid = False
            node.yPos = n1
        _g_head6 = g_nodes.h
        while (_g_head6 is not None):
            val6 = _g_head6.item
            _g_head6 = _g_head6.next
            node11 = val6
            needCheck = True
            while needCheck:
                needCheck = False
                _g_head7 = g_nodes.h
                while (_g_head7 is not None):
                    val7 = _g_head7.item
                    _g_head7 = _g_head7.next
                    node21 = val7
                    if (((node11.node.id > node21.node.id) and ((node11.xPos == node21.xPos))) and ((node21.yPos == node21.yPos))):
                        n2 = ((((-1 if ((python_lib_Random.random() > 0.5)) else 1)) * 1000) * python_lib_Random.random())
                        node11.valid = False
                        node11.xPos = n2
                        n3 = ((((-1 if ((python_lib_Random.random() > 0.5)) else 1)) * 1000) * python_lib_Random.random())
                        node11.valid = False
                        node11.yPos = n3
                        needCheck = True
                        break
        _g_head8 = g_nodes.h
        while (_g_head8 is not None):
            val8 = _g_head8.item
            _g_head8 = _g_head8.next
            node3 = val8
            node3.velocityX = 0
            node3.velocityY = 0
        tE = 0
        xDif = None
        yDif = None
        r = None
        stepCount = 0
        stopCritSteps = None
        while True:
            stepCount = (stepCount + 1)
            stopCritSteps = False
            tE = 0
            _g_head9 = g_nodes.h
            while (_g_head9 is not None):
                val9 = _g_head9.item
                _g_head9 = _g_head9.next
                node4 = val9
                node4.forceX = 0
                node4.forceY = 0
                _g_head10 = g_nodes.h
                while (_g_head10 is not None):
                    val10 = _g_head10.item
                    _g_head10 = _g_head10.next
                    oNode = val10
                    if (node4 != oNode):
                        xDif = (node4.xPos - oNode.xPos)
                        yDif = (node4.yPos - oNode.yPos)
                        v = ((xDif * xDif) + ((yDif * yDif)))
                        if (v < 0):
                            r = Math.NaN
                        else:
                            r = python_lib_Math.sqrt(v)
                        if (r > 1):
                            node4.forceX = (node4.forceX + (((500.0 * xDif) / ((r * r)))))
                            node4.forceY = (node4.forceY + (((500.0 * yDif) / ((r * r)))))
                        else:
                            r = (r + 0.1)
                            node4.forceX = (node4.forceX + (((500.0 * ((xDif + (((10 * python_lib_Random.random()) * ((1 if ((python_lib_Random.random() > 0.5)) else -1))))))) / ((r * r)))))
                            node4.forceY = (node4.forceY + (((500.0 * ((yDif + (((10 * python_lib_Random.random()) * ((1 if ((python_lib_Random.random() > 0.5)) else -1))))))) / ((r * r)))))
                _g_head11 = g_cons.h
                while (_g_head11 is not None):
                    val11 = _g_head11.item
                    _g_head11 = _g_head11.next
                    con2 = val11
                    if (con2.n1 == node4):
                        xDif = (con2.n2.xPos - con2.n1.xPos)
                        yDif = (con2.n2.yPos - con2.n1.yPos)
                    elif (con2.n2 == node4):
                        xDif = (con2.n1.xPos - con2.n2.xPos)
                        yDif = (con2.n1.yPos - con2.n2.yPos)
                    else:
                        continue
                    v1 = ((xDif * xDif) + ((yDif * yDif)))
                    if (v1 < 0):
                        r = Math.NaN
                    else:
                        r = python_lib_Math.sqrt(v1)
                    displacement = (r - con2.expLength)
                    xDif = (xDif / r)
                    yDif = (yDif / r)
                    node4.forceX = (node4.forceX + (((0.1 * displacement) * xDif)))
                    node4.forceY = (node4.forceY + (((0.1 * displacement) * yDif)))
            _g_head12 = g_nodes.h
            while (_g_head12 is not None):
                val12 = _g_head12.item
                _g_head12 = _g_head12.next
                node5 = val12
                node5.velocityX = (((node5.velocityX + node5.forceX)) * 0.6)
                node5.velocityY = (((node5.velocityY + node5.forceY)) * 0.6)
                node5.valid = False
                node5.xPos = (node5.xPos + node5.velocityX)
                node5.valid = False
                node5.yPos = (node5.yPos + node5.velocityY)
                v2 = ((node5.velocityX * node5.velocityX) + ((node5.velocityY * node5.velocityY)))
                l1 = (Math.NaN if ((v2 < 0)) else python_lib_Math.sqrt(v2))
                tE = (tE + ((l1 * l1)))
            if (stepCount > 10000):
                stopCritSteps = True
            if (not (((tE > 0.5) and (not stopCritSteps)))):
                break
        rx = 0
        _g_head13 = g_nodes.h
        while (_g_head13 is not None):
            val13 = _g_head13.item
            _g_head13 = _g_head13.next
            node6 = val13
            rx = (rx + node6.xPos)
        cx = (rx / g_nodes.length)
        ry = 0
        _g_head14 = g_nodes.h
        while (_g_head14 is not None):
            val14 = _g_head14.item
            _g_head14 = _g_head14.next
            node7 = val14
            ry = (ry + node7.yPos)
        cy = (ry / g_nodes.length)
        _g_head15 = g_nodes.h
        while (_g_head15 is not None):
            val15 = _g_head15.item
            _g_head15 = _g_head15.next
            node8 = val15
            node8.valid = False
            node8.xPos = (node8.xPos - cx)
            node8.valid = False
            node8.yPos = (node8.yPos - cy)
        l2 = List()
        _g_head16 = g_links.h
        while (_g_head16 is not None):
            val16 = _g_head16.item
            _g_head16 = _g_head16.next
            link = val16
            link.xPos = Math.NaN
            link.yPos = Math.NaN
            link.setByUser = False
            vX = (link.n1.xPos - link.n2.xPos)
            vY = (link.n1.yPos - link.n2.yPos)
            vrX = (-vY / 8)
            vrY = (vX / 8)
            mX = (link.n2.xPos + ((vX / 2)))
            mY = (link.n2.yPos + ((vY / 2)))
            link.x1 = (mX - vrX)
            link.y1 = (mY - vrY)
            link.x2 = (mX + vrX)
            link.y2 = (mY + vrY)
            link.e1 = 0
            link.e2 = 0
            _g_head17 = g_nodes.h
            while (_g_head17 is not None):
                val17 = _g_head17.item
                _g_head17 = _g_head17.next
                node9 = val17
                dX = (node9.xPos - link.x1)
                dY = (node9.yPos - link.y1)
                v3 = ((dX * dX) + ((dY * dY)))
                link.e1 = (link.e1 + ((1 / ((Math.NaN if ((v3 < 0)) else python_lib_Math.sqrt(v3))))))
                dX1 = (node9.xPos - link.x2)
                dY1 = (node9.yPos - link.y2)
                v4 = ((dX1 * dX1) + ((dY1 * dY1)))
                link.e2 = (link.e2 + ((1 / ((Math.NaN if ((v4 < 0)) else python_lib_Math.sqrt(v4))))))
            l2.add(link)
        while (not l2.isEmpty()):
            bestEDiff = -1.0
            bestLink = None
            _g_head18 = l2.h
            while (_g_head18 is not None):
                val18 = _g_head18.item
                _g_head18 = _g_head18.next
                link1 = val18
                eDiff = Reflect.field(Math,"fabs")((link1.e1 - link1.e2))
                if ((eDiff > bestEDiff) or ((bestEDiff == -1))):
                    bestEDiff = eDiff
                    bestLink = link1
            bestLink.xPos = (bestLink.x1 if ((bestLink.e1 < bestLink.e2)) else bestLink.x2)
            bestLink.yPos = (bestLink.y1 if ((bestLink.e1 < bestLink.e2)) else bestLink.y2)
            l2.remove(bestLink)
            _g_head19 = l2.h
            while (_g_head19 is not None):
                val19 = _g_head19.item
                _g_head19 = _g_head19.next
                link2 = val19
                dX2 = (bestLink.xPos - link2.x1)
                dY2 = (bestLink.yPos - link2.y1)
                v5 = ((dX2 * dX2) + ((dY2 * dY2)))
                link2.e1 = (link2.e1 + ((1 / ((Math.NaN if ((v5 < 0)) else python_lib_Math.sqrt(v5))))))
                dX3 = (bestLink.xPos - link2.x2)
                dY3 = (bestLink.yPos - link2.y2)
                v6 = ((dX3 * dX3) + ((dY3 * dY3)))
                link2.e2 = (link2.e2 + ((1 / ((Math.NaN if ((v6 < 0)) else python_lib_Math.sqrt(v6))))))
        _this_newline = None
        _this_indent = None
        _this_countingOffset = 1
        _this_newline = "\n"
        _this_indent = "  "
        ow = -1
        oh = -1
        maxX = Math.NEGATIVE_INFINITY
        maxY = Math.NEGATIVE_INFINITY
        minX = Math.POSITIVE_INFINITY
        minY = Math.POSITIVE_INFINITY
        _g_head20 = g_nodes.h
        while (_g_head20 is not None):
            val20 = _g_head20.item
            _g_head20 = _g_head20.next
            node10 = val20
            b = (node10.xPos + node10.radius)
            if python_lib_Math.isnan(maxX):
                maxX = maxX
            elif python_lib_Math.isnan(b):
                maxX = b
            else:
                maxX = max(maxX,b)
            b1 = (node10.yPos + node10.radius)
            if python_lib_Math.isnan(maxY):
                maxY = maxY
            elif python_lib_Math.isnan(b1):
                maxY = b1
            else:
                maxY = max(maxY,b1)
            b2 = (node10.xPos - node10.radius)
            if python_lib_Math.isnan(minX):
                minX = minX
            elif python_lib_Math.isnan(b2):
                minX = b2
            else:
                minX = min(minX,b2)
            b3 = (node10.yPos - node10.radius)
            if python_lib_Math.isnan(minY):
                minY = minY
            elif python_lib_Math.isnan(b3):
                minY = b3
            else:
                minY = min(minY,b3)
        _g_head21 = g_links.h
        while (_g_head21 is not None):
            val21 = _g_head21.item
            _g_head21 = _g_head21.next
            link3 = val21
            tMax = 0
            bX = ((2 * link3.xPos) - ((((link3.n1.xPos + link3.n2.xPos)) / 2)))
            if ((((2 * bX) - link3.n1.xPos) - link3.n2.xPos) != 0):
                tMax = (((bX - link3.n1.xPos)) / ((((2 * bX) - link3.n1.xPos) - link3.n2.xPos)))
            if ((0 <= tMax) and ((tMax <= 1))):
                tMax = tMax
            else:
                tMax = 0
            x = ((((1 - tMax)) * (((((1 - tMax)) * link3.n1.xPos) + ((tMax * bX))))) + ((tMax * (((((1 - tMax)) * bX) + ((tMax * link3.n2.xPos)))))))
            tMax1 = 0
            bY = ((2 * link3.yPos) - ((((link3.n1.yPos + link3.n2.yPos)) / 2)))
            if ((((2 * bY) - link3.n1.yPos) - link3.n2.yPos) != 0):
                tMax1 = (((bY - link3.n1.yPos)) / ((((2 * bY) - link3.n1.yPos) - link3.n2.yPos)))
            if ((0 <= tMax1) and ((tMax1 <= 1))):
                tMax1 = tMax1
            else:
                tMax1 = 0
            y = ((((1 - tMax1)) * (((((1 - tMax1)) * link3.n1.yPos) + ((tMax1 * bY))))) + ((tMax1 * (((((1 - tMax1)) * bY) + ((tMax1 * link3.n2.yPos)))))))
            if python_lib_Math.isnan(maxX):
                maxX = maxX
            elif python_lib_Math.isnan(x):
                maxX = x
            else:
                maxX = max(maxX,x)
            if python_lib_Math.isnan(maxY):
                maxY = maxY
            elif python_lib_Math.isnan(y):
                maxY = y
            else:
                maxY = max(maxY,y)
            if python_lib_Math.isnan(minX):
                minX = minX
            elif python_lib_Math.isnan(x):
                minX = x
            else:
                minX = min(minX,x)
            if python_lib_Math.isnan(minY):
                minY = minY
            elif python_lib_Math.isnan(y):
                minY = y
            else:
                minY = min(minY,y)
        width = ((maxX - minX) + 30)
        height = ((maxY - minY) + 30)
        f1 = (ow / width)
        if (ow == -1):
            f1 = 1
        f2 = (oh / height)
        if (oh == -1):
            f2 = 1
        if python_lib_Math.isnan(f1):
            g_lastStretchFact = f1
        elif python_lib_Math.isnan(f2):
            g_lastStretchFact = f2
        else:
            g_lastStretchFact = min(f1,f2)
        ow = (width * g_lastStretchFact)
        oh = (height * g_lastStretchFact)
        result5 = List()
        result5.add(("<svg version='1.1' baseProfile='full' width='" + Std.string(ow)))
        result5.add(("' height='" + Std.string(oh)))
        result5.add((((((((("' viewBox='" + Std.string(((minX - 15)))) + ",") + Std.string(((minY - 15)))) + ",") + Std.string(width)) + ",") + Std.string(height)) + "' xmlns='http://www.w3.org/2000/svg'>"))
        if g_drawCons:
            _g_head22 = g_cons.h
            while (_g_head22 is not None):
                val22 = _g_head22.item
                _g_head22 = _g_head22.next
                con3 = val22
                result6 = List()
                result6.add("<line x1='")
                result6.add((Std.string(con3.n1.xPos) + "' y1='"))
                result6.add((Std.string(con3.n1.yPos) + "' x2='"))
                result6.add((Std.string(con3.n2.xPos) + "' y2='"))
                result6.add((Std.string(con3.n2.yPos) + "' stroke='"))
                result6.add((HxOverrides.stringOrNull(con3.strokeColor) + "' stroke-width='"))
                result6.add((Std.string(con3.strokeWidth) + "' "))
                if (not con3.dashedArray.isEmpty()):
                    result6.add("stroke-dasharray='")
                    result6.add(con3.dashedArray.join(","))
                    result6.add("' ")
                result6.add("/>")
                if ((con3.drawMutsByLine or con3.drawMutsByText) or con3.drawMutsByDots):
                    vX1 = (con3.n1.xPos - con3.n2.xPos)
                    vY1 = (con3.n1.yPos - con3.n2.yPos)
                    v7 = ((vX1 * vX1) + ((vY1 * vY1)))
                    vL = (Math.NaN if ((v7 < 0)) else python_lib_Math.sqrt(v7))
                    eVX = (vX1 / vL)
                    eVY = (vY1 / vL)
                    startX = (con3.n2.xPos + ((eVX * con3.n2.radius)))
                    startY = (con3.n2.yPos + ((eVY * con3.n2.radius)))
                    endX = ((con3.n2.xPos + vX1) - ((eVX * con3.n1.radius)))
                    endY = ((con3.n2.yPos + vY1) - ((eVY * con3.n1.radius)))
                    vX1 = (((endX - startX)) / ((con3.l.length + 1)))
                    vY1 = (((endY - startY)) / ((con3.l.length + 1)))
                    iii = 0
                    _g_head23 = con3.l.h
                    while (_g_head23 is not None):
                        val23 = _g_head23.item
                        _g_head23 = _g_head23.next
                        text = val23
                        iii = (iii + 1)
                        x1 = (startX + ((vX1 * iii)))
                        y1 = (startY + ((vY1 * iii)))
                        if con3.drawMutsByDots:
                            result6.add("<circle cx='")
                            result6.add((Std.string(x1) + "' cy='"))
                            result6.add((Std.string(y1) + "' r='"))
                            result6.add((Std.string(con3.drawMutsDotsSize) + "' fill='"))
                            result6.add(con3.drawMutsDotsColor)
                            if (not con3.drawMutsDotsDashedArray.isEmpty()):
                                result6.add("' stroke-dasharray='")
                                result6.add(con3.drawMutsDotsDashedArray.join(","))
                                result6.add("'")
                            result6.add("/>")
                        if con3.drawMutsByLine:
                            x11 = (x1 - ((eVY * con3.drawMutsLineLen)))
                            y11 = (y1 + ((eVX * con3.drawMutsLineLen)))
                            x2 = (x1 + ((eVY * con3.drawMutsLineLen)))
                            y2 = (y1 - ((eVX * con3.drawMutsLineLen)))
                            result6.add("<line x1='")
                            result6.add((Std.string(x11) + "' y1='"))
                            result6.add((Std.string(y11) + "' x2='"))
                            result6.add((Std.string(x2) + "' y2='"))
                            result6.add((Std.string(y2) + "' stroke='"))
                            result6.add((HxOverrides.stringOrNull(con3.drawMutsLineStrokeColor) + "' stroke-width='"))
                            result6.add((Std.string(con3.drawMutsLineWidth) + "'"))
                            if (not con3.drawMutsLineDashedArray.isEmpty()):
                                result6.add(" stroke-dasharray='")
                                result6.add(con3.drawMutsLineDashedArray.join(","))
                                result6.add("'")
                            result6.add("/>")
                        if con3.drawMutsByText:
                            result6.add("<text x='")
                            result6.add((Std.string((x1 + con3.drawMutsTextPX)) + "' y='"))
                            result6.add((Std.string(((y1 + ((con3.drawMutsTextSize / 2))) + con3.drawMutsTextPY)) + "' fill='"))
                            result6.add((HxOverrides.stringOrNull(con3.drawMutsTextColor) + "' font-family='"))
                            result6.add((HxOverrides.stringOrNull(con3.drawMutsTextFont) + "' font-size='"))
                            result6.add((Std.string(con3.drawMutsTextSize) + "'"))
                            result6.add(((">" + Std.string(text)) + "</text>"))
                result5.add(result6.join(""))
        if g_drawCurves:
            result5.add("<g fill='none'>")
            _g_head24 = g_links.h
            while (_g_head24 is not None):
                val24 = _g_head24.item
                _g_head24 = _g_head24.next
                link4 = val24
                result7 = List()
                if ((link4.strokeColorList is None) or link4.strokeColorList.isEmpty()):
                    result7.add("<path d='M")
                    result7.add((Std.string(link4.n1.xPos) + " "))
                    result7.add((Std.string(link4.n1.yPos) + " Q"))
                    result7.add((" " + Std.string((((2 * link4.xPos) - ((((link4.n1.xPos + link4.n2.xPos)) / 2)))))))
                    result7.add((" " + Std.string((((2 * link4.yPos) - ((((link4.n1.yPos + link4.n2.yPos)) / 2)))))))
                    result7.add((" " + Std.string(link4.n2.xPos)))
                    result7.add((" " + Std.string(link4.n2.yPos)))
                    result7.add("' stroke='")
                    result7.add(link4.strokeColor)
                    result7.add("' stroke-width='")
                    result7.add((Std.string(link4.strokeWidth) + "' "))
                    if (not link4.dashedArray.isEmpty()):
                        result7.add("stroke-dasharray='")
                        result7.add(link4.dashedArray.join(","))
                        result7.add("' ")
                    result7.add("/>")
                else:
                    b00X = (-2 * ((link4.xPos - link4.n1.xPos)))
                    b00Y = (-2 * ((link4.yPos - link4.n1.yPos)))
                    b10X = (-2 * ((link4.n2.xPos - link4.xPos)))
                    b10Y = (-2 * ((link4.n2.yPos - link4.yPos)))
                    b05X = (b00X + b10X)
                    b05Y = (b00Y + b10Y)
                    v00X = b00Y
                    v00Y = -b00X
                    v8 = ((v00X * v00X) + ((v00Y * v00Y)))
                    l00 = (Math.NaN if ((v8 < 0)) else python_lib_Math.sqrt(v8))
                    v00X = (v00X / l00)
                    v00Y = (v00Y / l00)
                    v10X = b10Y
                    v10Y = -b10X
                    v9 = ((v10X * v10X) + ((v10Y * v10Y)))
                    l10 = (Math.NaN if ((v9 < 0)) else python_lib_Math.sqrt(v9))
                    v10X = (v10X / l10)
                    v10Y = (v10Y / l10)
                    v05X = b05Y
                    v05Y = -b05X
                    v10 = ((v05X * v05X) + ((v05Y * v05Y)))
                    l05 = (Math.NaN if ((v10 < 0)) else python_lib_Math.sqrt(v10))
                    v05X = (v05X / l05)
                    v05Y = (v05Y / l05)
                    sum = 0
                    _g_head25 = link4.strokeColorList.h
                    while (_g_head25 is not None):
                        val25 = _g_head25.item
                        _g_head25 = _g_head25.next
                        p = val25
                        sum = (sum + p.second)
                    dSum = 0
                    factor = (link4.strokeWidth / sum)
                    _g_head26 = link4.strokeColorList.h
                    while (_g_head26 is not None):
                        val26 = _g_head26.item
                        _g_head26 = _g_head26.next
                        p1 = val26
                        c = p1.first
                        d2 = p1.second
                        l3 = ((((((sum - d2)) / 2) - dSum)) * factor)
                        dSum = (dSum + d2)
                        result7.add("<path d='M")
                        result7.add((Std.string((link4.n1.xPos + ((v00X * l3)))) + " "))
                        result7.add((Std.string((link4.n1.yPos + ((v00Y * l3)))) + " Q"))
                        result7.add((" " + Std.string((((2 * ((link4.xPos + ((v05X * l3))))) - (((((link4.n1.xPos + ((v00X * l3))) + ((link4.n2.xPos + ((v10X * l3)))))) / 2)))))))
                        result7.add((" " + Std.string((((2 * ((link4.yPos + ((v05Y * l3))))) - (((((link4.n1.yPos + ((v00Y * l3))) + ((link4.n2.yPos + ((v10Y * l3)))))) / 2)))))))
                        result7.add((" " + Std.string(((link4.n2.xPos + ((v10X * l3)))))))
                        result7.add((" " + Std.string(((link4.n2.yPos + ((v10Y * l3)))))))
                        result7.add("' stroke='")
                        result7.add(c)
                        result7.add("' stroke-width='")
                        result7.add((Std.string((d2 * factor)) + "' "))
                        if (not link4.dashedArray.isEmpty()):
                            result7.add("stroke-dasharray='")
                            result7.add(link4.dashedArray.join(","))
                            result7.add("' ")
                        result7.add("/>")
                result5.add(result7.join(""))
            result5.add("</g>")
        if g_drawCircles:
            _g_head27 = g_nodes.h
            while (_g_head27 is not None):
                val27 = _g_head27.item
                _g_head27 = _g_head27.next
                node12 = val27
                tmp3 = None
                if ((not g_drawCirclesMedians) and ((node12.node.type != parsing_SEQ_TYPE.SAMPLED_SEQUENCE))):
                    tmp3 = ""
                elif node12.valid:
                    tmp3 = node12.svg
                else:
                    result8 = List()
                    def _hx_local_38(t):
                        if ((t.first is not None) and ((t.first != ""))):
                            return (t.second > 0)
                        else:
                            return False
                    node12.pie = node12.pie.filter(_hx_local_38)
                    needArcs = False
                    result8.add("<circle id='")
                    result8.add(("n" + Std.string(node12.node.id)))
                    result8.add("' ")
                    result8.add("stroke='")
                    result8.add(node12.strokeColor)
                    result8.add("' ")
                    result8.add("stroke-width='")
                    result8.add(("" + Std.string(node12.strokeWidth)))
                    result8.add("' ")
                    if (not node12.dashedArray.isEmpty()):
                        result8.add("stroke-dasharray='")
                        result8.add(node12.dashedArray.join(","))
                        result8.add("' ")
                    result8.add("cx='")
                    result8.add(("" + Std.string(node12.xPos)))
                    result8.add("' ")
                    result8.add("cy='")
                    result8.add(("" + Std.string(node12.yPos)))
                    result8.add("' ")
                    result8.add("r='")
                    result8.add(("" + Std.string(node12.radius)))
                    result8.add("' ")
                    if node12.pie.isEmpty():
                        result8.add("fill='blue'")
                    elif (node12.pie.length == 1):
                        result8.add("fill='")
                        result8.add(node12.pie.first().first)
                        result8.add("' ")
                    else:
                        needArcs = True
                    result8.add("/>")
                    if needArcs:
                        summe = 0
                        _g_head28 = node12.pie.h
                        while (_g_head28 is not None):
                            val28 = _g_head28.item
                            _g_head28 = _g_head28.next
                            p2 = val28
                            summe = (summe + p2.second)
                        cs = 0
                        _g_head29 = node12.pie.h
                        while (_g_head29 is not None):
                            val29 = _g_head29.item
                            _g_head29 = _g_head29.next
                            p3 = val29
                            color = p3.first
                            perc = (p3.second / summe)
                            v11 = (((cs / summe) * 2) * Math.PI)
                            pX1 = ((((Math.NaN if (((v11 == Math.POSITIVE_INFINITY) or ((v11 == Math.NEGATIVE_INFINITY)))) else python_lib_Math.sin(v11))) * node12.radius) + node12.xPos)
                            v12 = (((cs / summe) * 2) * Math.PI)
                            pY1 = ((-((Math.NaN if (((v12 == Math.POSITIVE_INFINITY) or ((v12 == Math.NEGATIVE_INFINITY)))) else python_lib_Math.cos(v12))) * node12.radius) + node12.yPos)
                            cs = (cs + p3.second)
                            v13 = (((cs / summe) * 2) * Math.PI)
                            pX2 = ((((Math.NaN if (((v13 == Math.POSITIVE_INFINITY) or ((v13 == Math.NEGATIVE_INFINITY)))) else python_lib_Math.sin(v13))) * node12.radius) + node12.xPos)
                            v14 = (((cs / summe) * 2) * Math.PI)
                            pY2 = ((-((Math.NaN if (((v14 == Math.POSITIVE_INFINITY) or ((v14 == Math.NEGATIVE_INFINITY)))) else python_lib_Math.cos(v14))) * node12.radius) + node12.yPos)
                            arcFlag = (0 if ((perc < 0.5)) else 1)
                            result8.add((((((((((((((((((((("<path fill='" + ("null" if color is None else color)) + "' d='M") + Std.string(node12.xPos)) + ",") + Std.string(node12.yPos)) + "L") + Std.string(pX1)) + ",") + Std.string(pY1)) + "A") + Std.string(node12.radius)) + ",") + Std.string(node12.radius)) + " 1 ") + Std.string(arcFlag)) + ",1 ") + Std.string(pX2)) + ", ") + Std.string(pY2)) + " z'/>"))
                    node12.svg = result8.join("")
                    node12.valid = True
                    tmp3 = node12.svg
                result5.add(tmp3)
        if g_drawCirclesNames:
            _g_head30 = g_nodes.h
            while (_g_head30 is not None):
                val30 = _g_head30.item
                _g_head30 = _g_head30.next
                node13 = val30
                tmp4 = None
                if (node13.node.type != parsing_SEQ_TYPE.SAMPLED_SEQUENCE):
                    tmp4 = ""
                else:
                    x3 = ((node13.xPos + node13.radius) + 5)
                    y3 = ((node13.yPos + node13.radius) + 5)
                    tmp4 = (((((("<text x='" + Std.string(x3)) + "' y='") + Std.string(y3)) + "'>") + HxOverrides.stringOrNull(node13.node.names.first())) + "</text>")
                result5.add(tmp4)
        if g_drawAngles:
            _g_head31 = g_cons.h
            while (_g_head31 is not None):
                val31 = _g_head31.item
                _g_head31 = _g_head31.next
                c1 = val31
                _g_head32 = g_cons.h
                while (_g_head32 is not None):
                    val32 = _g_head32.item
                    _g_head32 = _g_head32.next
                    c2 = val32
                    if (c1.id > c2.id):
                        nA = None
                        nB = None
                        nC = None
                        if (c1.n1 == c2.n1):
                            nA = c1.n2
                            nB = c2.n2
                            nC = c1.n1
                        elif (c1.n1 == c2.n2):
                            nA = c1.n2
                            nB = c2.n1
                            nC = c1.n1
                        elif (c1.n2 == c2.n1):
                            nA = c1.n1
                            nB = c2.n2
                            nC = c1.n2
                        elif (c1.n2 == c2.n2):
                            nA = c1.n1
                            nB = c2.n1
                            nC = c1.n2
                        if (nC is not None):
                            v1X = (nA.xPos - nC.xPos)
                            v1Y = (nA.yPos - nC.yPos)
                            v2X = (nB.xPos - nC.xPos)
                            v2Y = (nB.yPos - nC.yPos)
                            v15 = ((v1X * v1X) + ((v1Y * v1Y)))
                            l11 = (Math.NaN if ((v15 < 0)) else python_lib_Math.sqrt(v15))
                            v16 = ((v2X * v2X) + ((v2Y * v2Y)))
                            l21 = (Math.NaN if ((v16 < 0)) else python_lib_Math.sqrt(v16))
                            c3 = ((v1X * v2X) + ((v1Y * v2Y)))
                            wXV = ((v1X / l11) + ((v2X / l21)))
                            wYV = ((v1Y / l11) + ((v2Y / l21)))
                            v17 = ((wXV * wXV) + ((wYV * wYV)))
                            wL = (Math.NaN if ((v17 < 0)) else python_lib_Math.sqrt(v17))
                            xx = (nC.xPos + (((wXV / wL) * ((nC.radius + 20)))))
                            yy = (nC.yPos + (((wYV / wL) * ((nC.radius + 20)))))
                            txt = HxString.substr(("" + Std.string((((Math.acos((c3 / ((l11 * l21)))) * 360) / ((2 * Math.PI)))))),0,6)
                            result5.add((((((("<text x='" + Std.string(xx)) + "' y='") + Std.string(yy)) + "' text-anchor='middle'>") + ("null" if txt is None else txt)) + "</text>"))
        if g_drawBezierPoints:
            _g_head33 = g_links.h
            while (_g_head33 is not None):
                val33 = _g_head33.item
                _g_head33 = _g_head33.next
                link5 = val33
                result5.add((((((((("<circle cx='" + Std.string(link5.xPos)) + "' cy='") + Std.string(link5.yPos)) + "' r='5' fill='") + HxOverrides.stringOrNull(link5.strokeColor)) + "' stroke='") + HxOverrides.stringOrNull((("black" if (link5.setByUser) else "red")))) + "' />"))
        if g_drawCenter:
            rx1 = 0
            _g_head34 = g_nodes.h
            while (_g_head34 is not None):
                val34 = _g_head34.item
                _g_head34 = _g_head34.next
                node14 = val34
                rx1 = (rx1 + node14.xPos)
            x4 = (rx1 / g_nodes.length)
            ry1 = 0
            _g_head35 = g_nodes.h
            while (_g_head35 is not None):
                val35 = _g_head35.item
                _g_head35 = _g_head35.next
                node15 = val35
                ry1 = (ry1 + node15.yPos)
            y4 = (ry1 / g_nodes.length)
            result5.add((((((((("<line x1='" + Std.string(x4)) + "' y1='") + Std.string(minY)) + "' x2='") + Std.string(x4)) + "' y2='") + Std.string(maxY)) + "' stroke='green' stroke-dasharray='3 3' />"))
            result5.add((((((((("<line x1='" + Std.string(minX)) + "' y1='") + Std.string(y4)) + "' x2='") + Std.string(maxX)) + "' y2='") + Std.string(y4)) + "' stroke='green' stroke-dasharray='3 3' />"))
            rx2 = 0
            _g_head36 = g_nodes.h
            while (_g_head36 is not None):
                val36 = _g_head36.item
                _g_head36 = _g_head36.next
                node16 = val36
                rx2 = (rx2 + node16.xPos)
            tmp5 = (("<circle cx='" + Std.string((rx2 / g_nodes.length))) + "' cy='")
            ry2 = 0
            _g_head37 = g_nodes.h
            while (_g_head37 is not None):
                val37 = _g_head37.item
                _g_head37 = _g_head37.next
                node17 = val37
                ry2 = (ry2 + node17.yPos)
            result5.add(((("null" if tmp5 is None else tmp5) + Std.string((ry2 / g_nodes.length))) + "' r='5' fill='green' />"))
        result5.add("</svg>")
        s1 = result5.join("")
        Sys.stdout().writeString(s1)


class draw_Graph:
    _hx_class_name = "draw.Graph"
    __slots__ = ("nodes", "cons", "links", "drawCircles", "drawCirclesNames", "drawCirclesMedians", "drawCons", "drawCurves", "drawBezierPoints", "drawCenter", "drawAngles", "lastStretchFact")
    _hx_fields = ["nodes", "cons", "links", "drawCircles", "drawCirclesNames", "drawCirclesMedians", "drawCons", "drawCurves", "drawBezierPoints", "drawCenter", "drawAngles", "lastStretchFact"]
    _hx_methods = ["assignMutsLines", "assignMutsText", "assignButsByDots", "getNearestO", "getNodeById", "assingPiesByTxt", "assignPieCharts", "initStrokeColorListByStr", "initStrokeColorList", "generateRandomColor", "colorfyFFR", "colorNetwork", "pieToTxt", "saveStyle", "parsePie", "loadStyle", "getSvgCode", "assignLinkPos", "assignRandomNodePos", "checkNoNodeAtSamePoint", "calcCenterX", "calcCenterY", "centerPos", "stretch", "mult_radius", "mirrorX", "mirrorY", "rotateP90", "rotateN90", "rotate", "fluct", "forceDirectedMethod", "modifyLinks", "modifyCons", "modifyNodes", "resetLinkColors", "calculateEnergy"]
    _hx_statics = ["generateRandomHex", "dist", "main"]

    def __init__(self,l):
        self.lastStretchFact = None
        self.drawAngles = False
        self.drawCenter = False
        self.drawBezierPoints = False
        self.drawCurves = True
        self.drawCons = True
        self.drawCirclesMedians = False
        self.drawCirclesNames = False
        self.drawCircles = True
        self.drawCircles = True
        self.drawCirclesNames = False
        self.drawCirclesMedians = False
        self.drawCons = True
        self.drawCurves = True
        self.drawBezierPoints = False
        self.drawCenter = False
        self.drawAngles = False
        self.nodes = List()
        self.cons = List()
        self.links = List()
        _g_head = l.h
        while (_g_head is not None):
            val = _g_head.item
            _g_head = _g_head.next
            e = val
            self.nodes.add(draw_NodePos(e))
        nextConId = 0
        _g_head1 = self.nodes.h
        while (_g_head1 is not None):
            val1 = _g_head1.item
            _g_head1 = _g_head1.next
            node1 = val1
            _g_head2 = self.nodes.h
            while (_g_head2 is not None):
                val2 = _g_head2.item
                _g_head2 = _g_head2.next
                node2 = val2
                if (node1.node.id > node2.node.id):
                    _g_head3 = node2.node.cons.h
                    while (_g_head3 is not None):
                        val3 = _g_head3.item
                        _g_head3 = _g_head3.next
                        con = val3
                        if (con.first == node1.node.id):
                            tmp = nextConId
                            nextConId = (nextConId + 1)
                            self.cons.add(draw_Connection(tmp,node1,node2,con.second))
                            break
                    _g_head4 = node2.node.links.h
                    while (_g_head4 is not None):
                        val4 = _g_head4.item
                        _g_head4 = _g_head4.next
                        con1 = val4
                        if (con1.first == node1.node.id):
                            self.links.add(draw_Link(node1,node2,con1.second))
                            break

    def assignMutsLines(self,drawMutsByLine,drawMutsLineStrokeColor,drawMutsLineWidth,drawMutsLineLen,drawMutsLineDashedArray):
        drawMutsLineDashedArray_ = List()
        _g = 0
        while (_g < len(drawMutsLineDashedArray)):
            e = (drawMutsLineDashedArray[_g] if _g >= 0 and _g < len(drawMutsLineDashedArray) else None)
            _g = (_g + 1)
            drawMutsLineDashedArray_.add(e)
        _g_head = self.cons.h
        while (_g_head is not None):
            val = _g_head.item
            _g_head = _g_head.next
            con = val
            con.drawMutsByLine = drawMutsByLine
            con.drawMutsLineStrokeColor = drawMutsLineStrokeColor
            con.drawMutsLineWidth = drawMutsLineWidth
            con.drawMutsLineLen = drawMutsLineLen
            con.drawMutsLineDashedArray = drawMutsLineDashedArray_

    def assignMutsText(self,drawMutsByText,drawMutsTextFont,drawMutsTextSize,drawMutsTextColor,drawMutsTextPX,drawMutsTextPY):
        _g_head = self.cons.h
        while (_g_head is not None):
            val = _g_head.item
            _g_head = _g_head.next
            con = val
            con.drawMutsByText = drawMutsByText
            con.drawMutsTextFont = drawMutsTextFont
            con.drawMutsTextSize = drawMutsTextSize
            con.drawMutsTextColor = drawMutsTextColor
            con.drawMutsTextPX = drawMutsTextPX
            con.drawMutsTextPY = drawMutsTextPY

    def assignButsByDots(self,drawMutsByDots,drawMutsDotsSize,drawMutsDotsColor,drawMutsDotsDashedArray):
        drawMutsDotsDashedArray_ = List()
        _g = 0
        while (_g < len(drawMutsDotsDashedArray)):
            e = (drawMutsDotsDashedArray[_g] if _g >= 0 and _g < len(drawMutsDotsDashedArray) else None)
            _g = (_g + 1)
            drawMutsDotsDashedArray_.add(e)
        _g_head = self.cons.h
        while (_g_head is not None):
            val = _g_head.item
            _g_head = _g_head.next
            con = val
            con.drawMutsByDots = drawMutsByDots
            con.drawMutsDotsSize = drawMutsDotsSize
            con.drawMutsDotsColor = drawMutsDotsColor
            con.drawMutsDotsDashedArray = drawMutsDotsDashedArray_

    def getNearestO(self,x,y):
        maxX = Math.NEGATIVE_INFINITY
        maxY = Math.NEGATIVE_INFINITY
        minX = Math.POSITIVE_INFINITY
        minY = Math.POSITIVE_INFINITY
        _g_head = self.nodes.h
        while (_g_head is not None):
            val = _g_head.item
            _g_head = _g_head.next
            node = val
            b = (node.xPos + node.radius)
            if python_lib_Math.isnan(maxX):
                maxX = maxX
            elif python_lib_Math.isnan(b):
                maxX = b
            else:
                maxX = max(maxX,b)
            b1 = (node.yPos + node.radius)
            if python_lib_Math.isnan(maxY):
                maxY = maxY
            elif python_lib_Math.isnan(b1):
                maxY = b1
            else:
                maxY = max(maxY,b1)
            b2 = (node.xPos - node.radius)
            if python_lib_Math.isnan(minX):
                minX = minX
            elif python_lib_Math.isnan(b2):
                minX = b2
            else:
                minX = min(minX,b2)
            b3 = (node.yPos - node.radius)
            if python_lib_Math.isnan(minY):
                minY = minY
            elif python_lib_Math.isnan(b3):
                minY = b3
            else:
                minY = min(minY,b3)
        _g_head1 = self.links.h
        while (_g_head1 is not None):
            val1 = _g_head1.item
            _g_head1 = _g_head1.next
            link = val1
            tMax = 0
            bX = ((2 * link.xPos) - ((((link.n1.xPos + link.n2.xPos)) / 2)))
            if ((((2 * bX) - link.n1.xPos) - link.n2.xPos) != 0):
                tMax = (((bX - link.n1.xPos)) / ((((2 * bX) - link.n1.xPos) - link.n2.xPos)))
            if ((0 <= tMax) and ((tMax <= 1))):
                tMax = tMax
            else:
                tMax = 0
            x1 = ((((1 - tMax)) * (((((1 - tMax)) * link.n1.xPos) + ((tMax * bX))))) + ((tMax * (((((1 - tMax)) * bX) + ((tMax * link.n2.xPos)))))))
            tMax1 = 0
            bY = ((2 * link.yPos) - ((((link.n1.yPos + link.n2.yPos)) / 2)))
            if ((((2 * bY) - link.n1.yPos) - link.n2.yPos) != 0):
                tMax1 = (((bY - link.n1.yPos)) / ((((2 * bY) - link.n1.yPos) - link.n2.yPos)))
            if ((0 <= tMax1) and ((tMax1 <= 1))):
                tMax1 = tMax1
            else:
                tMax1 = 0
            y1 = ((((1 - tMax1)) * (((((1 - tMax1)) * link.n1.yPos) + ((tMax1 * bY))))) + ((tMax1 * (((((1 - tMax1)) * bY) + ((tMax1 * link.n2.yPos)))))))
            if python_lib_Math.isnan(maxX):
                maxX = maxX
            elif python_lib_Math.isnan(x1):
                maxX = x1
            else:
                maxX = max(maxX,x1)
            if python_lib_Math.isnan(maxY):
                maxY = maxY
            elif python_lib_Math.isnan(y1):
                maxY = y1
            else:
                maxY = max(maxY,y1)
            if python_lib_Math.isnan(minX):
                minX = minX
            elif python_lib_Math.isnan(x1):
                minX = x1
            else:
                minX = min(minX,x1)
            if python_lib_Math.isnan(minY):
                minY = minY
            elif python_lib_Math.isnan(y1):
                minY = y1
            else:
                minY = min(minY,y1)
        x = ((x + minX) - 15)
        y = ((y + minY) - 15)
        result = None
        best = Math.POSITIVE_INFINITY
        d = 0
        if self.drawCircles:
            _g_head2 = self.nodes.h
            while (_g_head2 is not None):
                val2 = _g_head2.item
                _g_head2 = _g_head2.next
                o = val2
                dX = (x - o.xPos)
                dY = (y - o.yPos)
                v = ((dX * dX) + ((dY * dY)))
                if (v < 0):
                    d = Math.NaN
                else:
                    d = python_lib_Math.sqrt(v)
                if (d < best):
                    best = d
                    result = o
        if self.drawBezierPoints:
            _g_head3 = self.links.h
            while (_g_head3 is not None):
                val3 = _g_head3.item
                _g_head3 = _g_head3.next
                o1 = val3
                dX1 = (x - o1.xPos)
                dY1 = (y - o1.yPos)
                v1 = ((dX1 * dX1) + ((dY1 * dY1)))
                if (v1 < 0):
                    d = Math.NaN
                else:
                    d = python_lib_Math.sqrt(v1)
                if (d < best):
                    best = d
                    result = o1
        return result

    def getNodeById(self,id):
        result = None
        _g_head = self.nodes.h
        while (_g_head is not None):
            val = _g_head.item
            _g_head = _g_head.next
            node = val
            if (node.node.id == id):
                result = node
                break
        return result

    def assingPiesByTxt(self,s,ignoreCase,byIndNameOnly):
        l = parsing_LstParser.parseLst(s)
        _g_head = self.nodes.h
        while (_g_head is not None):
            val = _g_head.item
            _g_head = _g_head.next
            node = val
            if (node.node.names.length == 0):
                l1 = List()
                l1.add(util_Pair("grey",1))
                node.valid = False
                node.pie = l1
                continue
            l_ = List()
            _g_head1 = node.node.names.h
            while (_g_head1 is not None):
                val1 = _g_head1.item
                _g_head1 = _g_head1.next
                name = val1
                if byIndNameOnly:
                    result = name
                    if (name is not None):
                        _hx_str = mj_Seq.delimiter
                        pos = name.rfind(_hx_str, 0, len(name))
                        if (pos != -1):
                            result = HxString.substr(name,0,pos)
                    name = result
                colorName = None
                _g_head2 = l.h
                while (_g_head2 is not None):
                    val2 = _g_head2.item
                    _g_head2 = _g_head2.next
                    p = val2
                    if ignoreCase:
                        if (p.first.upper() == name.upper()):
                            colorName = p.second.lower()
                            break
                    elif (p.first == name):
                        colorName = p.second.lower()
                        break
                if (colorName is None):
                    print(str((("WARN: No colorname found/given for '" + ("null" if name is None else name)) + "'!")))
                found = False
                _g_head3 = l_.h
                while (_g_head3 is not None):
                    val3 = _g_head3.item
                    _g_head3 = _g_head3.next
                    p1 = val3
                    if (p1.first == colorName):
                        p1.second = (p1.second + 1)
                        found = True
                        break
                if (not found):
                    l_.add(util_Pair(colorName,1))
            node.valid = False
            node.pie = l_

    def assignPieCharts(self,l,ignoreCase,byIndNameOnly):
        _g_head = self.nodes.h
        while (_g_head is not None):
            val = _g_head.item
            _g_head = _g_head.next
            node = val
            if (node.node.names.length == 0):
                l1 = List()
                l1.add(util_Pair("grey",1))
                node.valid = False
                node.pie = l1
                continue
            l_ = List()
            _g_head1 = node.node.names.h
            while (_g_head1 is not None):
                val1 = _g_head1.item
                _g_head1 = _g_head1.next
                name = val1
                if byIndNameOnly:
                    result = name
                    if (name is not None):
                        _hx_str = mj_Seq.delimiter
                        pos = name.rfind(_hx_str, 0, len(name))
                        if (pos != -1):
                            result = HxString.substr(name,0,pos)
                    name = result
                colorName = None
                _g_head2 = l.h
                while (_g_head2 is not None):
                    val2 = _g_head2.item
                    _g_head2 = _g_head2.next
                    p = val2
                    if ignoreCase:
                        if (p.first.upper() == name.upper()):
                            colorName = p.second.lower()
                            break
                    elif (p.first == name):
                        colorName = p.second.lower()
                        break
                if (colorName is None):
                    print(str((("WARN: No colorname found/given for '" + ("null" if name is None else name)) + "'!")))
                found = False
                _g_head3 = l_.h
                while (_g_head3 is not None):
                    val3 = _g_head3.item
                    _g_head3 = _g_head3.next
                    p1 = val3
                    if (p1.first == colorName):
                        p1.second = (p1.second + 1)
                        found = True
                        break
                if (not found):
                    l_.add(util_Pair(colorName,1))
            node.valid = False
            node.pie = l_

    def initStrokeColorListByStr(self,s,ignoreCase):
        self.initStrokeColorList(parsing_LstParser.parseLst(s),ignoreCase)

    def initStrokeColorList(self,l,ignoreCase):
        _g_head = self.links.h
        while (_g_head is not None):
            val = _g_head.item
            _g_head = _g_head.next
            link = val
            _hx_map = haxe_ds_StringMap()
            _g_head1 = link.n1.node.names.h
            while (_g_head1 is not None):
                val1 = _g_head1.item
                _g_head1 = _g_head1.next
                name1 = val1
                result = name1
                if (name1 is not None):
                    _hx_str = mj_Seq.delimiter
                    pos = name1.rfind(_hx_str, 0, len(name1))
                    if (pos != -1):
                        result = HxString.substr(name1,0,pos)
                nn1 = result
                _g_head2 = link.n2.node.names.h
                while (_g_head2 is not None):
                    val2 = _g_head2.item
                    _g_head2 = _g_head2.next
                    name2 = val2
                    result1 = name2
                    if (name2 is not None):
                        str1 = mj_Seq.delimiter
                        pos1 = name2.rfind(str1, 0, len(name2))
                        if (pos1 != -1):
                            result1 = HxString.substr(name2,0,pos1)
                    nn2 = result1
                    if (nn1 == nn2):
                        colorName = None
                        if ignoreCase:
                            _g_head3 = l.h
                            while (_g_head3 is not None):
                                val3 = _g_head3.item
                                _g_head3 = _g_head3.next
                                p = val3
                                if (p.first.upper() == nn1.upper()):
                                    colorName = p.second.lower()
                                    break
                        else:
                            _g_head4 = l.h
                            while (_g_head4 is not None):
                                val4 = _g_head4.item
                                _g_head4 = _g_head4.next
                                p1 = val4
                                if (p1.first == nn1):
                                    colorName = p1.second.lower()
                                    break
                        if (colorName in _hx_map.h):
                            value = (_hx_map.h.get(colorName,None) + 1)
                            _hx_map.h[colorName] = value
                        else:
                            _hx_map.h[colorName] = 1
            link.strokeColorList = List()
            key = _hx_map.keys()
            while key.hasNext():
                key1 = key.next()
                link.strokeColorList.add(util_Pair(key1,_hx_map.h.get(key1,None)))

    def generateRandomColor(self):
        rand = python_lib_Random.random()
        result = None
        if (rand <= 0.0625):
            result = "0"
        elif (rand <= 0.125):
            result = "1"
        elif (rand <= 0.1875):
            result = "2"
        elif (rand <= 0.25):
            result = "3"
        elif (rand <= 0.3125):
            result = "4"
        elif (rand <= 0.375):
            result = "5"
        elif (rand <= 0.4375):
            result = "6"
        elif (rand <= 0.5):
            result = "7"
        elif (rand <= 0.5625):
            result = "8"
        elif (rand <= 0.625):
            result = "9"
        elif (rand <= 0.6875):
            result = "A"
        elif (rand <= 0.75):
            result = "B"
        elif (rand <= 0.8125):
            result = "C"
        elif (rand <= 0.875):
            result = "D"
        elif (rand <= 0.9375):
            result = "E"
        else:
            result = "F"
        rand1 = python_lib_Random.random()
        result1 = None
        if (rand1 <= 0.0625):
            result1 = "0"
        elif (rand1 <= 0.125):
            result1 = "1"
        elif (rand1 <= 0.1875):
            result1 = "2"
        elif (rand1 <= 0.25):
            result1 = "3"
        elif (rand1 <= 0.3125):
            result1 = "4"
        elif (rand1 <= 0.375):
            result1 = "5"
        elif (rand1 <= 0.4375):
            result1 = "6"
        elif (rand1 <= 0.5):
            result1 = "7"
        elif (rand1 <= 0.5625):
            result1 = "8"
        elif (rand1 <= 0.625):
            result1 = "9"
        elif (rand1 <= 0.6875):
            result1 = "A"
        elif (rand1 <= 0.75):
            result1 = "B"
        elif (rand1 <= 0.8125):
            result1 = "C"
        elif (rand1 <= 0.875):
            result1 = "D"
        elif (rand1 <= 0.9375):
            result1 = "E"
        else:
            result1 = "F"
        rand2 = python_lib_Random.random()
        result2 = None
        if (rand2 <= 0.0625):
            result2 = "0"
        elif (rand2 <= 0.125):
            result2 = "1"
        elif (rand2 <= 0.1875):
            result2 = "2"
        elif (rand2 <= 0.25):
            result2 = "3"
        elif (rand2 <= 0.3125):
            result2 = "4"
        elif (rand2 <= 0.375):
            result2 = "5"
        elif (rand2 <= 0.4375):
            result2 = "6"
        elif (rand2 <= 0.5):
            result2 = "7"
        elif (rand2 <= 0.5625):
            result2 = "8"
        elif (rand2 <= 0.625):
            result2 = "9"
        elif (rand2 <= 0.6875):
            result2 = "A"
        elif (rand2 <= 0.75):
            result2 = "B"
        elif (rand2 <= 0.8125):
            result2 = "C"
        elif (rand2 <= 0.875):
            result2 = "D"
        elif (rand2 <= 0.9375):
            result2 = "E"
        else:
            result2 = "F"
        rand3 = python_lib_Random.random()
        result3 = None
        if (rand3 <= 0.0625):
            result3 = "0"
        elif (rand3 <= 0.125):
            result3 = "1"
        elif (rand3 <= 0.1875):
            result3 = "2"
        elif (rand3 <= 0.25):
            result3 = "3"
        elif (rand3 <= 0.3125):
            result3 = "4"
        elif (rand3 <= 0.375):
            result3 = "5"
        elif (rand3 <= 0.4375):
            result3 = "6"
        elif (rand3 <= 0.5):
            result3 = "7"
        elif (rand3 <= 0.5625):
            result3 = "8"
        elif (rand3 <= 0.625):
            result3 = "9"
        elif (rand3 <= 0.6875):
            result3 = "A"
        elif (rand3 <= 0.75):
            result3 = "B"
        elif (rand3 <= 0.8125):
            result3 = "C"
        elif (rand3 <= 0.875):
            result3 = "D"
        elif (rand3 <= 0.9375):
            result3 = "E"
        else:
            result3 = "F"
        rand4 = python_lib_Random.random()
        result4 = None
        if (rand4 <= 0.0625):
            result4 = "0"
        elif (rand4 <= 0.125):
            result4 = "1"
        elif (rand4 <= 0.1875):
            result4 = "2"
        elif (rand4 <= 0.25):
            result4 = "3"
        elif (rand4 <= 0.3125):
            result4 = "4"
        elif (rand4 <= 0.375):
            result4 = "5"
        elif (rand4 <= 0.4375):
            result4 = "6"
        elif (rand4 <= 0.5):
            result4 = "7"
        elif (rand4 <= 0.5625):
            result4 = "8"
        elif (rand4 <= 0.625):
            result4 = "9"
        elif (rand4 <= 0.6875):
            result4 = "A"
        elif (rand4 <= 0.75):
            result4 = "B"
        elif (rand4 <= 0.8125):
            result4 = "C"
        elif (rand4 <= 0.875):
            result4 = "D"
        elif (rand4 <= 0.9375):
            result4 = "E"
        else:
            result4 = "F"
        rand5 = python_lib_Random.random()
        result5 = None
        if (rand5 <= 0.0625):
            result5 = "0"
        elif (rand5 <= 0.125):
            result5 = "1"
        elif (rand5 <= 0.1875):
            result5 = "2"
        elif (rand5 <= 0.25):
            result5 = "3"
        elif (rand5 <= 0.3125):
            result5 = "4"
        elif (rand5 <= 0.375):
            result5 = "5"
        elif (rand5 <= 0.4375):
            result5 = "6"
        elif (rand5 <= 0.5):
            result5 = "7"
        elif (rand5 <= 0.5625):
            result5 = "8"
        elif (rand5 <= 0.625):
            result5 = "9"
        elif (rand5 <= 0.6875):
            result5 = "A"
        elif (rand5 <= 0.75):
            result5 = "B"
        elif (rand5 <= 0.8125):
            result5 = "C"
        elif (rand5 <= 0.875):
            result5 = "D"
        elif (rand5 <= 0.9375):
            result5 = "E"
        else:
            result5 = "F"
        return (((((("#" + ("null" if result is None else result)) + ("null" if result1 is None else result1)) + ("null" if result2 is None else result2)) + ("null" if result3 is None else result3)) + ("null" if result4 is None else result4)) + ("null" if result5 is None else result5))

    def colorfyFFR(self,n,s):
        l = List()
        l.add(util_Pair(s,1))
        n.valid = False
        n.pie = l
        n.isProcessed = True
        _g_head = self.links.h
        while (_g_head is not None):
            val = _g_head.item
            _g_head = _g_head.next
            link = val
            if (link.n1 == n):
                link.strokeColor = s
                if (not link.n2.isProcessed):
                    self.colorfyFFR(link.n2,s)
            if (link.n2 == n):
                link.strokeColor = s
                if (not link.n1.isProcessed):
                    self.colorfyFFR(link.n1,s)

    def colorNetwork(self):
        _g_head = self.nodes.h
        while (_g_head is not None):
            val = _g_head.item
            _g_head = _g_head.next
            node = val
            node.isProcessed = False
        _g_head1 = self.nodes.h
        while (_g_head1 is not None):
            val1 = _g_head1.item
            _g_head1 = _g_head1.next
            node1 = val1
            if node1.isProcessed:
                continue
            if (node1.node.names.length == 0):
                l = List()
                l.add(util_Pair("grey",1))
                node1.valid = False
                node1.pie = l
                continue
            rand = python_lib_Random.random()
            result = None
            if (rand <= 0.0625):
                result = "0"
            elif (rand <= 0.125):
                result = "1"
            elif (rand <= 0.1875):
                result = "2"
            elif (rand <= 0.25):
                result = "3"
            elif (rand <= 0.3125):
                result = "4"
            elif (rand <= 0.375):
                result = "5"
            elif (rand <= 0.4375):
                result = "6"
            elif (rand <= 0.5):
                result = "7"
            elif (rand <= 0.5625):
                result = "8"
            elif (rand <= 0.625):
                result = "9"
            elif (rand <= 0.6875):
                result = "A"
            elif (rand <= 0.75):
                result = "B"
            elif (rand <= 0.8125):
                result = "C"
            elif (rand <= 0.875):
                result = "D"
            elif (rand <= 0.9375):
                result = "E"
            else:
                result = "F"
            rand1 = python_lib_Random.random()
            result1 = None
            if (rand1 <= 0.0625):
                result1 = "0"
            elif (rand1 <= 0.125):
                result1 = "1"
            elif (rand1 <= 0.1875):
                result1 = "2"
            elif (rand1 <= 0.25):
                result1 = "3"
            elif (rand1 <= 0.3125):
                result1 = "4"
            elif (rand1 <= 0.375):
                result1 = "5"
            elif (rand1 <= 0.4375):
                result1 = "6"
            elif (rand1 <= 0.5):
                result1 = "7"
            elif (rand1 <= 0.5625):
                result1 = "8"
            elif (rand1 <= 0.625):
                result1 = "9"
            elif (rand1 <= 0.6875):
                result1 = "A"
            elif (rand1 <= 0.75):
                result1 = "B"
            elif (rand1 <= 0.8125):
                result1 = "C"
            elif (rand1 <= 0.875):
                result1 = "D"
            elif (rand1 <= 0.9375):
                result1 = "E"
            else:
                result1 = "F"
            rand2 = python_lib_Random.random()
            result2 = None
            if (rand2 <= 0.0625):
                result2 = "0"
            elif (rand2 <= 0.125):
                result2 = "1"
            elif (rand2 <= 0.1875):
                result2 = "2"
            elif (rand2 <= 0.25):
                result2 = "3"
            elif (rand2 <= 0.3125):
                result2 = "4"
            elif (rand2 <= 0.375):
                result2 = "5"
            elif (rand2 <= 0.4375):
                result2 = "6"
            elif (rand2 <= 0.5):
                result2 = "7"
            elif (rand2 <= 0.5625):
                result2 = "8"
            elif (rand2 <= 0.625):
                result2 = "9"
            elif (rand2 <= 0.6875):
                result2 = "A"
            elif (rand2 <= 0.75):
                result2 = "B"
            elif (rand2 <= 0.8125):
                result2 = "C"
            elif (rand2 <= 0.875):
                result2 = "D"
            elif (rand2 <= 0.9375):
                result2 = "E"
            else:
                result2 = "F"
            rand3 = python_lib_Random.random()
            result3 = None
            if (rand3 <= 0.0625):
                result3 = "0"
            elif (rand3 <= 0.125):
                result3 = "1"
            elif (rand3 <= 0.1875):
                result3 = "2"
            elif (rand3 <= 0.25):
                result3 = "3"
            elif (rand3 <= 0.3125):
                result3 = "4"
            elif (rand3 <= 0.375):
                result3 = "5"
            elif (rand3 <= 0.4375):
                result3 = "6"
            elif (rand3 <= 0.5):
                result3 = "7"
            elif (rand3 <= 0.5625):
                result3 = "8"
            elif (rand3 <= 0.625):
                result3 = "9"
            elif (rand3 <= 0.6875):
                result3 = "A"
            elif (rand3 <= 0.75):
                result3 = "B"
            elif (rand3 <= 0.8125):
                result3 = "C"
            elif (rand3 <= 0.875):
                result3 = "D"
            elif (rand3 <= 0.9375):
                result3 = "E"
            else:
                result3 = "F"
            rand4 = python_lib_Random.random()
            result4 = None
            if (rand4 <= 0.0625):
                result4 = "0"
            elif (rand4 <= 0.125):
                result4 = "1"
            elif (rand4 <= 0.1875):
                result4 = "2"
            elif (rand4 <= 0.25):
                result4 = "3"
            elif (rand4 <= 0.3125):
                result4 = "4"
            elif (rand4 <= 0.375):
                result4 = "5"
            elif (rand4 <= 0.4375):
                result4 = "6"
            elif (rand4 <= 0.5):
                result4 = "7"
            elif (rand4 <= 0.5625):
                result4 = "8"
            elif (rand4 <= 0.625):
                result4 = "9"
            elif (rand4 <= 0.6875):
                result4 = "A"
            elif (rand4 <= 0.75):
                result4 = "B"
            elif (rand4 <= 0.8125):
                result4 = "C"
            elif (rand4 <= 0.875):
                result4 = "D"
            elif (rand4 <= 0.9375):
                result4 = "E"
            else:
                result4 = "F"
            rand5 = python_lib_Random.random()
            result5 = None
            if (rand5 <= 0.0625):
                result5 = "0"
            elif (rand5 <= 0.125):
                result5 = "1"
            elif (rand5 <= 0.1875):
                result5 = "2"
            elif (rand5 <= 0.25):
                result5 = "3"
            elif (rand5 <= 0.3125):
                result5 = "4"
            elif (rand5 <= 0.375):
                result5 = "5"
            elif (rand5 <= 0.4375):
                result5 = "6"
            elif (rand5 <= 0.5):
                result5 = "7"
            elif (rand5 <= 0.5625):
                result5 = "8"
            elif (rand5 <= 0.625):
                result5 = "9"
            elif (rand5 <= 0.6875):
                result5 = "A"
            elif (rand5 <= 0.75):
                result5 = "B"
            elif (rand5 <= 0.8125):
                result5 = "C"
            elif (rand5 <= 0.875):
                result5 = "D"
            elif (rand5 <= 0.9375):
                result5 = "E"
            else:
                result5 = "F"
            self.colorfyFFR(node1,(((((("#" + ("null" if result is None else result)) + ("null" if result1 is None else result1)) + ("null" if result2 is None else result2)) + ("null" if result3 is None else result3)) + ("null" if result4 is None else result4)) + ("null" if result5 is None else result5)))

    def pieToTxt(self,pie):
        result = List()
        _g_head = pie.h
        while (_g_head is not None):
            val = _g_head.item
            _g_head = _g_head.next
            p = val
            result.add(((HxOverrides.stringOrNull(p.first) + "\x01") + Std.string(p.second)))
        return result.join("\x03")

    def saveStyle(self):
        result = List()
        n = List()
        n.add(("1" if (self.drawCircles) else "0"))
        n.add(("1" if (self.drawCons) else "0"))
        n.add(("1" if (self.drawCurves) else "0"))
        n.add(("1" if (self.drawBezierPoints) else "0"))
        n.add(("1" if (self.drawCenter) else "0"))
        n.add(("1" if (self.drawAngles) else "0"))
        result.add(n.join("\x02"))
        _g_head = self.nodes.h
        while (_g_head is not None):
            val = _g_head.item
            _g_head = _g_head.next
            node = val
            n1 = List()
            n1.add(("" + Std.string(node.xPos)))
            n1.add(("" + Std.string(node.yPos)))
            n1.add(("" + Std.string(node.radius)))
            pie = node.pie
            result1 = List()
            _g_head1 = pie.h
            while (_g_head1 is not None):
                val1 = _g_head1.item
                _g_head1 = _g_head1.next
                p = val1
                result1.add(((HxOverrides.stringOrNull(p.first) + "\x01") + Std.string(p.second)))
            n1.add(result1.join("\x03"))
            n1.add(node.strokeColor)
            n1.add(("" + Std.string(node.strokeWidth)))
            n1.add(node.dashedArray.join("|"))
            result.add(n1.join("\x02"))
        _g_head2 = self.cons.h
        while (_g_head2 is not None):
            val2 = _g_head2.item
            _g_head2 = _g_head2.next
            con = val2
            n2 = List()
            n2.add(con.strokeColor)
            n2.add(("" + Std.string(con.strokeWidth)))
            n2.add(con.dashedArray.join("|"))
            n2.add(("1" if (con.drawMutsByLine) else "0"))
            n2.add(con.drawMutsLineStrokeColor)
            n2.add(("" + Std.string(con.drawMutsLineWidth)))
            n2.add(("" + Std.string(con.drawMutsLineLen)))
            n2.add(("" + HxOverrides.stringOrNull(con.drawMutsLineDashedArray.join("|"))))
            n2.add(("1" if (con.drawMutsByText) else "0"))
            n2.add(con.drawMutsTextFont)
            n2.add(("" + Std.string(con.drawMutsTextSize)))
            n2.add(con.drawMutsTextColor)
            n2.add(("" + Std.string(con.drawMutsTextPX)))
            n2.add(("" + Std.string(con.drawMutsTextPY)))
            n2.add(("1" if (con.drawMutsByDots) else "0"))
            n2.add(("" + Std.string(con.drawMutsDotsSize)))
            n2.add(con.drawMutsDotsColor)
            n2.add(con.drawMutsDotsDashedArray.join("|"))
            result.add(n2.join("\x02"))
        _g_head3 = self.links.h
        while (_g_head3 is not None):
            val3 = _g_head3.item
            _g_head3 = _g_head3.next
            link = val3
            n3 = List()
            n3.add(("" + Std.string(link.w)))
            n3.add(link.strokeColor)
            n3.add(("" + Std.string(link.strokeWidth)))
            n3.add(link.dashedArray.join("|"))
            n3.add(("" + Std.string(link.xPos)))
            n3.add(("" + Std.string(link.yPos)))
            result.add(n3.join("\x02"))
        return result.join("\n")

    def parsePie(self,s):
        result = List()
        _g = 0
        _g1 = s.split("\x03")
        while (_g < len(_g1)):
            p = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            d = p.split("\x01")
            result.add(util_Pair((d[0] if 0 < len(d) else None),Std.parseInt((d[1] if 1 < len(d) else None))))
        return result

    def loadStyle(self,style):
        lines = List()
        _g = 0
        _g1 = style.split("\n")
        while (_g < len(_g1)):
            line = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            lines.add(line)
        _this = lines.pop()
        attrs = _this.split("\x02")
        self.drawCircles = ((attrs[0] if 0 < len(attrs) else None) == "1")
        self.drawCons = ((attrs[1] if 1 < len(attrs) else None) == "1")
        self.drawCurves = ((attrs[2] if 2 < len(attrs) else None) == "1")
        self.drawBezierPoints = ((attrs[3] if 3 < len(attrs) else None) == "1")
        self.drawCenter = ((attrs[4] if 4 < len(attrs) else None) == "1")
        self.drawAngles = ((attrs[5] if 5 < len(attrs) else None) == "1")
        _g_head = self.nodes.h
        while (_g_head is not None):
            val = _g_head.item
            _g_head = _g_head.next
            node = val
            _this1 = lines.pop()
            attrs1 = _this1.split("\x02")
            n = Std.parseFloat((attrs1[0] if 0 < len(attrs1) else None))
            node.valid = False
            node.xPos = n
            n1 = Std.parseFloat((attrs1[1] if 1 < len(attrs1) else None))
            node.valid = False
            node.yPos = n1
            n2 = Std.parseFloat((attrs1[2] if 2 < len(attrs1) else None))
            node.valid = False
            node.radius = n2
            s = (attrs1[3] if 3 < len(attrs1) else None)
            result = List()
            _g2 = 0
            _g11 = s.split("\x03")
            while (_g2 < len(_g11)):
                p = (_g11[_g2] if _g2 >= 0 and _g2 < len(_g11) else None)
                _g2 = (_g2 + 1)
                d = p.split("\x01")
                result.add(util_Pair((d[0] if 0 < len(d) else None),Std.parseInt((d[1] if 1 < len(d) else None))))
            node.valid = False
            node.pie = result
            node.valid = False
            node.strokeColor = (attrs1[4] if 4 < len(attrs1) else None)
            n3 = Std.parseFloat((attrs1[5] if 5 < len(attrs1) else None))
            node.valid = False
            node.strokeWidth = n3
            l = List()
            _g3 = 0
            _this2 = (attrs1[6] if 6 < len(attrs1) else None)
            _g12 = _this2.split("|")
            while (_g3 < len(_g12)):
                f = (_g12[_g3] if _g3 >= 0 and _g3 < len(_g12) else None)
                _g3 = (_g3 + 1)
                l.add(Std.parseFloat(f))
            node.valid = False
            node.dashedArray = l
        _g_head1 = self.cons.h
        while (_g_head1 is not None):
            val1 = _g_head1.item
            _g_head1 = _g_head1.next
            con = val1
            _this3 = lines.pop()
            attrs2 = _this3.split("\x02")
            con.strokeColor = (attrs2[0] if 0 < len(attrs2) else None)
            con.strokeWidth = Std.parseFloat((attrs2[1] if 1 < len(attrs2) else None))
            con.dashedArray = List()
            _g4 = 0
            _this4 = (attrs2[2] if 2 < len(attrs2) else None)
            _g13 = _this4.split("|")
            while (_g4 < len(_g13)):
                f1 = (_g13[_g4] if _g4 >= 0 and _g4 < len(_g13) else None)
                _g4 = (_g4 + 1)
                con.dashedArray.add(Std.parseFloat(f1))
            con.drawMutsByLine = ((attrs2[3] if 3 < len(attrs2) else None) == "1")
            con.drawMutsLineStrokeColor = (attrs2[4] if 4 < len(attrs2) else None)
            con.drawMutsLineWidth = Std.parseFloat((attrs2[5] if 5 < len(attrs2) else None))
            con.drawMutsLineLen = Std.parseFloat((attrs2[6] if 6 < len(attrs2) else None))
            con.drawMutsLineDashedArray = List()
            _g5 = 0
            _this5 = (attrs2[7] if 7 < len(attrs2) else None)
            _g14 = _this5.split("|")
            while (_g5 < len(_g14)):
                f2 = (_g14[_g5] if _g5 >= 0 and _g5 < len(_g14) else None)
                _g5 = (_g5 + 1)
                con.drawMutsLineDashedArray.add(Std.parseFloat(f2))
            con.drawMutsByText = ((attrs2[8] if 8 < len(attrs2) else None) == "1")
            con.drawMutsTextFont = (attrs2[9] if 9 < len(attrs2) else None)
            con.drawMutsTextSize = Std.parseFloat((attrs2[10] if 10 < len(attrs2) else None))
            con.drawMutsTextColor = (attrs2[11] if 11 < len(attrs2) else None)
            con.drawMutsTextPX = Std.parseFloat((attrs2[12] if 12 < len(attrs2) else None))
            con.drawMutsTextPY = Std.parseFloat((attrs2[13] if 13 < len(attrs2) else None))
            con.drawMutsByDots = ((attrs2[14] if 14 < len(attrs2) else None) == "1")
            con.drawMutsDotsSize = Std.parseFloat((attrs2[15] if 15 < len(attrs2) else None))
            con.drawMutsDotsColor = (attrs2[16] if 16 < len(attrs2) else None)
            con.drawMutsDotsDashedArray = List()
            _g6 = 0
            _this6 = (attrs2[17] if 17 < len(attrs2) else None)
            _g15 = _this6.split("|")
            while (_g6 < len(_g15)):
                f3 = (_g15[_g6] if _g6 >= 0 and _g6 < len(_g15) else None)
                _g6 = (_g6 + 1)
                con.drawMutsDotsDashedArray.add(Std.parseFloat(f3))
        _g_head2 = self.links.h
        while (_g_head2 is not None):
            val2 = _g_head2.item
            _g_head2 = _g_head2.next
            link = val2
            _this7 = lines.pop()
            attrs3 = _this7.split("\x02")
            link.w = Std.parseFloat((attrs3[0] if 0 < len(attrs3) else None))
            link.strokeColor = (attrs3[1] if 1 < len(attrs3) else None)
            link.strokeWidth = Std.parseFloat((attrs3[2] if 2 < len(attrs3) else None))
            link.dashedArray = List()
            _g7 = 0
            _this8 = (attrs3[3] if 3 < len(attrs3) else None)
            _g16 = _this8.split("|")
            while (_g7 < len(_g16)):
                f4 = (_g16[_g7] if _g7 >= 0 and _g7 < len(_g16) else None)
                _g7 = (_g7 + 1)
                link.dashedArray.add(Std.parseFloat(f4))
            link.xPos = Std.parseFloat((attrs3[4] if 4 < len(attrs3) else None))
            link.yPos = Std.parseFloat((attrs3[5] if 5 < len(attrs3) else None))

    def getSvgCode(self,ow = -1,oh = -1):
        if (ow is None):
            ow = -1
        if (oh is None):
            oh = -1
        maxX = Math.NEGATIVE_INFINITY
        maxY = Math.NEGATIVE_INFINITY
        minX = Math.POSITIVE_INFINITY
        minY = Math.POSITIVE_INFINITY
        _g_head = self.nodes.h
        while (_g_head is not None):
            val = _g_head.item
            _g_head = _g_head.next
            node = val
            b = (node.xPos + node.radius)
            if python_lib_Math.isnan(maxX):
                maxX = maxX
            elif python_lib_Math.isnan(b):
                maxX = b
            else:
                maxX = max(maxX,b)
            b1 = (node.yPos + node.radius)
            if python_lib_Math.isnan(maxY):
                maxY = maxY
            elif python_lib_Math.isnan(b1):
                maxY = b1
            else:
                maxY = max(maxY,b1)
            b2 = (node.xPos - node.radius)
            if python_lib_Math.isnan(minX):
                minX = minX
            elif python_lib_Math.isnan(b2):
                minX = b2
            else:
                minX = min(minX,b2)
            b3 = (node.yPos - node.radius)
            if python_lib_Math.isnan(minY):
                minY = minY
            elif python_lib_Math.isnan(b3):
                minY = b3
            else:
                minY = min(minY,b3)
        _g_head1 = self.links.h
        while (_g_head1 is not None):
            val1 = _g_head1.item
            _g_head1 = _g_head1.next
            link = val1
            tMax = 0
            bX = ((2 * link.xPos) - ((((link.n1.xPos + link.n2.xPos)) / 2)))
            if ((((2 * bX) - link.n1.xPos) - link.n2.xPos) != 0):
                tMax = (((bX - link.n1.xPos)) / ((((2 * bX) - link.n1.xPos) - link.n2.xPos)))
            if ((0 <= tMax) and ((tMax <= 1))):
                tMax = tMax
            else:
                tMax = 0
            x = ((((1 - tMax)) * (((((1 - tMax)) * link.n1.xPos) + ((tMax * bX))))) + ((tMax * (((((1 - tMax)) * bX) + ((tMax * link.n2.xPos)))))))
            tMax1 = 0
            bY = ((2 * link.yPos) - ((((link.n1.yPos + link.n2.yPos)) / 2)))
            if ((((2 * bY) - link.n1.yPos) - link.n2.yPos) != 0):
                tMax1 = (((bY - link.n1.yPos)) / ((((2 * bY) - link.n1.yPos) - link.n2.yPos)))
            if ((0 <= tMax1) and ((tMax1 <= 1))):
                tMax1 = tMax1
            else:
                tMax1 = 0
            y = ((((1 - tMax1)) * (((((1 - tMax1)) * link.n1.yPos) + ((tMax1 * bY))))) + ((tMax1 * (((((1 - tMax1)) * bY) + ((tMax1 * link.n2.yPos)))))))
            if python_lib_Math.isnan(maxX):
                maxX = maxX
            elif python_lib_Math.isnan(x):
                maxX = x
            else:
                maxX = max(maxX,x)
            if python_lib_Math.isnan(maxY):
                maxY = maxY
            elif python_lib_Math.isnan(y):
                maxY = y
            else:
                maxY = max(maxY,y)
            if python_lib_Math.isnan(minX):
                minX = minX
            elif python_lib_Math.isnan(x):
                minX = x
            else:
                minX = min(minX,x)
            if python_lib_Math.isnan(minY):
                minY = minY
            elif python_lib_Math.isnan(y):
                minY = y
            else:
                minY = min(minY,y)
        width = ((maxX - minX) + 30)
        height = ((maxY - minY) + 30)
        f1 = (ow / width)
        if (ow == -1):
            f1 = 1
        f2 = (oh / height)
        if (oh == -1):
            f2 = 1
        self.lastStretchFact = (f1 if (python_lib_Math.isnan(f1)) else (f2 if (python_lib_Math.isnan(f2)) else min(f1,f2)))
        ow = (width * self.lastStretchFact)
        oh = (height * self.lastStretchFact)
        result = List()
        result.add(("<svg version='1.1' baseProfile='full' width='" + Std.string(ow)))
        result.add(("' height='" + Std.string(oh)))
        result.add((((((((("' viewBox='" + Std.string(((minX - 15)))) + ",") + Std.string(((minY - 15)))) + ",") + Std.string(width)) + ",") + Std.string(height)) + "' xmlns='http://www.w3.org/2000/svg'>"))
        if self.drawCons:
            _g_head2 = self.cons.h
            while (_g_head2 is not None):
                val2 = _g_head2.item
                _g_head2 = _g_head2.next
                con = val2
                result1 = List()
                result1.add("<line x1='")
                result1.add((Std.string(con.n1.xPos) + "' y1='"))
                result1.add((Std.string(con.n1.yPos) + "' x2='"))
                result1.add((Std.string(con.n2.xPos) + "' y2='"))
                result1.add((Std.string(con.n2.yPos) + "' stroke='"))
                result1.add((HxOverrides.stringOrNull(con.strokeColor) + "' stroke-width='"))
                result1.add((Std.string(con.strokeWidth) + "' "))
                if (not con.dashedArray.isEmpty()):
                    result1.add("stroke-dasharray='")
                    result1.add(con.dashedArray.join(","))
                    result1.add("' ")
                result1.add("/>")
                if ((con.drawMutsByLine or con.drawMutsByText) or con.drawMutsByDots):
                    vX = (con.n1.xPos - con.n2.xPos)
                    vY = (con.n1.yPos - con.n2.yPos)
                    v = ((vX * vX) + ((vY * vY)))
                    vL = (Math.NaN if ((v < 0)) else python_lib_Math.sqrt(v))
                    eVX = (vX / vL)
                    eVY = (vY / vL)
                    startX = (con.n2.xPos + ((eVX * con.n2.radius)))
                    startY = (con.n2.yPos + ((eVY * con.n2.radius)))
                    endX = ((con.n2.xPos + vX) - ((eVX * con.n1.radius)))
                    endY = ((con.n2.yPos + vY) - ((eVY * con.n1.radius)))
                    vX = (((endX - startX)) / ((con.l.length + 1)))
                    vY = (((endY - startY)) / ((con.l.length + 1)))
                    iii = 0
                    _g_head3 = con.l.h
                    while (_g_head3 is not None):
                        val3 = _g_head3.item
                        _g_head3 = _g_head3.next
                        text = val3
                        iii = (iii + 1)
                        x1 = (startX + ((vX * iii)))
                        y1 = (startY + ((vY * iii)))
                        if con.drawMutsByDots:
                            result1.add("<circle cx='")
                            result1.add((Std.string(x1) + "' cy='"))
                            result1.add((Std.string(y1) + "' r='"))
                            result1.add((Std.string(con.drawMutsDotsSize) + "' fill='"))
                            result1.add(con.drawMutsDotsColor)
                            if (not con.drawMutsDotsDashedArray.isEmpty()):
                                result1.add("' stroke-dasharray='")
                                result1.add(con.drawMutsDotsDashedArray.join(","))
                                result1.add("'")
                            result1.add("/>")
                        if con.drawMutsByLine:
                            x11 = (x1 - ((eVY * con.drawMutsLineLen)))
                            y11 = (y1 + ((eVX * con.drawMutsLineLen)))
                            x2 = (x1 + ((eVY * con.drawMutsLineLen)))
                            y2 = (y1 - ((eVX * con.drawMutsLineLen)))
                            result1.add("<line x1='")
                            result1.add((Std.string(x11) + "' y1='"))
                            result1.add((Std.string(y11) + "' x2='"))
                            result1.add((Std.string(x2) + "' y2='"))
                            result1.add((Std.string(y2) + "' stroke='"))
                            result1.add((HxOverrides.stringOrNull(con.drawMutsLineStrokeColor) + "' stroke-width='"))
                            result1.add((Std.string(con.drawMutsLineWidth) + "'"))
                            if (not con.drawMutsLineDashedArray.isEmpty()):
                                result1.add(" stroke-dasharray='")
                                result1.add(con.drawMutsLineDashedArray.join(","))
                                result1.add("'")
                            result1.add("/>")
                        if con.drawMutsByText:
                            result1.add("<text x='")
                            result1.add((Std.string((x1 + con.drawMutsTextPX)) + "' y='"))
                            result1.add((Std.string(((y1 + ((con.drawMutsTextSize / 2))) + con.drawMutsTextPY)) + "' fill='"))
                            result1.add((HxOverrides.stringOrNull(con.drawMutsTextColor) + "' font-family='"))
                            result1.add((HxOverrides.stringOrNull(con.drawMutsTextFont) + "' font-size='"))
                            result1.add((Std.string(con.drawMutsTextSize) + "'"))
                            result1.add(((">" + Std.string(text)) + "</text>"))
                result.add(result1.join(""))
        if self.drawCurves:
            result.add("<g fill='none'>")
            _g_head4 = self.links.h
            while (_g_head4 is not None):
                val4 = _g_head4.item
                _g_head4 = _g_head4.next
                link1 = val4
                result2 = List()
                if ((link1.strokeColorList is None) or link1.strokeColorList.isEmpty()):
                    result2.add("<path d='M")
                    result2.add((Std.string(link1.n1.xPos) + " "))
                    result2.add((Std.string(link1.n1.yPos) + " Q"))
                    result2.add((" " + Std.string((((2 * link1.xPos) - ((((link1.n1.xPos + link1.n2.xPos)) / 2)))))))
                    result2.add((" " + Std.string((((2 * link1.yPos) - ((((link1.n1.yPos + link1.n2.yPos)) / 2)))))))
                    result2.add((" " + Std.string(link1.n2.xPos)))
                    result2.add((" " + Std.string(link1.n2.yPos)))
                    result2.add("' stroke='")
                    result2.add(link1.strokeColor)
                    result2.add("' stroke-width='")
                    result2.add((Std.string(link1.strokeWidth) + "' "))
                    if (not link1.dashedArray.isEmpty()):
                        result2.add("stroke-dasharray='")
                        result2.add(link1.dashedArray.join(","))
                        result2.add("' ")
                    result2.add("/>")
                else:
                    b00X = (-2 * ((link1.xPos - link1.n1.xPos)))
                    b00Y = (-2 * ((link1.yPos - link1.n1.yPos)))
                    b10X = (-2 * ((link1.n2.xPos - link1.xPos)))
                    b10Y = (-2 * ((link1.n2.yPos - link1.yPos)))
                    b05X = (b00X + b10X)
                    b05Y = (b00Y + b10Y)
                    v00X = b00Y
                    v00Y = -b00X
                    v1 = ((v00X * v00X) + ((v00Y * v00Y)))
                    l00 = (Math.NaN if ((v1 < 0)) else python_lib_Math.sqrt(v1))
                    v00X = (v00X / l00)
                    v00Y = (v00Y / l00)
                    v10X = b10Y
                    v10Y = -b10X
                    v2 = ((v10X * v10X) + ((v10Y * v10Y)))
                    l10 = (Math.NaN if ((v2 < 0)) else python_lib_Math.sqrt(v2))
                    v10X = (v10X / l10)
                    v10Y = (v10Y / l10)
                    v05X = b05Y
                    v05Y = -b05X
                    v3 = ((v05X * v05X) + ((v05Y * v05Y)))
                    l05 = (Math.NaN if ((v3 < 0)) else python_lib_Math.sqrt(v3))
                    v05X = (v05X / l05)
                    v05Y = (v05Y / l05)
                    sum = 0
                    _g_head5 = link1.strokeColorList.h
                    while (_g_head5 is not None):
                        val5 = _g_head5.item
                        _g_head5 = _g_head5.next
                        p = val5
                        sum = (sum + p.second)
                    dSum = 0
                    factor = (link1.strokeWidth / sum)
                    _g_head6 = link1.strokeColorList.h
                    while (_g_head6 is not None):
                        val6 = _g_head6.item
                        _g_head6 = _g_head6.next
                        p1 = val6
                        c = p1.first
                        d = p1.second
                        l = ((((((sum - d)) / 2) - dSum)) * factor)
                        dSum = (dSum + d)
                        result2.add("<path d='M")
                        result2.add((Std.string((link1.n1.xPos + ((v00X * l)))) + " "))
                        result2.add((Std.string((link1.n1.yPos + ((v00Y * l)))) + " Q"))
                        result2.add((" " + Std.string((((2 * ((link1.xPos + ((v05X * l))))) - (((((link1.n1.xPos + ((v00X * l))) + ((link1.n2.xPos + ((v10X * l)))))) / 2)))))))
                        result2.add((" " + Std.string((((2 * ((link1.yPos + ((v05Y * l))))) - (((((link1.n1.yPos + ((v00Y * l))) + ((link1.n2.yPos + ((v10Y * l)))))) / 2)))))))
                        result2.add((" " + Std.string(((link1.n2.xPos + ((v10X * l)))))))
                        result2.add((" " + Std.string(((link1.n2.yPos + ((v10Y * l)))))))
                        result2.add("' stroke='")
                        result2.add(c)
                        result2.add("' stroke-width='")
                        result2.add((Std.string((d * factor)) + "' "))
                        if (not link1.dashedArray.isEmpty()):
                            result2.add("stroke-dasharray='")
                            result2.add(link1.dashedArray.join(","))
                            result2.add("' ")
                        result2.add("/>")
                result.add(result2.join(""))
            result.add("</g>")
        if self.drawCircles:
            _g_head7 = self.nodes.h
            while (_g_head7 is not None):
                val7 = _g_head7.item
                _g_head7 = _g_head7.next
                node1 = val7
                tmp = None
                if ((not self.drawCirclesMedians) and ((node1.node.type != parsing_SEQ_TYPE.SAMPLED_SEQUENCE))):
                    tmp = ""
                elif node1.valid:
                    tmp = node1.svg
                else:
                    result3 = List()
                    def _hx_local_9(t):
                        if ((t.first is not None) and ((t.first != ""))):
                            return (t.second > 0)
                        else:
                            return False
                    node1.pie = node1.pie.filter(_hx_local_9)
                    needArcs = False
                    result3.add("<circle id='")
                    result3.add(("n" + Std.string(node1.node.id)))
                    result3.add("' ")
                    result3.add("stroke='")
                    result3.add(node1.strokeColor)
                    result3.add("' ")
                    result3.add("stroke-width='")
                    result3.add(("" + Std.string(node1.strokeWidth)))
                    result3.add("' ")
                    if (not node1.dashedArray.isEmpty()):
                        result3.add("stroke-dasharray='")
                        result3.add(node1.dashedArray.join(","))
                        result3.add("' ")
                    result3.add("cx='")
                    result3.add(("" + Std.string(node1.xPos)))
                    result3.add("' ")
                    result3.add("cy='")
                    result3.add(("" + Std.string(node1.yPos)))
                    result3.add("' ")
                    result3.add("r='")
                    result3.add(("" + Std.string(node1.radius)))
                    result3.add("' ")
                    if node1.pie.isEmpty():
                        result3.add("fill='blue'")
                    elif (node1.pie.length == 1):
                        result3.add("fill='")
                        result3.add(node1.pie.first().first)
                        result3.add("' ")
                    else:
                        needArcs = True
                    result3.add("/>")
                    if needArcs:
                        summe = 0
                        _g_head8 = node1.pie.h
                        while (_g_head8 is not None):
                            val8 = _g_head8.item
                            _g_head8 = _g_head8.next
                            p2 = val8
                            summe = (summe + p2.second)
                        cs = 0
                        _g_head9 = node1.pie.h
                        while (_g_head9 is not None):
                            val9 = _g_head9.item
                            _g_head9 = _g_head9.next
                            p3 = val9
                            color = p3.first
                            perc = (p3.second / summe)
                            v4 = (((cs / summe) * 2) * Math.PI)
                            pX1 = ((((Math.NaN if (((v4 == Math.POSITIVE_INFINITY) or ((v4 == Math.NEGATIVE_INFINITY)))) else python_lib_Math.sin(v4))) * node1.radius) + node1.xPos)
                            v5 = (((cs / summe) * 2) * Math.PI)
                            pY1 = ((-((Math.NaN if (((v5 == Math.POSITIVE_INFINITY) or ((v5 == Math.NEGATIVE_INFINITY)))) else python_lib_Math.cos(v5))) * node1.radius) + node1.yPos)
                            cs = (cs + p3.second)
                            v6 = (((cs / summe) * 2) * Math.PI)
                            pX2 = ((((Math.NaN if (((v6 == Math.POSITIVE_INFINITY) or ((v6 == Math.NEGATIVE_INFINITY)))) else python_lib_Math.sin(v6))) * node1.radius) + node1.xPos)
                            v7 = (((cs / summe) * 2) * Math.PI)
                            pY2 = ((-((Math.NaN if (((v7 == Math.POSITIVE_INFINITY) or ((v7 == Math.NEGATIVE_INFINITY)))) else python_lib_Math.cos(v7))) * node1.radius) + node1.yPos)
                            arcFlag = (0 if ((perc < 0.5)) else 1)
                            result3.add((((((((((((((((((((("<path fill='" + ("null" if color is None else color)) + "' d='M") + Std.string(node1.xPos)) + ",") + Std.string(node1.yPos)) + "L") + Std.string(pX1)) + ",") + Std.string(pY1)) + "A") + Std.string(node1.radius)) + ",") + Std.string(node1.radius)) + " 1 ") + Std.string(arcFlag)) + ",1 ") + Std.string(pX2)) + ", ") + Std.string(pY2)) + " z'/>"))
                    node1.svg = result3.join("")
                    node1.valid = True
                    tmp = node1.svg
                result.add(tmp)
        if self.drawCirclesNames:
            _g_head10 = self.nodes.h
            while (_g_head10 is not None):
                val10 = _g_head10.item
                _g_head10 = _g_head10.next
                node2 = val10
                tmp1 = None
                if (node2.node.type != parsing_SEQ_TYPE.SAMPLED_SEQUENCE):
                    tmp1 = ""
                else:
                    x3 = ((node2.xPos + node2.radius) + 5)
                    y3 = ((node2.yPos + node2.radius) + 5)
                    tmp1 = (((((("<text x='" + Std.string(x3)) + "' y='") + Std.string(y3)) + "'>") + HxOverrides.stringOrNull(node2.node.names.first())) + "</text>")
                result.add(tmp1)
        if self.drawAngles:
            _g_head11 = self.cons.h
            while (_g_head11 is not None):
                val11 = _g_head11.item
                _g_head11 = _g_head11.next
                c1 = val11
                _g_head12 = self.cons.h
                while (_g_head12 is not None):
                    val12 = _g_head12.item
                    _g_head12 = _g_head12.next
                    c2 = val12
                    if (c1.id > c2.id):
                        nA = None
                        nB = None
                        nC = None
                        if (c1.n1 == c2.n1):
                            nA = c1.n2
                            nB = c2.n2
                            nC = c1.n1
                        elif (c1.n1 == c2.n2):
                            nA = c1.n2
                            nB = c2.n1
                            nC = c1.n1
                        elif (c1.n2 == c2.n1):
                            nA = c1.n1
                            nB = c2.n2
                            nC = c1.n2
                        elif (c1.n2 == c2.n2):
                            nA = c1.n1
                            nB = c2.n1
                            nC = c1.n2
                        if (nC is not None):
                            v1X = (nA.xPos - nC.xPos)
                            v1Y = (nA.yPos - nC.yPos)
                            v2X = (nB.xPos - nC.xPos)
                            v2Y = (nB.yPos - nC.yPos)
                            v8 = ((v1X * v1X) + ((v1Y * v1Y)))
                            l1 = (Math.NaN if ((v8 < 0)) else python_lib_Math.sqrt(v8))
                            v9 = ((v2X * v2X) + ((v2Y * v2Y)))
                            l2 = (Math.NaN if ((v9 < 0)) else python_lib_Math.sqrt(v9))
                            c3 = ((v1X * v2X) + ((v1Y * v2Y)))
                            wXV = ((v1X / l1) + ((v2X / l2)))
                            wYV = ((v1Y / l1) + ((v2Y / l2)))
                            v10 = ((wXV * wXV) + ((wYV * wYV)))
                            wL = (Math.NaN if ((v10 < 0)) else python_lib_Math.sqrt(v10))
                            xx = (nC.xPos + (((wXV / wL) * ((nC.radius + 20)))))
                            yy = (nC.yPos + (((wYV / wL) * ((nC.radius + 20)))))
                            txt = HxString.substr(("" + Std.string((((Math.acos((c3 / ((l1 * l2)))) * 360) / ((2 * Math.PI)))))),0,6)
                            result.add((((((("<text x='" + Std.string(xx)) + "' y='") + Std.string(yy)) + "' text-anchor='middle'>") + ("null" if txt is None else txt)) + "</text>"))
        if self.drawBezierPoints:
            _g_head13 = self.links.h
            while (_g_head13 is not None):
                val13 = _g_head13.item
                _g_head13 = _g_head13.next
                link2 = val13
                result.add((((((((("<circle cx='" + Std.string(link2.xPos)) + "' cy='") + Std.string(link2.yPos)) + "' r='5' fill='") + HxOverrides.stringOrNull(link2.strokeColor)) + "' stroke='") + HxOverrides.stringOrNull((("black" if (link2.setByUser) else "red")))) + "' />"))
        if self.drawCenter:
            rx = 0
            _g_head14 = self.nodes.h
            while (_g_head14 is not None):
                val14 = _g_head14.item
                _g_head14 = _g_head14.next
                node3 = val14
                rx = (rx + node3.xPos)
            x4 = (rx / self.nodes.length)
            ry = 0
            _g_head15 = self.nodes.h
            while (_g_head15 is not None):
                val15 = _g_head15.item
                _g_head15 = _g_head15.next
                node4 = val15
                ry = (ry + node4.yPos)
            y4 = (ry / self.nodes.length)
            result.add((((((((("<line x1='" + Std.string(x4)) + "' y1='") + Std.string(minY)) + "' x2='") + Std.string(x4)) + "' y2='") + Std.string(maxY)) + "' stroke='green' stroke-dasharray='3 3' />"))
            result.add((((((((("<line x1='" + Std.string(minX)) + "' y1='") + Std.string(y4)) + "' x2='") + Std.string(maxX)) + "' y2='") + Std.string(y4)) + "' stroke='green' stroke-dasharray='3 3' />"))
            rx1 = 0
            _g_head16 = self.nodes.h
            while (_g_head16 is not None):
                val16 = _g_head16.item
                _g_head16 = _g_head16.next
                node5 = val16
                rx1 = (rx1 + node5.xPos)
            tmp2 = (("<circle cx='" + Std.string((rx1 / self.nodes.length))) + "' cy='")
            ry1 = 0
            _g_head17 = self.nodes.h
            while (_g_head17 is not None):
                val17 = _g_head17.item
                _g_head17 = _g_head17.next
                node6 = val17
                ry1 = (ry1 + node6.yPos)
            result.add(((("null" if tmp2 is None else tmp2) + Std.string((ry1 / self.nodes.length))) + "' r='5' fill='green' />"))
        result.add("</svg>")
        return result.join("")

    def assignLinkPos(self,overwriteUser = True):
        if (overwriteUser is None):
            overwriteUser = True
        l = List()
        _g_head = self.links.h
        while (_g_head is not None):
            val = _g_head.item
            _g_head = _g_head.next
            link = val
            if ((not overwriteUser) and link.setByUser):
                continue
            else:
                link.xPos = Math.NaN
                link.yPos = Math.NaN
                link.setByUser = False
                vX = (link.n1.xPos - link.n2.xPos)
                vY = (link.n1.yPos - link.n2.yPos)
                vrX = (-vY / 8)
                vrY = (vX / 8)
                mX = (link.n2.xPos + ((vX / 2)))
                mY = (link.n2.yPos + ((vY / 2)))
                link.x1 = (mX - vrX)
                link.y1 = (mY - vrY)
                link.x2 = (mX + vrX)
                link.y2 = (mY + vrY)
                link.e1 = 0
                link.e2 = 0
                _g_head1 = self.nodes.h
                while (_g_head1 is not None):
                    val1 = _g_head1.item
                    _g_head1 = _g_head1.next
                    node = val1
                    dX = (node.xPos - link.x1)
                    dY = (node.yPos - link.y1)
                    v = ((dX * dX) + ((dY * dY)))
                    link.e1 = (link.e1 + ((1 / ((Math.NaN if ((v < 0)) else python_lib_Math.sqrt(v))))))
                    dX1 = (node.xPos - link.x2)
                    dY1 = (node.yPos - link.y2)
                    v1 = ((dX1 * dX1) + ((dY1 * dY1)))
                    link.e2 = (link.e2 + ((1 / ((Math.NaN if ((v1 < 0)) else python_lib_Math.sqrt(v1))))))
                if (not overwriteUser):
                    _g_head2 = self.links.h
                    while (_g_head2 is not None):
                        val2 = _g_head2.item
                        _g_head2 = _g_head2.next
                        link2 = val2
                        if link2.setByUser:
                            dX2 = (link2.xPos - link.x1)
                            dY2 = (link2.yPos - link.y1)
                            v2 = ((dX2 * dX2) + ((dY2 * dY2)))
                            link.e1 = (link.e1 + ((1 / ((Math.NaN if ((v2 < 0)) else python_lib_Math.sqrt(v2))))))
                            dX3 = (link2.xPos - link.x2)
                            dY3 = (link2.yPos - link.y2)
                            v3 = ((dX3 * dX3) + ((dY3 * dY3)))
                            link.e2 = (link.e2 + ((1 / ((Math.NaN if ((v3 < 0)) else python_lib_Math.sqrt(v3))))))
                l.add(link)
        while (not l.isEmpty()):
            bestEDiff = -1.0
            bestLink = None
            _g_head3 = l.h
            while (_g_head3 is not None):
                val3 = _g_head3.item
                _g_head3 = _g_head3.next
                link1 = val3
                eDiff = Reflect.field(Math,"fabs")((link1.e1 - link1.e2))
                if ((eDiff > bestEDiff) or ((bestEDiff == -1))):
                    bestEDiff = eDiff
                    bestLink = link1
            bestLink.xPos = (bestLink.x1 if ((bestLink.e1 < bestLink.e2)) else bestLink.x2)
            bestLink.yPos = (bestLink.y1 if ((bestLink.e1 < bestLink.e2)) else bestLink.y2)
            l.remove(bestLink)
            _g_head4 = l.h
            while (_g_head4 is not None):
                val4 = _g_head4.item
                _g_head4 = _g_head4.next
                link3 = val4
                dX4 = (bestLink.xPos - link3.x1)
                dY4 = (bestLink.yPos - link3.y1)
                v4 = ((dX4 * dX4) + ((dY4 * dY4)))
                link3.e1 = (link3.e1 + ((1 / ((Math.NaN if ((v4 < 0)) else python_lib_Math.sqrt(v4))))))
                dX5 = (bestLink.xPos - link3.x2)
                dY5 = (bestLink.yPos - link3.y2)
                v5 = ((dX5 * dX5) + ((dY5 * dY5)))
                link3.e2 = (link3.e2 + ((1 / ((Math.NaN if ((v5 < 0)) else python_lib_Math.sqrt(v5))))))

    def assignRandomNodePos(self):
        _g_head = self.nodes.h
        while (_g_head is not None):
            val = _g_head.item
            _g_head = _g_head.next
            node = val
            n = ((((-1 if ((python_lib_Random.random() > 0.5)) else 1)) * 1000) * python_lib_Random.random())
            node.valid = False
            node.xPos = n
            n1 = ((((-1 if ((python_lib_Random.random() > 0.5)) else 1)) * 1000) * python_lib_Random.random())
            node.valid = False
            node.yPos = n1
        _g_head1 = self.nodes.h
        while (_g_head1 is not None):
            val1 = _g_head1.item
            _g_head1 = _g_head1.next
            node1 = val1
            needCheck = True
            while needCheck:
                needCheck = False
                _g_head2 = self.nodes.h
                while (_g_head2 is not None):
                    val2 = _g_head2.item
                    _g_head2 = _g_head2.next
                    node2 = val2
                    if (((node1.node.id > node2.node.id) and ((node1.xPos == node2.xPos))) and ((node2.yPos == node2.yPos))):
                        n2 = ((((-1 if ((python_lib_Random.random() > 0.5)) else 1)) * 1000) * python_lib_Random.random())
                        node1.valid = False
                        node1.xPos = n2
                        n3 = ((((-1 if ((python_lib_Random.random() > 0.5)) else 1)) * 1000) * python_lib_Random.random())
                        node1.valid = False
                        node1.yPos = n3
                        needCheck = True
                        break

    def checkNoNodeAtSamePoint(self):
        _g_head = self.nodes.h
        while (_g_head is not None):
            val = _g_head.item
            _g_head = _g_head.next
            node1 = val
            needCheck = True
            while needCheck:
                needCheck = False
                _g_head1 = self.nodes.h
                while (_g_head1 is not None):
                    val1 = _g_head1.item
                    _g_head1 = _g_head1.next
                    node2 = val1
                    if (((node1.node.id > node2.node.id) and ((node1.xPos == node2.xPos))) and ((node2.yPos == node2.yPos))):
                        n = ((((-1 if ((python_lib_Random.random() > 0.5)) else 1)) * 1000) * python_lib_Random.random())
                        node1.valid = False
                        node1.xPos = n
                        n1 = ((((-1 if ((python_lib_Random.random() > 0.5)) else 1)) * 1000) * python_lib_Random.random())
                        node1.valid = False
                        node1.yPos = n1
                        needCheck = True
                        break

    def calcCenterX(self):
        rx = 0
        _g_head = self.nodes.h
        while (_g_head is not None):
            val = _g_head.item
            _g_head = _g_head.next
            node = val
            rx = (rx + node.xPos)
        return (rx / self.nodes.length)

    def calcCenterY(self):
        ry = 0
        _g_head = self.nodes.h
        while (_g_head is not None):
            val = _g_head.item
            _g_head = _g_head.next
            node = val
            ry = (ry + node.yPos)
        return (ry / self.nodes.length)

    def centerPos(self):
        rx = 0
        _g_head = self.nodes.h
        while (_g_head is not None):
            val = _g_head.item
            _g_head = _g_head.next
            node = val
            rx = (rx + node.xPos)
        cx = (rx / self.nodes.length)
        ry = 0
        _g_head1 = self.nodes.h
        while (_g_head1 is not None):
            val1 = _g_head1.item
            _g_head1 = _g_head1.next
            node1 = val1
            ry = (ry + node1.yPos)
        cy = (ry / self.nodes.length)
        _g_head2 = self.nodes.h
        while (_g_head2 is not None):
            val2 = _g_head2.item
            _g_head2 = _g_head2.next
            node2 = val2
            node2.valid = False
            node2.xPos = (node2.xPos - cx)
            node2.valid = False
            node2.yPos = (node2.yPos - cy)

    def stretch(self,fact):
        rx = 0
        _g_head = self.nodes.h
        while (_g_head is not None):
            val = _g_head.item
            _g_head = _g_head.next
            node = val
            rx = (rx + node.xPos)
        cx = (rx / self.nodes.length)
        ry = 0
        _g_head1 = self.nodes.h
        while (_g_head1 is not None):
            val1 = _g_head1.item
            _g_head1 = _g_head1.next
            node1 = val1
            ry = (ry + node1.yPos)
        cy = (ry / self.nodes.length)
        _g_head2 = self.nodes.h
        while (_g_head2 is not None):
            val2 = _g_head2.item
            _g_head2 = _g_head2.next
            node2 = val2
            node2.valid = False
            node2.xPos = (node2.xPos - cx)
            node2.valid = False
            node2.yPos = (node2.yPos - cy)
        rx1 = 0
        _g_head3 = self.nodes.h
        while (_g_head3 is not None):
            val3 = _g_head3.item
            _g_head3 = _g_head3.next
            node3 = val3
            rx1 = (rx1 + node3.xPos)
        cx1 = (rx1 / self.nodes.length)
        ry1 = 0
        _g_head4 = self.nodes.h
        while (_g_head4 is not None):
            val4 = _g_head4.item
            _g_head4 = _g_head4.next
            node4 = val4
            ry1 = (ry1 + node4.yPos)
        cy1 = (ry1 / self.nodes.length)
        _g_head5 = self.nodes.h
        while (_g_head5 is not None):
            val5 = _g_head5.item
            _g_head5 = _g_head5.next
            node5 = val5
            vX = (node5.xPos - cx1)
            vY = (node5.yPos - cy1)
            vX = (vX * fact)
            vY = (vY * fact)
            node5.valid = False
            node5.xPos = (cx1 + vX)
            node5.valid = False
            node5.yPos = (cy1 + vY)

    def mult_radius(self,v):
        _g_head = self.nodes.h
        while (_g_head is not None):
            val = _g_head.item
            _g_head = _g_head.next
            node = val
            if (node.node.type == parsing_SEQ_TYPE.SAMPLED_SEQUENCE):
                node.valid = False
                node.radius = (node.radius * v)

    def mirrorX(self):
        _g_head = self.nodes.h
        while (_g_head is not None):
            val = _g_head.item
            _g_head = _g_head.next
            node = val
            vX = -node.xPos
            vY = node.yPos
            node.valid = False
            node.xPos = vX
            node.valid = False
            node.yPos = vY
        _g_head1 = self.links.h
        while (_g_head1 is not None):
            val1 = _g_head1.item
            _g_head1 = _g_head1.next
            link = val1
            vX1 = -link.xPos
            vY1 = link.yPos
            link.xPos = vX1
            link.yPos = vY1

    def mirrorY(self):
        _g_head = self.nodes.h
        while (_g_head is not None):
            val = _g_head.item
            _g_head = _g_head.next
            node = val
            vX = node.xPos
            vY = -node.yPos
            node.valid = False
            node.xPos = vX
            node.valid = False
            node.yPos = vY
        _g_head1 = self.links.h
        while (_g_head1 is not None):
            val1 = _g_head1.item
            _g_head1 = _g_head1.next
            link = val1
            vX1 = link.xPos
            vY1 = -link.yPos
            link.xPos = vX1
            link.yPos = vY1

    def rotateP90(self):
        _g_head = self.nodes.h
        while (_g_head is not None):
            val = _g_head.item
            _g_head = _g_head.next
            node = val
            vX = -node.yPos
            vY = node.xPos
            node.valid = False
            node.xPos = vX
            node.valid = False
            node.yPos = vY
        _g_head1 = self.links.h
        while (_g_head1 is not None):
            val1 = _g_head1.item
            _g_head1 = _g_head1.next
            link = val1
            vX1 = -link.yPos
            vY1 = link.xPos
            link.xPos = vX1
            link.yPos = vY1

    def rotateN90(self):
        _g_head = self.nodes.h
        while (_g_head is not None):
            val = _g_head.item
            _g_head = _g_head.next
            node = val
            vX = node.yPos
            vY = -node.xPos
            node.valid = False
            node.xPos = vX
            node.valid = False
            node.yPos = vY
        _g_head1 = self.links.h
        while (_g_head1 is not None):
            val1 = _g_head1.item
            _g_head1 = _g_head1.next
            link = val1
            vX1 = link.yPos
            vY1 = -link.xPos
            link.xPos = vX1
            link.yPos = vY1

    def rotate(self,angle):
        rx = 0
        _g_head = self.nodes.h
        while (_g_head is not None):
            val = _g_head.item
            _g_head = _g_head.next
            node = val
            rx = (rx + node.xPos)
        cx = (rx / self.nodes.length)
        ry = 0
        _g_head1 = self.nodes.h
        while (_g_head1 is not None):
            val1 = _g_head1.item
            _g_head1 = _g_head1.next
            node1 = val1
            ry = (ry + node1.yPos)
        cy = (ry / self.nodes.length)
        _g_head2 = self.nodes.h
        while (_g_head2 is not None):
            val2 = _g_head2.item
            _g_head2 = _g_head2.next
            node2 = val2
            node2.valid = False
            node2.xPos = (node2.xPos - cx)
            node2.valid = False
            node2.yPos = (node2.yPos - cy)
        cosA = (Math.NaN if (((angle == Math.POSITIVE_INFINITY) or ((angle == Math.NEGATIVE_INFINITY)))) else python_lib_Math.cos(angle))
        sinA = (Math.NaN if (((angle == Math.POSITIVE_INFINITY) or ((angle == Math.NEGATIVE_INFINITY)))) else python_lib_Math.sin(angle))
        _g_head3 = self.nodes.h
        while (_g_head3 is not None):
            val3 = _g_head3.item
            _g_head3 = _g_head3.next
            node3 = val3
            vX = ((node3.xPos * cosA) - ((node3.yPos * sinA)))
            vY = ((node3.xPos * sinA) + ((node3.yPos * cosA)))
            node3.valid = False
            node3.xPos = vX
            node3.valid = False
            node3.yPos = vY
        _g_head4 = self.links.h
        while (_g_head4 is not None):
            val4 = _g_head4.item
            _g_head4 = _g_head4.next
            link = val4
            vX1 = ((link.xPos * cosA) - ((link.yPos * sinA)))
            vY1 = ((link.xPos * sinA) + ((link.yPos * cosA)))
            link.xPos = vX1
            link.yPos = vY1
        rx1 = 0
        _g_head5 = self.nodes.h
        while (_g_head5 is not None):
            val5 = _g_head5.item
            _g_head5 = _g_head5.next
            node4 = val5
            rx1 = (rx1 + node4.xPos)
        cx1 = (rx1 / self.nodes.length)
        ry1 = 0
        _g_head6 = self.nodes.h
        while (_g_head6 is not None):
            val6 = _g_head6.item
            _g_head6 = _g_head6.next
            node5 = val6
            ry1 = (ry1 + node5.yPos)
        cy1 = (ry1 / self.nodes.length)
        _g_head7 = self.nodes.h
        while (_g_head7 is not None):
            val7 = _g_head7.item
            _g_head7 = _g_head7.next
            node6 = val7
            node6.valid = False
            node6.xPos = (node6.xPos - cx1)
            node6.valid = False
            node6.yPos = (node6.yPos - cy1)

    def fluct(self):
        return ((10 * python_lib_Random.random()) * ((1 if ((python_lib_Random.random() > 0.5)) else -1)))

    def forceDirectedMethod(self,setRandomInitial,damping,smE,kn = 1.0,ks = 0.2,kc = 5.0,steps = 1000,remVelocity = True):
        if (kn is None):
            kn = 1.0
        if (ks is None):
            ks = 0.2
        if (kc is None):
            kc = 5.0
        if (steps is None):
            steps = 1000
        if (remVelocity is None):
            remVelocity = True
        if setRandomInitial:
            _g_head = self.nodes.h
            while (_g_head is not None):
                val = _g_head.item
                _g_head = _g_head.next
                node = val
                n = ((((-1 if ((python_lib_Random.random() > 0.5)) else 1)) * 1000) * python_lib_Random.random())
                node.valid = False
                node.xPos = n
                n1 = ((((-1 if ((python_lib_Random.random() > 0.5)) else 1)) * 1000) * python_lib_Random.random())
                node.valid = False
                node.yPos = n1
            _g_head1 = self.nodes.h
            while (_g_head1 is not None):
                val1 = _g_head1.item
                _g_head1 = _g_head1.next
                node1 = val1
                needCheck = True
                while needCheck:
                    needCheck = False
                    _g_head2 = self.nodes.h
                    while (_g_head2 is not None):
                        val2 = _g_head2.item
                        _g_head2 = _g_head2.next
                        node2 = val2
                        if (((node1.node.id > node2.node.id) and ((node1.xPos == node2.xPos))) and ((node2.yPos == node2.yPos))):
                            n2 = ((((-1 if ((python_lib_Random.random() > 0.5)) else 1)) * 1000) * python_lib_Random.random())
                            node1.valid = False
                            node1.xPos = n2
                            n3 = ((((-1 if ((python_lib_Random.random() > 0.5)) else 1)) * 1000) * python_lib_Random.random())
                            node1.valid = False
                            node1.yPos = n3
                            needCheck = True
                            break
        else:
            _g_head3 = self.nodes.h
            while (_g_head3 is not None):
                val3 = _g_head3.item
                _g_head3 = _g_head3.next
                node11 = val3
                needCheck1 = True
                while needCheck1:
                    needCheck1 = False
                    _g_head4 = self.nodes.h
                    while (_g_head4 is not None):
                        val4 = _g_head4.item
                        _g_head4 = _g_head4.next
                        node21 = val4
                        if (((node11.node.id > node21.node.id) and ((node11.xPos == node21.xPos))) and ((node21.yPos == node21.yPos))):
                            n4 = ((((-1 if ((python_lib_Random.random() > 0.5)) else 1)) * 1000) * python_lib_Random.random())
                            node11.valid = False
                            node11.xPos = n4
                            n5 = ((((-1 if ((python_lib_Random.random() > 0.5)) else 1)) * 1000) * python_lib_Random.random())
                            node11.valid = False
                            node11.yPos = n5
                            needCheck1 = True
                            break
        if remVelocity:
            _g_head5 = self.nodes.h
            while (_g_head5 is not None):
                val5 = _g_head5.item
                _g_head5 = _g_head5.next
                node3 = val5
                node3.velocityX = 0
                node3.velocityY = 0
        tE = 0
        xDif = None
        yDif = None
        r = None
        stepCount = 0
        stopCritSteps = None
        while True:
            stepCount = (stepCount + 1)
            stopCritSteps = False
            tE = 0
            _g_head6 = self.nodes.h
            while (_g_head6 is not None):
                val6 = _g_head6.item
                _g_head6 = _g_head6.next
                node4 = val6
                node4.forceX = 0
                node4.forceY = 0
                _g_head7 = self.nodes.h
                while (_g_head7 is not None):
                    val7 = _g_head7.item
                    _g_head7 = _g_head7.next
                    oNode = val7
                    if (node4 != oNode):
                        xDif = (node4.xPos - oNode.xPos)
                        yDif = (node4.yPos - oNode.yPos)
                        v = ((xDif * xDif) + ((yDif * yDif)))
                        if (v < 0):
                            r = Math.NaN
                        else:
                            r = python_lib_Math.sqrt(v)
                        if (r > 1):
                            node4.forceX = (node4.forceX + (((kn * xDif) / ((r * r)))))
                            node4.forceY = (node4.forceY + (((kn * yDif) / ((r * r)))))
                        else:
                            r = (r + 0.1)
                            node4.forceX = (node4.forceX + (((kn * ((xDif + (((10 * python_lib_Random.random()) * ((1 if ((python_lib_Random.random() > 0.5)) else -1))))))) / ((r * r)))))
                            node4.forceY = (node4.forceY + (((kn * ((yDif + (((10 * python_lib_Random.random()) * ((1 if ((python_lib_Random.random() > 0.5)) else -1))))))) / ((r * r)))))
                _g_head8 = self.cons.h
                while (_g_head8 is not None):
                    val8 = _g_head8.item
                    _g_head8 = _g_head8.next
                    con = val8
                    if (con.n1 == node4):
                        xDif = (con.n2.xPos - con.n1.xPos)
                        yDif = (con.n2.yPos - con.n1.yPos)
                    elif (con.n2 == node4):
                        xDif = (con.n1.xPos - con.n2.xPos)
                        yDif = (con.n1.yPos - con.n2.yPos)
                    else:
                        continue
                    v1 = ((xDif * xDif) + ((yDif * yDif)))
                    if (v1 < 0):
                        r = Math.NaN
                    else:
                        r = python_lib_Math.sqrt(v1)
                    displacement = (r - con.expLength)
                    xDif = (xDif / r)
                    yDif = (yDif / r)
                    node4.forceX = (node4.forceX + (((ks * displacement) * xDif)))
                    node4.forceY = (node4.forceY + (((ks * displacement) * yDif)))
            _g_head9 = self.nodes.h
            while (_g_head9 is not None):
                val9 = _g_head9.item
                _g_head9 = _g_head9.next
                node5 = val9
                node5.velocityX = (((node5.velocityX + node5.forceX)) * damping)
                node5.velocityY = (((node5.velocityY + node5.forceY)) * damping)
                node5.valid = False
                node5.xPos = (node5.xPos + node5.velocityX)
                node5.valid = False
                node5.yPos = (node5.yPos + node5.velocityY)
                v2 = ((node5.velocityX * node5.velocityX) + ((node5.velocityY * node5.velocityY)))
                l = (Math.NaN if ((v2 < 0)) else python_lib_Math.sqrt(v2))
                tE = (tE + ((l * l)))
            if ((stepCount > steps) and ((steps > -1))):
                stopCritSteps = True
            if (not (((tE > smE) and (not stopCritSteps)))):
                break
        return tE

    def modifyLinks(self,f):
        _g_head = self.links.h
        while (_g_head is not None):
            val = _g_head.item
            _g_head = _g_head.next
            l = val
            l.strokeWidth = (l.strokeWidth * f)

    def modifyCons(self,f):
        _g_head = self.cons.h
        while (_g_head is not None):
            val = _g_head.item
            _g_head = _g_head.next
            c = val
            c.strokeWidth = (c.strokeWidth * f)

    def modifyNodes(self,f):
        _g_head = self.nodes.h
        while (_g_head is not None):
            val = _g_head.item
            _g_head = _g_head.next
            n = val
            n.valid = False
            n.radius = (f * n.radius)

    def resetLinkColors(self,color):
        _g_head = self.links.h
        while (_g_head is not None):
            val = _g_head.item
            _g_head = _g_head.next
            l = val
            l.strokeColor = color

    def calculateEnergy(self):
        result = 0
        _g_head = self.nodes.h
        while (_g_head is not None):
            val = _g_head.item
            _g_head = _g_head.next
            node1 = val
            _g_head1 = self.nodes.h
            while (_g_head1 is not None):
                val1 = _g_head1.item
                _g_head1 = _g_head1.next
                node2 = val1
                if (node1.node.id > node2.node.id):
                    dX = (node1.xPos - node2.xPos)
                    dY = (node1.yPos - node2.yPos)
                    v = ((dX * dX) + ((dY * dY)))
                    result = (result + ((1.0 / ((Math.NaN if ((v < 0)) else python_lib_Math.sqrt(v))))))
        _g_head2 = self.cons.h
        while (_g_head2 is not None):
            val2 = _g_head2.item
            _g_head2 = _g_head2.next
            con = val2
            expDist = con.expLength
            dX1 = (con.n1.xPos - con.n2.xPos)
            dY1 = (con.n1.yPos - con.n2.yPos)
            v1 = ((dX1 * dX1) + ((dY1 * dY1)))
            rDist = (Math.NaN if ((v1 < 0)) else python_lib_Math.sqrt(v1))
            diff = (expDist - rDist)
            result = (result + ((diff * diff)))
        return result

    @staticmethod
    def generateRandomHex():
        rand = python_lib_Random.random()
        result = None
        if (rand <= 0.0625):
            result = "0"
        elif (rand <= 0.125):
            result = "1"
        elif (rand <= 0.1875):
            result = "2"
        elif (rand <= 0.25):
            result = "3"
        elif (rand <= 0.3125):
            result = "4"
        elif (rand <= 0.375):
            result = "5"
        elif (rand <= 0.4375):
            result = "6"
        elif (rand <= 0.5):
            result = "7"
        elif (rand <= 0.5625):
            result = "8"
        elif (rand <= 0.625):
            result = "9"
        elif (rand <= 0.6875):
            result = "A"
        elif (rand <= 0.75):
            result = "B"
        elif (rand <= 0.8125):
            result = "C"
        elif (rand <= 0.875):
            result = "D"
        elif (rand <= 0.9375):
            result = "E"
        else:
            result = "F"
        return result

    @staticmethod
    def dist(x1,y1,x2,y2):
        dX = (x1 - x2)
        dY = (y1 - y2)
        v = ((dX * dX) + ((dY * dY)))
        if (v < 0):
            return Math.NaN
        else:
            return python_lib_Math.sqrt(v)

    @staticmethod
    def main():
        pass



class draw_Link:
    _hx_class_name = "draw.Link"
    __slots__ = ("n1", "n2", "w", "strokeColor", "strokeColorList", "strokeWidth", "dashedArray", "xPos", "yPos", "x1", "y1", "x2", "y2", "e1", "e2", "setByUser")
    _hx_fields = ["n1", "n2", "w", "strokeColor", "strokeColorList", "strokeWidth", "dashedArray", "xPos", "yPos", "x1", "y1", "x2", "y2", "e1", "e2", "setByUser"]
    _hx_methods = ["set_xPos", "set_yPos", "calcCurve", "calcCPoint", "getLinkSvg", "getMMX", "getMMY"]

    def __init__(self,n1,n2,w):
        self.e2 = None
        self.e1 = None
        self.y2 = None
        self.x2 = None
        self.y1 = None
        self.x1 = None
        self.yPos = None
        self.xPos = None
        self.strokeColorList = None
        self.n1 = n1
        self.n2 = n2
        self.w = w
        self.strokeColor = "blue"
        self.strokeWidth = w
        self.dashedArray = List()
        self.setByUser = False

    def set_xPos(self,n):
        self.xPos = n

    def set_yPos(self,n):
        self.yPos = n

    def calcCurve(self,a,b,c,t):
        return ((((1 - t)) * (((((1 - t)) * a) + ((t * b))))) + ((t * (((((1 - t)) * b) + ((t * c)))))))

    def calcCPoint(self,a,b,c):
        return ((2 * b) - ((((a + c)) / 2)))

    def getLinkSvg(self):
        result = List()
        if ((self.strokeColorList is None) or self.strokeColorList.isEmpty()):
            result.add("<path d='M")
            result.add((Std.string(self.n1.xPos) + " "))
            result.add((Std.string(self.n1.yPos) + " Q"))
            result.add((" " + Std.string((((2 * self.xPos) - ((((self.n1.xPos + self.n2.xPos)) / 2)))))))
            result.add((" " + Std.string((((2 * self.yPos) - ((((self.n1.yPos + self.n2.yPos)) / 2)))))))
            result.add((" " + Std.string(self.n2.xPos)))
            result.add((" " + Std.string(self.n2.yPos)))
            result.add("' stroke='")
            result.add(self.strokeColor)
            result.add("' stroke-width='")
            result.add((Std.string(self.strokeWidth) + "' "))
            if (not self.dashedArray.isEmpty()):
                result.add("stroke-dasharray='")
                result.add(self.dashedArray.join(","))
                result.add("' ")
            result.add("/>")
        else:
            b00X = (-2 * ((self.xPos - self.n1.xPos)))
            b00Y = (-2 * ((self.yPos - self.n1.yPos)))
            b10X = (-2 * ((self.n2.xPos - self.xPos)))
            b10Y = (-2 * ((self.n2.yPos - self.yPos)))
            b05X = (b00X + b10X)
            b05Y = (b00Y + b10Y)
            v00X = b00Y
            v00Y = -b00X
            v = ((v00X * v00X) + ((v00Y * v00Y)))
            l00 = (Math.NaN if ((v < 0)) else python_lib_Math.sqrt(v))
            v00X = (v00X / l00)
            v00Y = (v00Y / l00)
            v10X = b10Y
            v10Y = -b10X
            v1 = ((v10X * v10X) + ((v10Y * v10Y)))
            l10 = (Math.NaN if ((v1 < 0)) else python_lib_Math.sqrt(v1))
            v10X = (v10X / l10)
            v10Y = (v10Y / l10)
            v05X = b05Y
            v05Y = -b05X
            v2 = ((v05X * v05X) + ((v05Y * v05Y)))
            l05 = (Math.NaN if ((v2 < 0)) else python_lib_Math.sqrt(v2))
            v05X = (v05X / l05)
            v05Y = (v05Y / l05)
            sum = 0
            _g_head = self.strokeColorList.h
            while (_g_head is not None):
                val = _g_head.item
                _g_head = _g_head.next
                p = val
                sum = (sum + p.second)
            dSum = 0
            factor = (self.strokeWidth / sum)
            _g_head1 = self.strokeColorList.h
            while (_g_head1 is not None):
                val1 = _g_head1.item
                _g_head1 = _g_head1.next
                p1 = val1
                c = p1.first
                d = p1.second
                l = ((((((sum - d)) / 2) - dSum)) * factor)
                dSum = (dSum + d)
                result.add("<path d='M")
                result.add((Std.string((self.n1.xPos + ((v00X * l)))) + " "))
                result.add((Std.string((self.n1.yPos + ((v00Y * l)))) + " Q"))
                result.add((" " + Std.string((((2 * ((self.xPos + ((v05X * l))))) - (((((self.n1.xPos + ((v00X * l))) + ((self.n2.xPos + ((v10X * l)))))) / 2)))))))
                result.add((" " + Std.string((((2 * ((self.yPos + ((v05Y * l))))) - (((((self.n1.yPos + ((v00Y * l))) + ((self.n2.yPos + ((v10Y * l)))))) / 2)))))))
                result.add((" " + Std.string(((self.n2.xPos + ((v10X * l)))))))
                result.add((" " + Std.string(((self.n2.yPos + ((v10Y * l)))))))
                result.add("' stroke='")
                result.add(c)
                result.add("' stroke-width='")
                result.add((Std.string((d * factor)) + "' "))
                if (not self.dashedArray.isEmpty()):
                    result.add("stroke-dasharray='")
                    result.add(self.dashedArray.join(","))
                    result.add("' ")
                result.add("/>")
        return result.join("")

    def getMMX(self):
        tMax = 0
        bX = ((2 * self.xPos) - ((((self.n1.xPos + self.n2.xPos)) / 2)))
        if ((((2 * bX) - self.n1.xPos) - self.n2.xPos) != 0):
            tMax = (((bX - self.n1.xPos)) / ((((2 * bX) - self.n1.xPos) - self.n2.xPos)))
        if ((0 <= tMax) and ((tMax <= 1))):
            tMax = tMax
        else:
            tMax = 0
        return ((((1 - tMax)) * (((((1 - tMax)) * self.n1.xPos) + ((tMax * bX))))) + ((tMax * (((((1 - tMax)) * bX) + ((tMax * self.n2.xPos)))))))

    def getMMY(self):
        tMax = 0
        bY = ((2 * self.yPos) - ((((self.n1.yPos + self.n2.yPos)) / 2)))
        if ((((2 * bY) - self.n1.yPos) - self.n2.yPos) != 0):
            tMax = (((bY - self.n1.yPos)) / ((((2 * bY) - self.n1.yPos) - self.n2.yPos)))
        if ((0 <= tMax) and ((tMax <= 1))):
            tMax = tMax
        else:
            tMax = 0
        return ((((1 - tMax)) * (((((1 - tMax)) * self.n1.yPos) + ((tMax * bY))))) + ((tMax * (((((1 - tMax)) * bY) + ((tMax * self.n2.yPos)))))))


class draw_SIZE_TO_RADIUS(Enum):
    __slots__ = ()
    _hx_class_name = "draw.SIZE_TO_RADIUS"
draw_SIZE_TO_RADIUS.CONST = draw_SIZE_TO_RADIUS("CONST", 0, list())
draw_SIZE_TO_RADIUS.SQRT = draw_SIZE_TO_RADIUS("SQRT", 1, list())
draw_SIZE_TO_RADIUS.LIN = draw_SIZE_TO_RADIUS("LIN", 2, list())


class draw_NodePos:
    _hx_class_name = "draw.NodePos"
    __slots__ = ("node", "xPos", "yPos", "radius", "pie", "strokeColor", "strokeWidth", "dashedArray", "velocityX", "velocityY", "forceX", "forceY", "isProcessed", "valid", "svg")
    _hx_fields = ["node", "xPos", "yPos", "radius", "pie", "strokeColor", "strokeWidth", "dashedArray", "velocityX", "velocityY", "forceX", "forceY", "isProcessed", "valid", "svg"]
    _hx_methods = ["set_xPos", "set_yPos", "mult_radius", "set_radius", "set_pie", "set_pieByArrays", "set_color", "set_pieByLst", "set_strokeColor", "set_strokeWidth", "set_dashedArray", "getNodeSvg", "getNodeNameSvg", "minX", "maxX", "minY", "maxY", "getDivContent"]
    _hx_statics = ["areaShouldBePropTo", "set_areaShouldBePropTo"]

    def __init__(self,n):
        self.svg = None
        self.isProcessed = None
        self.forceY = None
        self.forceX = None
        self.velocityY = None
        self.velocityX = None
        self.dashedArray = None
        self.strokeWidth = None
        self.strokeColor = None
        self.radius = None
        self.yPos = None
        self.xPos = None
        self.valid = False
        self.pie = List()
        self.node = n
        if (draw_NodePos.areaShouldBePropTo == draw_SIZE_TO_RADIUS.CONST):
            self.radius = 15
        elif (draw_NodePos.areaShouldBePropTo == draw_SIZE_TO_RADIUS.SQRT):
            v = self.node.names.length
            self.radius = (3 + ((Math.NaN if ((v < 0)) else python_lib_Math.sqrt(v))))
        elif (draw_NodePos.areaShouldBePropTo == draw_SIZE_TO_RADIUS.LIN):
            self.radius = (3 + self.node.names.length)
        if (self.node.type == parsing_SEQ_TYPE.MEDIAN_VECTOR):
            self.strokeColor = "grey"
            self.strokeWidth = 1
            self.radius = 3
        else:
            self.strokeColor = "black"
            self.strokeWidth = 1
        self.dashedArray = List()

    def set_xPos(self,n):
        self.valid = False
        self.xPos = n

    def set_yPos(self,n):
        self.valid = False
        self.yPos = n

    def mult_radius(self,v):
        self.valid = False
        self.radius = (v * self.radius)

    def set_radius(self,n):
        self.valid = False
        self.radius = n

    def set_pie(self,n):
        self.valid = False
        self.pie = n

    def set_pieByArrays(self,n1,n2):
        if (len(n1) != len(n2)):
            raise _HxException("n1 and n2 differ in size!")
        l = List()
        _g1 = 0
        _g = len(n1)
        while (_g1 < _g):
            i = _g1
            _g1 = (_g1 + 1)
            l.add(util_Pair((n1[i] if i >= 0 and i < len(n1) else None),(n2[i] if i >= 0 and i < len(n2) else None)))
        self.valid = False
        self.pie = l

    def set_color(self,s):
        l = List()
        l.add(util_Pair(s,1))
        self.valid = False
        self.pie = l

    def set_pieByLst(self,l,ignoreCase,byIndNameOnly):
        l_ = List()
        _g_head = self.node.names.h
        while (_g_head is not None):
            val = _g_head.item
            _g_head = _g_head.next
            name = val
            if byIndNameOnly:
                result = name
                if (name is not None):
                    _hx_str = mj_Seq.delimiter
                    pos = name.rfind(_hx_str, 0, len(name))
                    if (pos != -1):
                        result = HxString.substr(name,0,pos)
                name = result
            colorName = None
            _g_head1 = l.h
            while (_g_head1 is not None):
                val1 = _g_head1.item
                _g_head1 = _g_head1.next
                p = val1
                if ignoreCase:
                    if (p.first.upper() == name.upper()):
                        colorName = p.second.lower()
                        break
                elif (p.first == name):
                    colorName = p.second.lower()
                    break
            if (colorName is None):
                print(str((("WARN: No colorname found/given for '" + ("null" if name is None else name)) + "'!")))
            found = False
            _g_head2 = l_.h
            while (_g_head2 is not None):
                val2 = _g_head2.item
                _g_head2 = _g_head2.next
                p1 = val2
                if (p1.first == colorName):
                    p1.second = (p1.second + 1)
                    found = True
                    break
            if (not found):
                l_.add(util_Pair(colorName,1))
        self.valid = False
        self.pie = l_

    def set_strokeColor(self,n):
        self.valid = False
        self.strokeColor = n

    def set_strokeWidth(self,n):
        self.valid = False
        self.strokeWidth = n

    def set_dashedArray(self,n):
        self.valid = False
        self.dashedArray = n

    def getNodeSvg(self,drawMeds = True):
        if (drawMeds is None):
            drawMeds = True
        if ((not drawMeds) and ((self.node.type != parsing_SEQ_TYPE.SAMPLED_SEQUENCE))):
            return ""
        if self.valid:
            return self.svg
        result = List()
        def _hx_local_0(t):
            if ((t.first is not None) and ((t.first != ""))):
                return (t.second > 0)
            else:
                return False
        self.pie = self.pie.filter(_hx_local_0)
        needArcs = False
        result.add("<circle id='")
        result.add(("n" + Std.string(self.node.id)))
        result.add("' ")
        result.add("stroke='")
        result.add(self.strokeColor)
        result.add("' ")
        result.add("stroke-width='")
        result.add(("" + Std.string(self.strokeWidth)))
        result.add("' ")
        if (not self.dashedArray.isEmpty()):
            result.add("stroke-dasharray='")
            result.add(self.dashedArray.join(","))
            result.add("' ")
        result.add("cx='")
        result.add(("" + Std.string(self.xPos)))
        result.add("' ")
        result.add("cy='")
        result.add(("" + Std.string(self.yPos)))
        result.add("' ")
        result.add("r='")
        result.add(("" + Std.string(self.radius)))
        result.add("' ")
        if self.pie.isEmpty():
            result.add("fill='blue'")
        elif (self.pie.length == 1):
            result.add("fill='")
            result.add(self.pie.first().first)
            result.add("' ")
        else:
            needArcs = True
        result.add("/>")
        if needArcs:
            summe = 0
            _g_head = self.pie.h
            while (_g_head is not None):
                val = _g_head.item
                _g_head = _g_head.next
                p = val
                summe = (summe + p.second)
            cs = 0
            _g_head1 = self.pie.h
            while (_g_head1 is not None):
                val1 = _g_head1.item
                _g_head1 = _g_head1.next
                p1 = val1
                color = p1.first
                perc = (p1.second / summe)
                v = (((cs / summe) * 2) * Math.PI)
                pX1 = ((((Math.NaN if (((v == Math.POSITIVE_INFINITY) or ((v == Math.NEGATIVE_INFINITY)))) else python_lib_Math.sin(v))) * self.radius) + self.xPos)
                v1 = (((cs / summe) * 2) * Math.PI)
                pY1 = ((-((Math.NaN if (((v1 == Math.POSITIVE_INFINITY) or ((v1 == Math.NEGATIVE_INFINITY)))) else python_lib_Math.cos(v1))) * self.radius) + self.yPos)
                cs = (cs + p1.second)
                v2 = (((cs / summe) * 2) * Math.PI)
                pX2 = ((((Math.NaN if (((v2 == Math.POSITIVE_INFINITY) or ((v2 == Math.NEGATIVE_INFINITY)))) else python_lib_Math.sin(v2))) * self.radius) + self.xPos)
                v3 = (((cs / summe) * 2) * Math.PI)
                pY2 = ((-((Math.NaN if (((v3 == Math.POSITIVE_INFINITY) or ((v3 == Math.NEGATIVE_INFINITY)))) else python_lib_Math.cos(v3))) * self.radius) + self.yPos)
                arcFlag = (0 if ((perc < 0.5)) else 1)
                result.add((((((((((((((((((((("<path fill='" + ("null" if color is None else color)) + "' d='M") + Std.string(self.xPos)) + ",") + Std.string(self.yPos)) + "L") + Std.string(pX1)) + ",") + Std.string(pY1)) + "A") + Std.string(self.radius)) + ",") + Std.string(self.radius)) + " 1 ") + Std.string(arcFlag)) + ",1 ") + Std.string(pX2)) + ", ") + Std.string(pY2)) + " z'/>"))
        self.svg = result.join("")
        self.valid = True
        return self.svg

    def getNodeNameSvg(self):
        if (self.node.type != parsing_SEQ_TYPE.SAMPLED_SEQUENCE):
            return ""
        x = ((self.xPos + self.radius) + 5)
        y = ((self.yPos + self.radius) + 5)
        return (((((("<text x='" + Std.string(x)) + "' y='") + Std.string(y)) + "'>") + HxOverrides.stringOrNull(self.node.names.first())) + "</text>")

    def minX(self):
        return (self.xPos - self.radius)

    def maxX(self):
        return (self.xPos + self.radius)

    def minY(self):
        return (self.yPos - self.radius)

    def maxY(self):
        return (self.yPos + self.radius)

    def getDivContent(self):
        result = "<table style='width:100%'>"
        result = (("null" if result is None else result) + HxOverrides.stringOrNull(((("<tr><td>Id</td><td>" + Std.string(self.node.id)) + "</td></tr>"))))
        result = (("null" if result is None else result) + HxOverrides.stringOrNull(((("<tr><td>SpId</td><td>" + Std.string(self.node.spId)) + "</td></tr>"))))
        result = (("null" if result is None else result) + HxOverrides.stringOrNull(((("<tr><td>Seq</td><td>" + HxOverrides.stringOrNull(self.node.seq)) + "</td></tr>"))))
        result = (("null" if result is None else result) + HxOverrides.stringOrNull(((("<tr><td>Names</td><td>" + HxOverrides.stringOrNull(self.node.names.join(";"))) + "</td></tr>"))))
        result = (("null" if result is None else result) + HxOverrides.stringOrNull(((("<tr><td>xPos</td><td>" + Std.string(self.xPos)) + "</td></tr>"))))
        result = (("null" if result is None else result) + HxOverrides.stringOrNull(((("<tr><td>yPos</td><td>" + Std.string(self.yPos)) + "</td></tr>"))))
        result = (("null" if result is None else result) + HxOverrides.stringOrNull(((("<tr><td>radius</td><td>" + Std.string(self.radius)) + "</td></tr>"))))
        result = (("null" if result is None else result) + "</table>")
        return result

    @staticmethod
    def set_areaShouldBePropTo(s):
        if (s == "AREA"):
            draw_NodePos.areaShouldBePropTo = draw_SIZE_TO_RADIUS.SQRT
        elif (s == "Const"):
            draw_NodePos.areaShouldBePropTo = draw_SIZE_TO_RADIUS.CONST
        elif (s == "Radius"):
            draw_NodePos.areaShouldBePropTo = draw_SIZE_TO_RADIUS.LIN
        else:
            print("Not understood!")



class haxe_io_Bytes:
    _hx_class_name = "haxe.io.Bytes"
    __slots__ = ("length", "b")
    _hx_fields = ["length", "b"]
    _hx_statics = ["ofString"]

    def __init__(self,length,b):
        self.length = length
        self.b = b

    @staticmethod
    def ofString(s):
        b = bytearray(s,"UTF-8")
        return haxe_io_Bytes(len(b),b)



class haxe_io_Input:
    _hx_class_name = "haxe.io.Input"
    __slots__ = ("bigEndian",)
    _hx_fields = ["bigEndian"]
    _hx_methods = ["set_bigEndian"]

    def set_bigEndian(self,b):
        self.bigEndian = b
        return b



class haxe_io_Eof:
    _hx_class_name = "haxe.io.Eof"
    __slots__ = ()
    _hx_methods = ["toString"]

    def __init__(self):
        pass

    def toString(self):
        return "Eof"


class haxe_io_Error(Enum):
    __slots__ = ()
    _hx_class_name = "haxe.io.Error"

    @staticmethod
    def Custom(e):
        return haxe_io_Error("Custom", 3, [e])
haxe_io_Error.Blocked = haxe_io_Error("Blocked", 0, list())
haxe_io_Error.Overflow = haxe_io_Error("Overflow", 1, list())
haxe_io_Error.OutsideBounds = haxe_io_Error("OutsideBounds", 2, list())


class haxe_io_Output:
    _hx_class_name = "haxe.io.Output"
    __slots__ = ("bigEndian",)
    _hx_fields = ["bigEndian"]
    _hx_methods = ["writeByte", "writeBytes", "set_bigEndian", "writeFullBytes", "writeString"]

    def writeByte(self,c):
        raise _HxException("Not implemented")

    def writeBytes(self,s,pos,_hx_len):
        if (((pos < 0) or ((_hx_len < 0))) or (((pos + _hx_len) > s.length))):
            raise _HxException(haxe_io_Error.OutsideBounds)
        b = s.b
        k = _hx_len
        while (k > 0):
            self.writeByte(b[pos])
            pos = (pos + 1)
            k = (k - 1)
        return _hx_len

    def set_bigEndian(self,b):
        self.bigEndian = b
        return b

    def writeFullBytes(self,s,pos,_hx_len):
        while (_hx_len > 0):
            k = self.writeBytes(s,pos,_hx_len)
            pos = (pos + k)
            _hx_len = (_hx_len - k)

    def writeString(self,s):
        b = haxe_io_Bytes.ofString(s)
        self.writeFullBytes(b,0,b.length)



class interfaces_Printer:
    _hx_class_name = "interfaces.Printer"
    __slots__ = ("countingOffset", "newline", "indent")
    _hx_fields = ["countingOffset", "newline", "indent"]
    _hx_methods = ["printString", "close"]

    def __init__(self):
        self.indent = "  "
        self.newline = "\n"
        self.countingOffset = 1


class mj_Connection:
    _hx_class_name = "mj.Connection"
    __slots__ = ("next", "connectedTo", "dist")
    _hx_fields = ["next", "connectedTo", "dist"]

    def __init__(self,conT,dist):
        self.next = None
        self.connectedTo = conT
        self.dist = dist



class mj_Link:
    _hx_class_name = "mj.Link"
    __slots__ = ("to", "names")
    _hx_fields = ["to", "names"]
    _hx_methods = ["countInd"]

    def __init__(self):
        self.names = None
        self.to = None

    def countInd(self):
        return self.names.length



class mj_Seq:
    _hx_class_name = "mj.Seq"
    __slots__ = ("next", "prev", "hashCode", "nextWithHash", "prevWithHash", "names", "indNames", "origSeq", "redSeq", "isSample", "id", "spId", "visitedId", "connectedTo", "nrConnections", "linkedTo")
    _hx_fields = ["next", "prev", "hashCode", "nextWithHash", "prevWithHash", "names", "indNames", "origSeq", "redSeq", "isSample", "id", "spId", "visitedId", "connectedTo", "nrConnections", "linkedTo"]
    _hx_methods = ["calcHashForOrig", "calcHashForRed", "addName", "hasIndIdentifier", "cmpIndIdentifiers", "reduceSequence", "constructSeq", "addConnection", "clearConnections", "addLinkTo", "addLinkBySeq"]
    _hx_statics = ["delimiter", "calcHash", "getIndIdentifier", "createSample", "createMedian"]

    def __init__(self):
        self.nrConnections = None
        self.connectedTo = None
        self.visitedId = None
        self.id = None
        self.isSample = None
        self.redSeq = None
        self.origSeq = None
        self.prevWithHash = None
        self.nextWithHash = None
        self.hashCode = None
        self.prev = None
        self.next = None
        self.names = List()
        self.indNames = List()
        self.linkedTo = List()
        self.spId = 0

    def calcHashForOrig(self):
        s = self.origSeq
        result = 7
        _g1 = 0
        _g = len(s)
        while (_g1 < _g):
            pos = _g1
            _g1 = (_g1 + 1)
            result = ((31 * result) + HxString.charCodeAt(s,pos))
        self.hashCode = result

    def calcHashForRed(self):
        s = self.redSeq
        result = 7
        _g1 = 0
        _g = len(s)
        while (_g1 < _g):
            pos = _g1
            _g1 = (_g1 + 1)
            result = ((31 * result) + HxString.charCodeAt(s,pos))
        self.hashCode = result

    def addName(self,s):
        if ((s is not None) and ((s != ""))):
            self.names.add(s)
            result = s
            if (s is not None):
                _hx_str = mj_Seq.delimiter
                pos = s.rfind(_hx_str, 0, len(s))
                if (pos != -1):
                    result = HxString.substr(s,0,pos)
            indId = result
            result1 = False
            _g_head = self.indNames.h
            while (_g_head is not None):
                val = _g_head.item
                _g_head = _g_head.next
                indName = val
                if (indName == indId):
                    result1 = True
                    break
            if (not result1):
                self.indNames.add(indId)

    def hasIndIdentifier(self,s):
        result = False
        _g_head = self.indNames.h
        while (_g_head is not None):
            val = _g_head.item
            _g_head = _g_head.next
            indName = val
            if (indName == s):
                result = True
                break
        return result

    def cmpIndIdentifiers(self,o):
        result = List()
        _g_head = o.h
        while (_g_head is not None):
            val = _g_head.item
            _g_head = _g_head.next
            e = val
            result1 = False
            _g_head1 = self.indNames.h
            while (_g_head1 is not None):
                val1 = _g_head1.item
                _g_head1 = _g_head1.next
                indName = val1
                if (indName == e):
                    result1 = True
                    break
            if result1:
                result.add(e)
        return result

    def reduceSequence(self,ipos):
        l = List()
        _g_head = ipos.h
        while (_g_head is not None):
            val = _g_head.item
            _g_head = _g_head.next
            e = val
            _this = self.origSeq
            l.add(("" if (((e < 0) or ((e >= len(_this))))) else _this[e]))
        self.redSeq = l.join("")

    def constructSeq(self,s,ipos):
        i = 0
        _g_head = ipos.h
        while (_g_head is not None):
            val = _g_head.item
            _g_head = _g_head.next
            pos = val
            _this = self.redSeq
            index = i
            i = (i + 1)
            val1 = ("" if (((index < 0) or ((index >= len(_this))))) else _this[index])
            s[pos] = val1
        b_b = python_lib_io_StringIO()
        i1 = 0
        _hx_len = len(s)
        _g1 = 0
        _g = _hx_len
        while (_g1 < _g):
            i2 = _g1
            _g1 = (_g1 + 1)
            b_b.write(Std.string(Std.string(s[i2])))
            if (i2 < ((_hx_len - 1))):
                b_b.write("")
        self.origSeq = b_b.getvalue()

    def addConnection(self,c):
        c.next = self.connectedTo
        self.connectedTo = c
        _hx_local_0 = self
        _hx_local_1 = _hx_local_0.nrConnections
        _hx_local_0.nrConnections = (_hx_local_1 + 1)
        _hx_local_1

    def clearConnections(self):
        self.nrConnections = 0
        self.connectedTo = None

    def addLinkTo(self,o,names):
        if ((names is not None) and (not names.isEmpty())):
            l = mj_Link()
            l.to = o
            l.names = names
            self.linkedTo.add(l)

    def addLinkBySeq(self,os):
        o = os.indNames
        result = List()
        _g_head = o.h
        while (_g_head is not None):
            val = _g_head.item
            _g_head = _g_head.next
            e = val
            result1 = False
            _g_head1 = self.indNames.h
            while (_g_head1 is not None):
                val1 = _g_head1.item
                _g_head1 = _g_head1.next
                indName = val1
                if (indName == e):
                    result1 = True
                    break
            if result1:
                result.add(e)
        l = result
        if ((l is not None) and (not l.isEmpty())):
            l1 = mj_Link()
            l1.to = os
            l1.names = l
            self.linkedTo.add(l1)
        if ((l is not None) and (not l.isEmpty())):
            l2 = mj_Link()
            l2.to = self
            l2.names = l
            os.linkedTo.add(l2)

    @staticmethod
    def calcHash(s):
        result = 7
        _g1 = 0
        _g = len(s)
        while (_g1 < _g):
            pos = _g1
            _g1 = (_g1 + 1)
            result = ((31 * result) + HxString.charCodeAt(s,pos))
        return result

    @staticmethod
    def getIndIdentifier(s):
        result = s
        if (s is not None):
            _hx_str = mj_Seq.delimiter
            pos = s.rfind(_hx_str, 0, len(s))
            if (pos != -1):
                result = HxString.substr(s,0,pos)
        return result

    @staticmethod
    def createSample(id,name,seq):
        result = mj_Seq()
        result.id = id
        if ((name is not None) and ((name != ""))):
            result.names.add(name)
            result1 = name
            if (name is not None):
                _hx_str = mj_Seq.delimiter
                pos = name.rfind(_hx_str, 0, len(name))
                if (pos != -1):
                    result1 = HxString.substr(name,0,pos)
            indId = result1
            result2 = False
            _g_head = result.indNames.h
            while (_g_head is not None):
                val = _g_head.item
                _g_head = _g_head.next
                indName = val
                if (indName == indId):
                    result2 = True
                    break
            if (not result2):
                result.indNames.add(indId)
        result.origSeq = seq
        s = result.origSeq
        result3 = 7
        _g1 = 0
        _g = len(s)
        while (_g1 < _g):
            pos1 = _g1
            _g1 = (_g1 + 1)
            result3 = ((31 * result3) + HxString.charCodeAt(s,pos1))
        result.hashCode = result3
        result.isSample = True
        return result

    @staticmethod
    def createMedian(id,seq):
        result = mj_Seq()
        result.id = id
        result.redSeq = seq
        s = result.redSeq
        result1 = 7
        _g1 = 0
        _g = len(s)
        while (_g1 < _g):
            pos = _g1
            _g1 = (_g1 + 1)
            result1 = ((31 * result1) + HxString.charCodeAt(s,pos))
        result.hashCode = result1
        result.isSample = False
        return result



class parsing_LstParser:
    _hx_class_name = "parsing.LstParser"
    __slots__ = ()
    _hx_statics = ["parseLst"]

    @staticmethod
    def parseLst(fileContent):
        result = List()
        lines = fileContent.split("\n")
        lineNo = 0
        _g = 0
        while (_g < len(lines)):
            line = (lines[_g] if _g >= 0 and _g < len(lines) else None)
            _g = (_g + 1)
            lineNo = (lineNo + 1)
            if (((line is None) or ((line == ""))) or (((("" if ((0 >= len(line))) else line[0])) == "#"))):
                continue
            pos = line.rfind("\t", 0, len(line))
            if (pos == -1):
                raise _HxException(("Missing tab character in line " + Std.string(lineNo)))
            name = HxString.substring(line,0,pos)
            end = len(name)
            while True:
                name1 = None
                if (end > 0):
                    cCode = HxString.charCodeAt(name,(end - 1))
                    result1 = False
                    _g1 = 0
                    _g11 = [9, 10, 11, 12, 13, 32, 133, 160, 5760, 8192, 8192, 8193, 8194, 8195, 8196, 8197, 8198, 8199, 8200, 8201, 8202, 8232, 8233, 8239, 8287, 12288, 6158, 8203, 8204, 8205, 8288, 65279]
                    while (_g1 < len(_g11)):
                        ele = (_g11[_g1] if _g1 >= 0 and _g1 < len(_g11) else None)
                        _g1 = (_g1 + 1)
                        if (ele == cCode):
                            result1 = True
                            break
                    name1 = result1
                else:
                    name1 = False
                if (not name1):
                    break
                end = (end - 1)
            s = HxString.substring(name,0,end)
            begin = 0
            sLen = len(s)
            while True:
                name2 = None
                if (begin < sLen):
                    cCode1 = HxString.charCodeAt(s,begin)
                    result2 = False
                    _g2 = 0
                    _g12 = [9, 10, 11, 12, 13, 32, 133, 160, 5760, 8192, 8192, 8193, 8194, 8195, 8196, 8197, 8198, 8199, 8200, 8201, 8202, 8232, 8233, 8239, 8287, 12288, 6158, 8203, 8204, 8205, 8288, 65279]
                    while (_g2 < len(_g12)):
                        ele1 = (_g12[_g2] if _g2 >= 0 and _g2 < len(_g12) else None)
                        _g2 = (_g2 + 1)
                        if (ele1 == cCode1):
                            result2 = True
                            break
                    name2 = result2
                else:
                    name2 = False
                if (not name2):
                    break
                begin = (begin + 1)
            name = HxString.substr(s,begin,None)
            _hx_chr = HxString.substring(line,(pos + 1),None)
            end1 = len(_hx_chr)
            while True:
                chr1 = None
                if (end1 > 0):
                    cCode2 = HxString.charCodeAt(_hx_chr,(end1 - 1))
                    result3 = False
                    _g3 = 0
                    _g13 = [9, 10, 11, 12, 13, 32, 133, 160, 5760, 8192, 8192, 8193, 8194, 8195, 8196, 8197, 8198, 8199, 8200, 8201, 8202, 8232, 8233, 8239, 8287, 12288, 6158, 8203, 8204, 8205, 8288, 65279]
                    while (_g3 < len(_g13)):
                        ele2 = (_g13[_g3] if _g3 >= 0 and _g3 < len(_g13) else None)
                        _g3 = (_g3 + 1)
                        if (ele2 == cCode2):
                            result3 = True
                            break
                    chr1 = result3
                else:
                    chr1 = False
                if (not chr1):
                    break
                end1 = (end1 - 1)
            s1 = HxString.substring(_hx_chr,0,end1)
            begin1 = 0
            sLen1 = len(s1)
            while True:
                chr2 = None
                if (begin1 < sLen1):
                    cCode3 = HxString.charCodeAt(s1,begin1)
                    result4 = False
                    _g4 = 0
                    _g14 = [9, 10, 11, 12, 13, 32, 133, 160, 5760, 8192, 8192, 8193, 8194, 8195, 8196, 8197, 8198, 8199, 8200, 8201, 8202, 8232, 8233, 8239, 8287, 12288, 6158, 8203, 8204, 8205, 8288, 65279]
                    while (_g4 < len(_g14)):
                        ele3 = (_g14[_g4] if _g4 >= 0 and _g4 < len(_g14) else None)
                        _g4 = (_g4 + 1)
                        if (ele3 == cCode3):
                            result4 = True
                            break
                    chr2 = result4
                else:
                    chr2 = False
                if (not chr2):
                    break
                begin1 = (begin1 + 1)
            _hx_chr = HxString.substr(s1,begin1,None)
            if ((((name is None) or ((name == ""))) or ((_hx_chr is None))) or ((_hx_chr == ""))):
                raise _HxException(("Error in line " + Std.string(lineNo)))
            result.add(util_Pair(name,_hx_chr))
        return result


class parsing_MJNetParser:
    _hx_class_name = "parsing.MJNetParser"
    __slots__ = ()
    _hx_statics = ["countIndents", "parseNet", "main"]

    @staticmethod
    def countIndents(s):
        result = 0
        while True:
            cCode = HxString.charCodeAt(s,result)
            result1 = False
            _g = 0
            _g1 = [9, 10, 11, 12, 13, 32, 133, 160, 5760, 8192, 8192, 8193, 8194, 8195, 8196, 8197, 8198, 8199, 8200, 8201, 8202, 8232, 8233, 8239, 8287, 12288, 6158, 8203, 8204, 8205, 8288, 65279]
            while (_g < len(_g1)):
                ele = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
                _g = (_g + 1)
                if (ele == cCode):
                    result1 = True
                    break
            if (not result1):
                break
            result = (result + 1)
        return result

    @staticmethod
    def parseNet(fileContent):
        lines = fileContent.split("\n")
        result = List()
        lineNo = 0
        currentNode = None
        readNames = False
        readCons = False
        readLinks = False
        _g = 0
        while (_g < len(lines)):
            line = (lines[_g] if _g >= 0 and _g < len(lines) else None)
            _g = (_g + 1)
            lineNo = (lineNo + 1)
            end = len(line)
            while True:
                tmp = None
                if (end > 0):
                    cCode = HxString.charCodeAt(line,(end - 1))
                    result1 = False
                    _g1 = 0
                    _g11 = [9, 10, 11, 12, 13, 32, 133, 160, 5760, 8192, 8192, 8193, 8194, 8195, 8196, 8197, 8198, 8199, 8200, 8201, 8202, 8232, 8233, 8239, 8287, 12288, 6158, 8203, 8204, 8205, 8288, 65279]
                    while (_g1 < len(_g11)):
                        ele = (_g11[_g1] if _g1 >= 0 and _g1 < len(_g11) else None)
                        _g1 = (_g1 + 1)
                        if (ele == cCode):
                            result1 = True
                            break
                    tmp = result1
                else:
                    tmp = False
                if (not tmp):
                    break
                end = (end - 1)
            s = HxString.substring(line,0,end)
            begin = 0
            sLen = len(s)
            while True:
                tmp1 = None
                if (begin < sLen):
                    cCode1 = HxString.charCodeAt(s,begin)
                    result2 = False
                    _g2 = 0
                    _g12 = [9, 10, 11, 12, 13, 32, 133, 160, 5760, 8192, 8192, 8193, 8194, 8195, 8196, 8197, 8198, 8199, 8200, 8201, 8202, 8232, 8233, 8239, 8287, 12288, 6158, 8203, 8204, 8205, 8288, 65279]
                    while (_g2 < len(_g12)):
                        ele1 = (_g12[_g2] if _g2 >= 0 and _g2 < len(_g12) else None)
                        _g2 = (_g2 + 1)
                        if (ele1 == cCode1):
                            result2 = True
                            break
                    tmp1 = result2
                else:
                    tmp1 = False
                if (not tmp1):
                    break
                begin = (begin + 1)
            line_ = HxString.substr(s,begin,None)
            if (((line_ is None) or ((line_ == ""))) or (((("" if ((0 >= len(line_))) else line_[0])) == "#"))):
                continue
            result3 = 0
            while True:
                cCode2 = HxString.charCodeAt(line,result3)
                result4 = False
                _g3 = 0
                _g13 = [9, 10, 11, 12, 13, 32, 133, 160, 5760, 8192, 8192, 8193, 8194, 8195, 8196, 8197, 8198, 8199, 8200, 8201, 8202, 8232, 8233, 8239, 8287, 12288, 6158, 8203, 8204, 8205, 8288, 65279]
                while (_g3 < len(_g13)):
                    ele2 = (_g13[_g3] if _g3 >= 0 and _g3 < len(_g13) else None)
                    _g3 = (_g3 + 1)
                    if (ele2 == cCode2):
                        result4 = True
                        break
                if (not result4):
                    break
                result3 = (result3 + 1)
            indents = result3
            if ((indents == 0) and (((line_ == "SAMPLED_SEQUENCE") or ((line_ == "MEDIAN_VECTOR"))))):
                if (currentNode is not None):
                    result.add(currentNode)
                currentNode = parsing_Node()
                currentNode.type = (parsing_SEQ_TYPE.SAMPLED_SEQUENCE if ((line_ == "SAMPLED_SEQUENCE")) else parsing_SEQ_TYPE.MEDIAN_VECTOR)
                readNames = False
                readCons = False
                readLinks = False
                continue
            if (currentNode is None):
                raise _HxException((("Expected SAMPLED_SEQUENCE or MEDIAN_VECTOR in line " + Std.string(lineNo)) + "!"))
            if ((indents == 2) and ((HxString.substr(line_,0,len("ID")) == "ID"))):
                currentNode.id = Std.parseInt(HxOverrides.arrayGet(line_.split(" "), 1))
            elif ((indents == 2) and ((HxString.substr(line_,0,len("FFR_ID")) == "FFR_ID"))):
                currentNode.spId = Std.parseInt(HxOverrides.arrayGet(line_.split(" "), 1))
            elif ((indents == 2) and ((HxString.substr(line_,0,len("SEQUENCE")) == "SEQUENCE"))):
                currentNode.seq = HxOverrides.arrayGet(line_.split(" "), 1)
            elif (not (((indents == 2) and ((HxString.substr(line_,0,len("NB_NAMES")) == "NB_NAMES"))))):
                if ((indents == 2) and ((HxString.substr(line_,0,len("NAMES")) == "NAMES"))):
                    readNames = True
                    readCons = False
                    readLinks = False
                elif ((indents == 2) and ((HxString.substr(line_,0,len("CONNECTED_TO")) == "CONNECTED_TO"))):
                    readNames = False
                    readCons = True
                    readLinks = False
                elif ((indents == 2) and ((HxString.substr(line_,0,len("LINKED_TO")) == "LINKED_TO"))):
                    readNames = False
                    readCons = False
                    readLinks = True
                elif ((indents == 4) and (((readNames or readCons) or readLinks))):
                    if readNames:
                        currentNode.names.add(line_)
                    elif readCons:
                        d = line_.split(" ")
                        l = List()
                        _g21 = 5
                        _g14 = len(d)
                        while (_g21 < _g14):
                            i = _g21
                            _g21 = (_g21 + 1)
                            l.add(Std.parseInt((d[i] if i >= 0 and i < len(d) else None)))
                        currentNode.cons.add(util_Pair(Std.parseInt((d[1] if 1 < len(d) else None)),l))
                    elif readLinks:
                        d1 = line_.split(" ")
                        currentNode.links.add(util_Pair(Std.parseInt((d1[1] if 1 < len(d1) else None)),Std.parseInt((d1[3] if 3 < len(d1) else None))))
                else:
                    raise _HxException((("Unexpected expression in line " + Std.string(lineNo)) + "!"))
        if (currentNode is not None):
            result.add(currentNode)
        return result

    @staticmethod
    def main():
        pass

class parsing_SEQ_TYPE(Enum):
    __slots__ = ()
    _hx_class_name = "parsing.SEQ_TYPE"
parsing_SEQ_TYPE.SAMPLED_SEQUENCE = parsing_SEQ_TYPE("SAMPLED_SEQUENCE", 0, list())
parsing_SEQ_TYPE.MEDIAN_VECTOR = parsing_SEQ_TYPE("MEDIAN_VECTOR", 1, list())


class parsing_Node:
    _hx_class_name = "parsing.Node"
    __slots__ = ("type", "id", "spId", "seq", "names", "cons", "links")
    _hx_fields = ["type", "id", "spId", "seq", "names", "cons", "links"]

    def __init__(self):
        self.seq = None
        self.spId = None
        self.id = None
        self.type = None
        self.names = List()
        self.cons = List()
        self.links = List()



class parsing_Parse:
    _hx_class_name = "parsing.Parse"
    __slots__ = ()
    _hx_statics = ["startsWith", "isWhitespace", "stripStringBegin", "stripStringEnd", "stripString"]

    @staticmethod
    def startsWith(t,s):
        return (HxString.substr(t,0,len(s)) == s)

    @staticmethod
    def isWhitespace(s,pos):
        cCode = HxString.charCodeAt(s,pos)
        result = False
        _g = 0
        _g1 = [9, 10, 11, 12, 13, 32, 133, 160, 5760, 8192, 8192, 8193, 8194, 8195, 8196, 8197, 8198, 8199, 8200, 8201, 8202, 8232, 8233, 8239, 8287, 12288, 6158, 8203, 8204, 8205, 8288, 65279]
        while (_g < len(_g1)):
            ele = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            if (ele == cCode):
                result = True
                break
        return result

    @staticmethod
    def stripStringBegin(s):
        begin = 0
        sLen = len(s)
        while True:
            tmp = None
            if (begin < sLen):
                cCode = HxString.charCodeAt(s,begin)
                result = False
                _g = 0
                _g1 = [9, 10, 11, 12, 13, 32, 133, 160, 5760, 8192, 8192, 8193, 8194, 8195, 8196, 8197, 8198, 8199, 8200, 8201, 8202, 8232, 8233, 8239, 8287, 12288, 6158, 8203, 8204, 8205, 8288, 65279]
                while (_g < len(_g1)):
                    ele = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
                    _g = (_g + 1)
                    if (ele == cCode):
                        result = True
                        break
                tmp = result
            else:
                tmp = False
            if (not tmp):
                break
            begin = (begin + 1)
        return HxString.substr(s,begin,None)

    @staticmethod
    def stripStringEnd(s):
        end = len(s)
        while True:
            tmp = None
            if (end > 0):
                cCode = HxString.charCodeAt(s,(end - 1))
                result = False
                _g = 0
                _g1 = [9, 10, 11, 12, 13, 32, 133, 160, 5760, 8192, 8192, 8193, 8194, 8195, 8196, 8197, 8198, 8199, 8200, 8201, 8202, 8232, 8233, 8239, 8287, 12288, 6158, 8203, 8204, 8205, 8288, 65279]
                while (_g < len(_g1)):
                    ele = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
                    _g = (_g + 1)
                    if (ele == cCode):
                        result = True
                        break
                tmp = result
            else:
                tmp = False
            if (not tmp):
                break
            end = (end - 1)
        return HxString.substring(s,0,end)

    @staticmethod
    def stripString(s):
        end = len(s)
        while True:
            tmp = None
            if (end > 0):
                cCode = HxString.charCodeAt(s,(end - 1))
                result = False
                _g = 0
                _g1 = [9, 10, 11, 12, 13, 32, 133, 160, 5760, 8192, 8192, 8193, 8194, 8195, 8196, 8197, 8198, 8199, 8200, 8201, 8202, 8232, 8233, 8239, 8287, 12288, 6158, 8203, 8204, 8205, 8288, 65279]
                while (_g < len(_g1)):
                    ele = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
                    _g = (_g + 1)
                    if (ele == cCode):
                        result = True
                        break
                tmp = result
            else:
                tmp = False
            if (not tmp):
                break
            end = (end - 1)
        s1 = HxString.substring(s,0,end)
        begin = 0
        sLen = len(s1)
        while True:
            tmp1 = None
            if (begin < sLen):
                cCode1 = HxString.charCodeAt(s1,begin)
                result1 = False
                _g2 = 0
                _g11 = [9, 10, 11, 12, 13, 32, 133, 160, 5760, 8192, 8192, 8193, 8194, 8195, 8196, 8197, 8198, 8199, 8200, 8201, 8202, 8232, 8233, 8239, 8287, 12288, 6158, 8203, 8204, 8205, 8288, 65279]
                while (_g2 < len(_g11)):
                    ele1 = (_g11[_g2] if _g2 >= 0 and _g2 < len(_g11) else None)
                    _g2 = (_g2 + 1)
                    if (ele1 == cCode1):
                        result1 = True
                        break
                tmp1 = result1
            else:
                tmp1 = False
            if (not tmp1):
                break
            begin = (begin + 1)
        return HxString.substr(s1,begin,None)


class python_Boot:
    _hx_class_name = "python.Boot"
    __slots__ = ()
    _hx_statics = ["keywords", "toString1", "fields", "simpleField", "field", "getInstanceFields", "getSuperClass", "getClassFields", "prefixLength", "unhandleKeywords"]

    @staticmethod
    def toString1(o,s):
        if (o is None):
            return "null"
        if isinstance(o,str):
            return o
        if (s is None):
            s = ""
        if (len(s) >= 5):
            return "<...>"
        if isinstance(o,bool):
            if o:
                return "true"
            else:
                return "false"
        if isinstance(o,int):
            return str(o)
        if isinstance(o,float):
            try:
                if (o == int(o)):
                    return str(Math.floor((o + 0.5)))
                else:
                    return str(o)
            except Exception as _hx_e:
                _hx_e1 = _hx_e.val if isinstance(_hx_e, _HxException) else _hx_e
                e = _hx_e1
                return str(o)
        if isinstance(o,list):
            o1 = o
            l = len(o1)
            st = "["
            s = (("null" if s is None else s) + "\t")
            _g1 = 0
            _g = l
            while (_g1 < _g):
                i = _g1
                _g1 = (_g1 + 1)
                prefix = ""
                if (i > 0):
                    prefix = ","
                st = (("null" if st is None else st) + HxOverrides.stringOrNull(((("null" if prefix is None else prefix) + HxOverrides.stringOrNull(python_Boot.toString1((o1[i] if i >= 0 and i < len(o1) else None),s))))))
            st = (("null" if st is None else st) + "]")
            return st
        try:
            if hasattr(o,"toString"):
                return o.toString()
        except Exception as _hx_e:
            _hx_e1 = _hx_e.val if isinstance(_hx_e, _HxException) else _hx_e
            pass
        if (python_lib_Inspect.isfunction(o) or python_lib_Inspect.ismethod(o)):
            return "<function>"
        if hasattr(o,"__class__"):
            if isinstance(o,_hx_AnonObject):
                toStr = None
                try:
                    fields = python_Boot.fields(o)
                    _g2 = []
                    _g11 = 0
                    while (_g11 < len(fields)):
                        f = (fields[_g11] if _g11 >= 0 and _g11 < len(fields) else None)
                        _g11 = (_g11 + 1)
                        x = ((("" + ("null" if f is None else f)) + " : ") + HxOverrides.stringOrNull(python_Boot.toString1(python_Boot.simpleField(o,f),(("null" if s is None else s) + "\t"))))
                        _g2.append(x)
                    fieldsStr = _g2
                    toStr = (("{ " + HxOverrides.stringOrNull(", ".join([x1 for x1 in fieldsStr]))) + " }")
                except Exception as _hx_e:
                    _hx_e1 = _hx_e.val if isinstance(_hx_e, _HxException) else _hx_e
                    e2 = _hx_e1
                    return "{ ... }"
                if (toStr is None):
                    return "{ ... }"
                else:
                    return toStr
            if isinstance(o,Enum):
                o2 = o
                l1 = len(o2.params)
                hasParams = (l1 > 0)
                if hasParams:
                    paramsStr = ""
                    _g12 = 0
                    _g3 = l1
                    while (_g12 < _g3):
                        i1 = _g12
                        _g12 = (_g12 + 1)
                        prefix1 = ""
                        if (i1 > 0):
                            prefix1 = ","
                        paramsStr = (("null" if paramsStr is None else paramsStr) + HxOverrides.stringOrNull(((("null" if prefix1 is None else prefix1) + HxOverrides.stringOrNull(python_Boot.toString1((o2.params[i1] if i1 >= 0 and i1 < len(o2.params) else None),s))))))
                    return (((HxOverrides.stringOrNull(o2.tag) + "(") + ("null" if paramsStr is None else paramsStr)) + ")")
                else:
                    return o2.tag
            if hasattr(o,"_hx_class_name"):
                if (o.__class__.__name__ != "type"):
                    fields1 = python_Boot.getInstanceFields(o)
                    _g4 = []
                    _g13 = 0
                    while (_g13 < len(fields1)):
                        f1 = (fields1[_g13] if _g13 >= 0 and _g13 < len(fields1) else None)
                        _g13 = (_g13 + 1)
                        x1 = ((("" + ("null" if f1 is None else f1)) + " : ") + HxOverrides.stringOrNull(python_Boot.toString1(python_Boot.simpleField(o,f1),(("null" if s is None else s) + "\t"))))
                        _g4.append(x1)
                    fieldsStr1 = _g4
                    toStr1 = (((HxOverrides.stringOrNull(o._hx_class_name) + "( ") + HxOverrides.stringOrNull(", ".join([x1 for x1 in fieldsStr1]))) + " )")
                    return toStr1
                else:
                    fields2 = python_Boot.getClassFields(o)
                    _g5 = []
                    _g14 = 0
                    while (_g14 < len(fields2)):
                        f2 = (fields2[_g14] if _g14 >= 0 and _g14 < len(fields2) else None)
                        _g14 = (_g14 + 1)
                        x2 = ((("" + ("null" if f2 is None else f2)) + " : ") + HxOverrides.stringOrNull(python_Boot.toString1(python_Boot.simpleField(o,f2),(("null" if s is None else s) + "\t"))))
                        _g5.append(x2)
                    fieldsStr2 = _g5
                    toStr2 = (((("#" + HxOverrides.stringOrNull(o._hx_class_name)) + "( ") + HxOverrides.stringOrNull(", ".join([x1 for x1 in fieldsStr2]))) + " )")
                    return toStr2
            if (o == str):
                return "#String"
            if (o == list):
                return "#Array"
            if callable(o):
                return "function"
            try:
                if hasattr(o,"__repr__"):
                    return o.__repr__()
            except Exception as _hx_e:
                _hx_e1 = _hx_e.val if isinstance(_hx_e, _HxException) else _hx_e
                pass
            if hasattr(o,"__str__"):
                return o.__str__([])
            if hasattr(o,"__name__"):
                return o.__name__
            return "???"
        else:
            return str(o)

    @staticmethod
    def fields(o):
        a = []
        if (o is not None):
            if hasattr(o,"_hx_fields"):
                fields = o._hx_fields
                return list(fields)
            if isinstance(o,_hx_AnonObject):
                d = o.__dict__
                keys = d.keys()
                handler = python_Boot.unhandleKeywords
                for k in keys:
                    a.append(handler(k))
            elif hasattr(o,"__dict__"):
                d1 = o.__dict__
                keys1 = d1.keys()
                for k in keys1:
                    a.append(k)
        return a

    @staticmethod
    def simpleField(o,field):
        if (field is None):
            return None
        field1 = (("_hx_" + field) if ((field in python_Boot.keywords)) else (("_hx_" + field) if (((((len(field) > 2) and ((ord(field[0]) == 95))) and ((ord(field[1]) == 95))) and ((ord(field[(len(field) - 1)]) != 95)))) else field))
        if hasattr(o,field1):
            return getattr(o,field1)
        else:
            return None

    @staticmethod
    def field(o,field):
        if (field is None):
            return None
        field1 = field
        _hx_local_0 = len(field1)
        if (_hx_local_0 == 10):
            if (field1 == "charCodeAt"):
                if isinstance(o,str):
                    s1 = o
                    def _hx_local_1(a11):
                        return HxString.charCodeAt(s1,a11)
                    return _hx_local_1
        elif (_hx_local_0 == 11):
            if (field1 == "lastIndexOf"):
                if isinstance(o,str):
                    s3 = o
                    def _hx_local_2(a15):
                        return HxString.lastIndexOf(s3,a15)
                    return _hx_local_2
                elif isinstance(o,list):
                    a4 = o
                    def _hx_local_3(x4):
                        return python_internal_ArrayImpl.lastIndexOf(a4,x4)
                    return _hx_local_3
            elif (field1 == "toLowerCase"):
                if isinstance(o,str):
                    s7 = o
                    def _hx_local_4():
                        return HxString.toLowerCase(s7)
                    return _hx_local_4
            elif (field1 == "toUpperCase"):
                if isinstance(o,str):
                    s9 = o
                    def _hx_local_5():
                        return HxString.toUpperCase(s9)
                    return _hx_local_5
        elif (_hx_local_0 == 9):
            if (field1 == "substring"):
                if isinstance(o,str):
                    s6 = o
                    def _hx_local_6(a19):
                        return HxString.substring(s6,a19)
                    return _hx_local_6
        elif (_hx_local_0 == 4):
            if (field1 == "copy"):
                if isinstance(o,list):
                    def _hx_local_7():
                        return list(o)
                    return _hx_local_7
            elif (field1 == "join"):
                if isinstance(o,list):
                    def _hx_local_8(sep):
                        return sep.join([python_Boot.toString1(x1,'') for x1 in o])
                    return _hx_local_8
            elif (field1 == "push"):
                if isinstance(o,list):
                    x7 = o
                    def _hx_local_9(e):
                        return python_internal_ArrayImpl.push(x7,e)
                    return _hx_local_9
            elif (field1 == "sort"):
                if isinstance(o,list):
                    x11 = o
                    def _hx_local_10(f2):
                        python_internal_ArrayImpl.sort(x11,f2)
                    return _hx_local_10
        elif (_hx_local_0 == 5):
            if (field1 == "shift"):
                if isinstance(o,list):
                    x9 = o
                    def _hx_local_11():
                        return python_internal_ArrayImpl.shift(x9)
                    return _hx_local_11
            elif (field1 == "slice"):
                if isinstance(o,list):
                    x10 = o
                    def _hx_local_12(a16):
                        return python_internal_ArrayImpl.slice(x10,a16)
                    return _hx_local_12
            elif (field1 == "split"):
                if isinstance(o,str):
                    s4 = o
                    def _hx_local_13(d):
                        return HxString.split(s4,d)
                    return _hx_local_13
        elif (_hx_local_0 == 7):
            if (field1 == "indexOf"):
                if isinstance(o,str):
                    s2 = o
                    def _hx_local_14(a13):
                        return HxString.indexOf(s2,a13)
                    return _hx_local_14
                elif isinstance(o,list):
                    a = o
                    def _hx_local_15(x1):
                        return python_internal_ArrayImpl.indexOf(a,x1)
                    return _hx_local_15
            elif (field1 == "reverse"):
                if isinstance(o,list):
                    a5 = o
                    def _hx_local_16():
                        python_internal_ArrayImpl.reverse(a5)
                    return _hx_local_16
            elif (field1 == "unshift"):
                if isinstance(o,list):
                    x14 = o
                    def _hx_local_17(e2):
                        python_internal_ArrayImpl.unshift(x14,e2)
                    return _hx_local_17
        elif (_hx_local_0 == 3):
            if (field1 == "map"):
                if isinstance(o,list):
                    x5 = o
                    def _hx_local_18(f1):
                        return python_internal_ArrayImpl.map(x5,f1)
                    return _hx_local_18
            elif (field1 == "pop"):
                if isinstance(o,list):
                    x6 = o
                    def _hx_local_19():
                        return python_internal_ArrayImpl.pop(x6)
                    return _hx_local_19
        elif (_hx_local_0 == 8):
            if (field1 == "iterator"):
                if isinstance(o,list):
                    x3 = o
                    def _hx_local_20():
                        return python_internal_ArrayImpl.iterator(x3)
                    return _hx_local_20
            elif (field1 == "toString"):
                if isinstance(o,str):
                    s8 = o
                    def _hx_local_21():
                        return HxString.toString(s8)
                    return _hx_local_21
                elif isinstance(o,list):
                    x13 = o
                    def _hx_local_22():
                        return python_internal_ArrayImpl.toString(x13)
                    return _hx_local_22
        elif (_hx_local_0 == 6):
            if (field1 == "charAt"):
                if isinstance(o,str):
                    s = o
                    def _hx_local_23(a1):
                        return HxString.charAt(s,a1)
                    return _hx_local_23
            elif (field1 == "concat"):
                if isinstance(o,list):
                    a12 = o
                    def _hx_local_24(a2):
                        return python_internal_ArrayImpl.concat(a12,a2)
                    return _hx_local_24
            elif (field1 == "filter"):
                if isinstance(o,list):
                    x = o
                    def _hx_local_25(f):
                        return python_internal_ArrayImpl.filter(x,f)
                    return _hx_local_25
            elif (field1 == "insert"):
                if isinstance(o,list):
                    a3 = o
                    def _hx_local_26(a14,x2):
                        python_internal_ArrayImpl.insert(a3,a14,x2)
                    return _hx_local_26
            elif (field1 == "length"):
                if isinstance(o,str):
                    return len(o)
                elif isinstance(o,list):
                    return len(o)
            elif (field1 == "remove"):
                if isinstance(o,list):
                    x8 = o
                    def _hx_local_27(e1):
                        return python_internal_ArrayImpl.remove(x8,e1)
                    return _hx_local_27
            elif (field1 == "splice"):
                if isinstance(o,list):
                    x12 = o
                    def _hx_local_28(a17,a21):
                        return python_internal_ArrayImpl.splice(x12,a17,a21)
                    return _hx_local_28
            elif (field1 == "substr"):
                if isinstance(o,str):
                    s5 = o
                    def _hx_local_29(a18):
                        return HxString.substr(s5,a18)
                    return _hx_local_29
        else:
            pass
        field2 = (("_hx_" + field) if ((field in python_Boot.keywords)) else (("_hx_" + field) if (((((len(field) > 2) and ((ord(field[0]) == 95))) and ((ord(field[1]) == 95))) and ((ord(field[(len(field) - 1)]) != 95)))) else field))
        if hasattr(o,field2):
            return getattr(o,field2)
        else:
            return None

    @staticmethod
    def getInstanceFields(c):
        f = (c._hx_fields if (hasattr(c,"_hx_fields")) else [])
        if hasattr(c,"_hx_methods"):
            f = (f + c._hx_methods)
        sc = python_Boot.getSuperClass(c)
        if (sc is None):
            return f
        else:
            scArr = python_Boot.getInstanceFields(sc)
            scMap = set(scArr)
            _g = 0
            while (_g < len(f)):
                f1 = (f[_g] if _g >= 0 and _g < len(f) else None)
                _g = (_g + 1)
                if (not (f1 in scMap)):
                    scArr.append(f1)
            return scArr

    @staticmethod
    def getSuperClass(c):
        if (c is None):
            return None
        try:
            if hasattr(c,"_hx_super"):
                return c._hx_super
            return None
        except Exception as _hx_e:
            _hx_e1 = _hx_e.val if isinstance(_hx_e, _HxException) else _hx_e
            pass
        return None

    @staticmethod
    def getClassFields(c):
        if hasattr(c,"_hx_statics"):
            x = c._hx_statics
            return list(x)
        else:
            return []

    @staticmethod
    def unhandleKeywords(name):
        if (HxString.substr(name,0,python_Boot.prefixLength) == "_hx_"):
            real = HxString.substr(name,python_Boot.prefixLength,None)
            if (real in python_Boot.keywords):
                return real
        return name


class python__KwArgs_KwArgs_Impl_:
    _hx_class_name = "python._KwArgs.KwArgs_Impl_"
    __slots__ = ()
    _hx_statics = ["fromT"]

    @staticmethod
    def fromT(d):
        this1 = python_Lib.anonAsDict(d)
        return this1


class python_Lib:
    _hx_class_name = "python.Lib"
    __slots__ = ()
    _hx_statics = ["print", "println", "anonToDict", "anonAsDict", "dictAsAnon"]

    @staticmethod
    def print(v):
        _hx_str = Std.string(v)
        python_lib_Sys.stdout.buffer.write(_hx_str.encode("utf-8", "strict"))
        python_lib_Sys.stdout.flush()

    @staticmethod
    def println(v):
        _hx_str = Std.string(v)
        python_lib_Sys.stdout.buffer.write((("" + ("null" if _hx_str is None else _hx_str)) + "\n").encode("utf-8", "strict"))
        python_lib_Sys.stdout.flush()

    @staticmethod
    def anonToDict(o):
        if isinstance(o,_hx_AnonObject):
            return o.__dict__.copy()
        else:
            return None

    @staticmethod
    def anonAsDict(o):
        if isinstance(o,_hx_AnonObject):
            return o.__dict__
        else:
            return None

    @staticmethod
    def dictAsAnon(d):
        return _hx_AnonObject(d)


class python_internal_ArrayImpl:
    _hx_class_name = "python.internal.ArrayImpl"
    __slots__ = ()
    _hx_statics = ["concat", "iterator", "indexOf", "lastIndexOf", "toString", "pop", "push", "unshift", "remove", "shift", "slice", "sort", "splice", "map", "filter", "insert", "reverse", "_get"]

    @staticmethod
    def concat(a1,a2):
        return (a1 + a2)

    @staticmethod
    def iterator(x):
        return python_HaxeIterator(x.__iter__())

    @staticmethod
    def indexOf(a,x,fromIndex = None):
        _hx_len = len(a)
        l = (0 if ((fromIndex is None)) else ((_hx_len + fromIndex) if ((fromIndex < 0)) else fromIndex))
        if (l < 0):
            l = 0
        _g1 = l
        _g = _hx_len
        while (_g1 < _g):
            i = _g1
            _g1 = (_g1 + 1)
            if (a[i] == x):
                return i
        return -1

    @staticmethod
    def lastIndexOf(a,x,fromIndex = None):
        _hx_len = len(a)
        l = (_hx_len if ((fromIndex is None)) else (((_hx_len + fromIndex) + 1) if ((fromIndex < 0)) else (fromIndex + 1)))
        if (l > _hx_len):
            l = _hx_len
        while True:
            l = (l - 1)
            tmp = l
            if (not ((tmp > -1))):
                break
            if (a[l] == x):
                return l
        return -1

    @staticmethod
    def toString(x):
        return (("[" + HxOverrides.stringOrNull(",".join([python_Boot.toString1(x1,'') for x1 in x]))) + "]")

    @staticmethod
    def pop(x):
        if (len(x) == 0):
            return None
        else:
            return x.pop()

    @staticmethod
    def push(x,e):
        x.append(e)
        return len(x)

    @staticmethod
    def unshift(x,e):
        x.insert(0, e)

    @staticmethod
    def remove(x,e):
        try:
            x.remove(e)
            return True
        except Exception as _hx_e:
            _hx_e1 = _hx_e.val if isinstance(_hx_e, _HxException) else _hx_e
            e1 = _hx_e1
            return False

    @staticmethod
    def shift(x):
        if (len(x) == 0):
            return None
        return x.pop(0)

    @staticmethod
    def slice(x,pos,end = None):
        return x[pos:end]

    @staticmethod
    def sort(x,f):
        x.sort(key= python_lib_Functools.cmp_to_key(f))

    @staticmethod
    def splice(x,pos,_hx_len):
        if (pos < 0):
            pos = (len(x) + pos)
        if (pos < 0):
            pos = 0
        res = x[pos:(pos + _hx_len)]
        del x[pos:(pos + _hx_len)]
        return res

    @staticmethod
    def map(x,f):
        return list(map(f,x))

    @staticmethod
    def filter(x,f):
        return list(filter(f,x))

    @staticmethod
    def insert(a,pos,x):
        a.insert(pos, x)

    @staticmethod
    def reverse(a):
        a.reverse()

    @staticmethod
    def _get(x,idx):
        if ((idx > -1) and ((idx < len(x)))):
            return x[idx]
        else:
            return None


class _HxException(Exception):
    _hx_class_name = "_HxException"
    __slots__ = ("val",)
    _hx_fields = ["val"]
    _hx_methods = []
    _hx_statics = []
    _hx_super = Exception


    def __init__(self,val):
        self.val = None
        message = str(val)
        super().__init__(message)
        self.val = val



class HxOverrides:
    _hx_class_name = "HxOverrides"
    __slots__ = ()
    _hx_statics = ["eq", "stringOrNull", "arrayGet", "mapKwArgs"]

    @staticmethod
    def eq(a,b):
        if (isinstance(a,list) or isinstance(b,list)):
            return a is b
        return (a == b)

    @staticmethod
    def stringOrNull(s):
        if (s is None):
            return "null"
        else:
            return s

    @staticmethod
    def arrayGet(a,i):
        if isinstance(a,list):
            x = a
            if ((i > -1) and ((i < len(x)))):
                return x[i]
            else:
                return None
        else:
            return a[i]

    @staticmethod
    def mapKwArgs(a,v):
        a1 = python_Lib.dictAsAnon(python_Lib.anonToDict(a))
        k = python_HaxeIterator(iter(v.keys()))
        while k.hasNext():
            k1 = k.next()
            val = v.get(k1)
            if hasattr(a1,k1):
                x = getattr(a1,k1)
                setattr(a1,val,x)
                delattr(a1,k1)
        return a1


class HxString:
    _hx_class_name = "HxString"
    __slots__ = ()
    _hx_statics = ["split", "charCodeAt", "charAt", "lastIndexOf", "toUpperCase", "toLowerCase", "indexOf", "toString", "substring", "substr"]

    @staticmethod
    def split(s,d):
        if (d == ""):
            return list(s)
        else:
            return s.split(d)

    @staticmethod
    def charCodeAt(s,index):
        if ((((s is None) or ((len(s) == 0))) or ((index < 0))) or ((index >= len(s)))):
            return None
        else:
            return ord(s[index])

    @staticmethod
    def charAt(s,index):
        if ((index < 0) or ((index >= len(s)))):
            return ""
        else:
            return s[index]

    @staticmethod
    def lastIndexOf(s,_hx_str,startIndex = None):
        if (startIndex is None):
            return s.rfind(_hx_str, 0, len(s))
        else:
            i = s.rfind(_hx_str, 0, (startIndex + 1))
            startLeft = (max(0,((startIndex + 1) - len(_hx_str))) if ((i == -1)) else (i + 1))
            check = s.find(_hx_str, startLeft, len(s))
            if ((check > i) and ((check <= startIndex))):
                return check
            else:
                return i

    @staticmethod
    def toUpperCase(s):
        return s.upper()

    @staticmethod
    def toLowerCase(s):
        return s.lower()

    @staticmethod
    def indexOf(s,_hx_str,startIndex = None):
        if (startIndex is None):
            return s.find(_hx_str)
        else:
            return s.find(_hx_str, startIndex)

    @staticmethod
    def toString(s):
        return s

    @staticmethod
    def substring(s,startIndex,endIndex = None):
        if (startIndex < 0):
            startIndex = 0
        if (endIndex is None):
            return s[startIndex:]
        else:
            if (endIndex < 0):
                endIndex = 0
            if (endIndex < startIndex):
                return s[endIndex:startIndex]
            else:
                return s[startIndex:endIndex]

    @staticmethod
    def substr(s,startIndex,_hx_len = None):
        if (_hx_len is None):
            return s[startIndex:]
        else:
            if (_hx_len == 0):
                return ""
            return s[startIndex:(startIndex + _hx_len)]


class python_io_NativeInput(haxe_io_Input):
    _hx_class_name = "python.io.NativeInput"
    __slots__ = ("stream", "wasEof")
    _hx_fields = ["stream", "wasEof"]
    _hx_methods = []
    _hx_statics = []
    _hx_super = haxe_io_Input


    def __init__(self,s):
        self.wasEof = None
        self.stream = s
        self.set_bigEndian(False)
        self.wasEof = False
        if (not self.stream.readable()):
            raise _HxException("Write-only stream")



class python_io_IInput:
    _hx_class_name = "python.io.IInput"
    __slots__ = ()
    _hx_methods = ["set_bigEndian"]


class python_io_IFileInput:
    _hx_class_name = "python.io.IFileInput"
    __slots__ = ()


class python_io_NativeOutput(haxe_io_Output):
    _hx_class_name = "python.io.NativeOutput"
    __slots__ = ("stream",)
    _hx_fields = ["stream"]
    _hx_methods = []
    _hx_statics = []
    _hx_super = haxe_io_Output


    def __init__(self,stream):
        self.stream = None
        self.set_bigEndian(False)
        self.stream = stream
        if (not stream.writable()):
            raise _HxException("Read only stream")



class python_io_IOutput:
    _hx_class_name = "python.io.IOutput"
    __slots__ = ()
    _hx_methods = ["set_bigEndian", "writeByte", "writeBytes", "writeFullBytes", "writeString"]


class python_io_IFileOutput:
    _hx_class_name = "python.io.IFileOutput"
    __slots__ = ()


class python_io_NativeTextInput(python_io_NativeInput):
    _hx_class_name = "python.io.NativeTextInput"
    __slots__ = ()
    _hx_fields = []
    _hx_methods = []
    _hx_statics = []
    _hx_super = python_io_NativeInput


    def __init__(self,stream):
        super().__init__(stream)


class python_io_FileTextInput(python_io_NativeTextInput):
    _hx_class_name = "python.io.FileTextInput"
    __slots__ = ()
    _hx_fields = []
    _hx_methods = []
    _hx_statics = []
    _hx_super = python_io_NativeTextInput


    def __init__(self,stream):
        super().__init__(stream)


class python_io_NativeTextOutput(python_io_NativeOutput):
    _hx_class_name = "python.io.NativeTextOutput"
    __slots__ = ()
    _hx_fields = []
    _hx_methods = ["writeByte"]
    _hx_statics = []
    _hx_super = python_io_NativeOutput


    def __init__(self,stream):
        super().__init__(stream)
        if (not stream.writable()):
            raise _HxException("Read only stream")

    def writeByte(self,c):
        self.stream.write("".join(map(chr,[c])))



class python_io_FileTextOutput(python_io_NativeTextOutput):
    _hx_class_name = "python.io.FileTextOutput"
    __slots__ = ()
    _hx_fields = []
    _hx_methods = []
    _hx_statics = []
    _hx_super = python_io_NativeTextOutput


    def __init__(self,stream):
        super().__init__(stream)


class python_io_IoTools:
    _hx_class_name = "python.io.IoTools"
    __slots__ = ()
    _hx_statics = ["createFileInputFromText", "createFileOutputFromText"]

    @staticmethod
    def createFileInputFromText(t):
        return sys_io_FileInput(python_io_FileTextInput(t))

    @staticmethod
    def createFileOutputFromText(t):
        return sys_io_FileOutput(python_io_FileTextOutput(t))


class sys_io_File:
    _hx_class_name = "sys.io.File"
    __slots__ = ()
    _hx_statics = ["getContent"]

    @staticmethod
    def getContent(path):
        f = python_lib_Builtins.open(path,"r",-1,"utf-8",None,"")
        content = f.read(-1)
        f.close()
        return content


class sys_io_FileInput(haxe_io_Input):
    _hx_class_name = "sys.io.FileInput"
    __slots__ = ("impl",)
    _hx_fields = ["impl"]
    _hx_methods = ["set_bigEndian"]
    _hx_statics = []
    _hx_super = haxe_io_Input


    def __init__(self,impl):
        self.impl = impl

    def set_bigEndian(self,b):
        return self.impl.set_bigEndian(b)



class sys_io_FileOutput(haxe_io_Output):
    _hx_class_name = "sys.io.FileOutput"
    __slots__ = ("impl",)
    _hx_fields = ["impl"]
    _hx_methods = ["set_bigEndian", "writeByte", "writeBytes", "writeFullBytes", "writeString"]
    _hx_statics = []
    _hx_super = haxe_io_Output


    def __init__(self,impl):
        self.impl = impl

    def set_bigEndian(self,b):
        return self.impl.set_bigEndian(b)

    def writeByte(self,c):
        self.impl.writeByte(c)

    def writeBytes(self,s,pos,_hx_len):
        return self.impl.writeBytes(s,pos,_hx_len)

    def writeFullBytes(self,s,pos,_hx_len):
        self.impl.writeFullBytes(s,pos,_hx_len)

    def writeString(self,s):
        self.impl.writeString(s)



class util_Pair:
    _hx_class_name = "util.Pair"
    __slots__ = ("first", "second")
    _hx_fields = ["first", "second"]
    _hx_methods = ["swapFirst", "swapSecond", "swap"]

    def __init__(self,u,v):
        self.second = None
        self.first = None
        self.first = u
        self.second = v

    def swapFirst(self,p):
        tmp = self.first
        self.first = p.first
        p.first = tmp

    def swapSecond(self,p):
        tmp = self.second
        self.second = p.second
        p.second = tmp

    def swap(self,p):
        self.swapFirst(p)
        self.swapSecond(p)



class util_StdOutPrinter:
    _hx_class_name = "util.StdOutPrinter"
    __slots__ = ("countingOffset", "newline", "indent")
    _hx_fields = ["countingOffset", "newline", "indent"]
    _hx_methods = ["printString", "close"]

    def __init__(self):
        self.indent = "  "
        self.newline = "\n"
        self.countingOffset = 1

    def printString(self,s):
        Sys.stdout().writeString(s)

    def close(self):
        pass


Math.NEGATIVE_INFINITY = float("-inf")
Math.POSITIVE_INFINITY = float("inf")
Math.NaN = float("nan")
Math.PI = python_lib_Math.pi

def _hx_init_Sys_environ():
    def _hx_local_0():
        Sys.environ = haxe_ds_StringMap()
        env = python_lib_Os.environ
        key = python_HaxeIterator(iter(env.keys()))
        while key.hasNext():
            key1 = key.next()
            _this = Sys.environ
            value = env.get(key1,None)
            _this.h[key1] = value
        return Sys.environ
    return _hx_local_0()
Sys.environ = _hx_init_Sys_environ()
Sys._programPath = sys_FileSystem.fullPath(python_lib_Inspect.getsourcefile(Sys))
draw_NodePos.areaShouldBePropTo = draw_SIZE_TO_RADIUS.SQRT
mj_Seq.delimiter = "_"
python_Boot.keywords = set(["and", "del", "from", "not", "with", "as", "elif", "global", "or", "yield", "assert", "else", "if", "pass", "None", "break", "except", "import", "raise", "True", "class", "exec", "in", "return", "False", "continue", "finally", "is", "try", "def", "for", "lambda", "while"])
python_Boot.prefixLength = len("_hx_")

draw_Drawer.main()