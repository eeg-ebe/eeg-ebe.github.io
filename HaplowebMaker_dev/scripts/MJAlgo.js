// Generated by Haxe 3.4.7
var $hxClasses = {},$estr = function() { return js_Boot.__string_rec(this,''); };
function $extend(from, fields) {
	function Inherit() {} Inherit.prototype = from; var proto = new Inherit();
	for (var name in fields) proto[name] = fields[name];
	if( fields.toString !== Object.prototype.toString ) proto.toString = fields.toString;
	return proto;
}
var HxOverrides = function() { };
$hxClasses["HxOverrides"] = HxOverrides;
HxOverrides.__name__ = ["HxOverrides"];
HxOverrides.dateStr = function(date) {
	var m = date.getMonth() + 1;
	var d = date.getDate();
	var h = date.getHours();
	var mi = date.getMinutes();
	var s = date.getSeconds();
	return date.getFullYear() + "-" + (m < 10 ? "0" + m : "" + m) + "-" + (d < 10 ? "0" + d : "" + d) + " " + (h < 10 ? "0" + h : "" + h) + ":" + (mi < 10 ? "0" + mi : "" + mi) + ":" + (s < 10 ? "0" + s : "" + s);
};
HxOverrides.strDate = function(s) {
	var _g = s.length;
	switch(_g) {
	case 8:
		var k = s.split(":");
		var d = new Date();
		d["setTime"](0);
		d["setUTCHours"](k[0]);
		d["setUTCMinutes"](k[1]);
		d["setUTCSeconds"](k[2]);
		return d;
	case 10:
		var k1 = s.split("-");
		return new Date(k1[0],k1[1] - 1,k1[2],0,0,0);
	case 19:
		var k2 = s.split(" ");
		var y = k2[0].split("-");
		var t = k2[1].split(":");
		return new Date(y[0],y[1] - 1,y[2],t[0],t[1],t[2]);
	default:
		throw new js__$Boot_HaxeError("Invalid date format : " + s);
	}
};
HxOverrides.cca = function(s,index) {
	var x = s.charCodeAt(index);
	if(x != x) {
		return undefined;
	}
	return x;
};
HxOverrides.substr = function(s,pos,len) {
	if(len == null) {
		len = s.length;
	} else if(len < 0) {
		if(pos == 0) {
			len = s.length + len;
		} else {
			return "";
		}
	}
	return s.substr(pos,len);
};
HxOverrides.indexOf = function(a,obj,i) {
	var len = a.length;
	if(i < 0) {
		i += len;
		if(i < 0) {
			i = 0;
		}
	}
	while(i < len) {
		if(a[i] === obj) {
			return i;
		}
		++i;
	}
	return -1;
};
HxOverrides.lastIndexOf = function(a,obj,i) {
	var len = a.length;
	if(i >= len) {
		i = len - 1;
	} else if(i < 0) {
		i += len;
	}
	while(i >= 0) {
		if(a[i] === obj) {
			return i;
		}
		--i;
	}
	return -1;
};
HxOverrides.remove = function(a,obj) {
	var i = a.indexOf(obj);
	if(i == -1) {
		return false;
	}
	a.splice(i,1);
	return true;
};
HxOverrides.iter = function(a) {
	return { cur : 0, arr : a, hasNext : function() {
		return this.cur < this.arr.length;
	}, next : function() {
		return this.arr[this.cur++];
	}};
};
var IntIterator = function(min,max) {
	this.min = min;
	this.max = max;
};
$hxClasses["IntIterator"] = IntIterator;
IntIterator.__name__ = ["IntIterator"];
IntIterator.prototype = {
	min: null
	,max: null
	,hasNext: function() {
		return this.min < this.max;
	}
	,next: function() {
		return this.min++;
	}
	,__class__: IntIterator
};
var List = function() {
	this.length = 0;
};
$hxClasses["List"] = List;
List.__name__ = ["List"];
List.prototype = {
	h: null
	,q: null
	,length: null
	,add: function(item) {
		var x = new _$List_ListNode(item,null);
		if(this.h == null) {
			this.h = x;
		} else {
			this.q.next = x;
		}
		this.q = x;
		this.length++;
	}
	,push: function(item) {
		var x = new _$List_ListNode(item,this.h);
		this.h = x;
		if(this.q == null) {
			this.q = x;
		}
		this.length++;
	}
	,first: function() {
		if(this.h == null) {
			return null;
		} else {
			return this.h.item;
		}
	}
	,last: function() {
		if(this.q == null) {
			return null;
		} else {
			return this.q.item;
		}
	}
	,pop: function() {
		if(this.h == null) {
			return null;
		}
		var x = this.h.item;
		this.h = this.h.next;
		if(this.h == null) {
			this.q = null;
		}
		this.length--;
		return x;
	}
	,isEmpty: function() {
		return this.h == null;
	}
	,clear: function() {
		this.h = null;
		this.q = null;
		this.length = 0;
	}
	,remove: function(v) {
		var prev = null;
		var l = this.h;
		while(l != null) {
			if(l.item == v) {
				if(prev == null) {
					this.h = l.next;
				} else {
					prev.next = l.next;
				}
				if(this.q == l) {
					this.q = prev;
				}
				this.length--;
				return true;
			}
			prev = l;
			l = l.next;
		}
		return false;
	}
	,iterator: function() {
		return new _$List_ListIterator(this.h);
	}
	,toString: function() {
		var s_b = "";
		var first = true;
		var l = this.h;
		s_b += "{";
		while(l != null) {
			if(first) {
				first = false;
			} else {
				s_b += ", ";
			}
			s_b += Std.string(Std.string(l.item));
			l = l.next;
		}
		s_b += "}";
		return s_b;
	}
	,join: function(sep) {
		var s_b = "";
		var first = true;
		var l = this.h;
		while(l != null) {
			if(first) {
				first = false;
			} else {
				s_b += sep == null ? "null" : "" + sep;
			}
			s_b += Std.string(l.item);
			l = l.next;
		}
		return s_b;
	}
	,filter: function(f) {
		var l2 = new List();
		var l = this.h;
		while(l != null) {
			var v = l.item;
			l = l.next;
			if(f(v)) {
				l2.add(v);
			}
		}
		return l2;
	}
	,map: function(f) {
		var b = new List();
		var l = this.h;
		while(l != null) {
			var v = l.item;
			l = l.next;
			b.add(f(v));
		}
		return b;
	}
	,__class__: List
};
var _$List_ListNode = function(item,next) {
	this.item = item;
	this.next = next;
};
$hxClasses["_List.ListNode"] = _$List_ListNode;
_$List_ListNode.__name__ = ["_List","ListNode"];
_$List_ListNode.prototype = {
	item: null
	,next: null
	,__class__: _$List_ListNode
};
var _$List_ListIterator = function(head) {
	this.head = head;
};
$hxClasses["_List.ListIterator"] = _$List_ListIterator;
_$List_ListIterator.__name__ = ["_List","ListIterator"];
_$List_ListIterator.prototype = {
	head: null
	,hasNext: function() {
		return this.head != null;
	}
	,next: function() {
		var val = this.head.item;
		this.head = this.head.next;
		return val;
	}
	,__class__: _$List_ListIterator
};
Math.__name__ = ["Math"];
var Reflect = function() { };
$hxClasses["Reflect"] = Reflect;
Reflect.__name__ = ["Reflect"];
Reflect.hasField = function(o,field) {
	return Object.prototype.hasOwnProperty.call(o,field);
};
Reflect.field = function(o,field) {
	try {
		return o[field];
	} catch( e ) {
		return null;
	}
};
Reflect.setField = function(o,field,value) {
	o[field] = value;
};
Reflect.getProperty = function(o,field) {
	var tmp;
	if(o == null) {
		return null;
	} else {
		var tmp1;
		if(o.__properties__) {
			tmp = o.__properties__["get_" + field];
			tmp1 = tmp;
		} else {
			tmp1 = false;
		}
		if(tmp1) {
			return o[tmp]();
		} else {
			return o[field];
		}
	}
};
Reflect.setProperty = function(o,field,value) {
	var tmp;
	var tmp1;
	if(o.__properties__) {
		tmp = o.__properties__["set_" + field];
		tmp1 = tmp;
	} else {
		tmp1 = false;
	}
	if(tmp1) {
		o[tmp](value);
	} else {
		o[field] = value;
	}
};
Reflect.callMethod = function(o,func,args) {
	return func.apply(o,args);
};
Reflect.fields = function(o) {
	var a = [];
	if(o != null) {
		var hasOwnProperty = Object.prototype.hasOwnProperty;
		for( var f in o ) {
		if(f != "__id__" && f != "hx__closures__" && hasOwnProperty.call(o,f)) {
			a.push(f);
		}
		}
	}
	return a;
};
Reflect.isFunction = function(f) {
	if(typeof(f) == "function") {
		return !(f.__name__ || f.__ename__);
	} else {
		return false;
	}
};
Reflect.compare = function(a,b) {
	if(a == b) {
		return 0;
	} else if(a > b) {
		return 1;
	} else {
		return -1;
	}
};
Reflect.compareMethods = function(f1,f2) {
	if(f1 == f2) {
		return true;
	}
	if(!Reflect.isFunction(f1) || !Reflect.isFunction(f2)) {
		return false;
	}
	if(f1.scope == f2.scope && f1.method == f2.method) {
		return f1.method != null;
	} else {
		return false;
	}
};
Reflect.isObject = function(v) {
	if(v == null) {
		return false;
	}
	var t = typeof(v);
	if(!(t == "string" || t == "object" && v.__enum__ == null)) {
		if(t == "function") {
			return (v.__name__ || v.__ename__) != null;
		} else {
			return false;
		}
	} else {
		return true;
	}
};
Reflect.isEnumValue = function(v) {
	if(v != null) {
		return v.__enum__ != null;
	} else {
		return false;
	}
};
Reflect.deleteField = function(o,field) {
	if(!Object.prototype.hasOwnProperty.call(o,field)) {
		return false;
	}
	delete(o[field]);
	return true;
};
Reflect.copy = function(o) {
	var o2 = { };
	var _g = 0;
	var _g1 = Reflect.fields(o);
	while(_g < _g1.length) {
		var f = _g1[_g];
		++_g;
		o2[f] = Reflect.field(o,f);
	}
	return o2;
};
Reflect.makeVarArgs = function(f) {
	return function() {
		var a = Array.prototype.slice.call(arguments);
		return f(a);
	};
};
var Std = function() { };
$hxClasses["Std"] = Std;
Std.__name__ = ["Std"];
Std["is"] = function(v,t) {
	return js_Boot.__instanceof(v,t);
};
Std.instance = function(value,c) {
	if((value instanceof c)) {
		return value;
	} else {
		return null;
	}
};
Std.string = function(s) {
	return js_Boot.__string_rec(s,"");
};
Std["int"] = function(x) {
	return x | 0;
};
Std.parseInt = function(x) {
	var v = parseInt(x,10);
	if(v == 0 && (HxOverrides.cca(x,1) == 120 || HxOverrides.cca(x,1) == 88)) {
		v = parseInt(x);
	}
	if(isNaN(v)) {
		return null;
	}
	return v;
};
Std.parseFloat = function(x) {
	return parseFloat(x);
};
Std.random = function(x) {
	if(x <= 0) {
		return 0;
	} else {
		return Math.floor(Math.random() * x);
	}
};
var StringBuf = function() {
	this.b = "";
};
$hxClasses["StringBuf"] = StringBuf;
StringBuf.__name__ = ["StringBuf"];
StringBuf.prototype = {
	b: null
	,get_length: function() {
		return this.b.length;
	}
	,add: function(x) {
		this.b += Std.string(x);
	}
	,addChar: function(c) {
		this.b += String.fromCharCode(c);
	}
	,addSub: function(s,pos,len) {
		this.b += len == null ? HxOverrides.substr(s,pos,null) : HxOverrides.substr(s,pos,len);
	}
	,toString: function() {
		return this.b;
	}
	,__class__: StringBuf
	,__properties__: {get_length:"get_length"}
};
var ValueType = $hxClasses["ValueType"] = { __ename__ : ["ValueType"], __constructs__ : ["TNull","TInt","TFloat","TBool","TObject","TFunction","TClass","TEnum","TUnknown"] };
ValueType.TNull = ["TNull",0];
ValueType.TNull.toString = $estr;
ValueType.TNull.__enum__ = ValueType;
ValueType.TInt = ["TInt",1];
ValueType.TInt.toString = $estr;
ValueType.TInt.__enum__ = ValueType;
ValueType.TFloat = ["TFloat",2];
ValueType.TFloat.toString = $estr;
ValueType.TFloat.__enum__ = ValueType;
ValueType.TBool = ["TBool",3];
ValueType.TBool.toString = $estr;
ValueType.TBool.__enum__ = ValueType;
ValueType.TObject = ["TObject",4];
ValueType.TObject.toString = $estr;
ValueType.TObject.__enum__ = ValueType;
ValueType.TFunction = ["TFunction",5];
ValueType.TFunction.toString = $estr;
ValueType.TFunction.__enum__ = ValueType;
ValueType.TClass = function(c) { var $x = ["TClass",6,c]; $x.__enum__ = ValueType; $x.toString = $estr; return $x; };
ValueType.TEnum = function(e) { var $x = ["TEnum",7,e]; $x.__enum__ = ValueType; $x.toString = $estr; return $x; };
ValueType.TUnknown = ["TUnknown",8];
ValueType.TUnknown.toString = $estr;
ValueType.TUnknown.__enum__ = ValueType;
ValueType.__empty_constructs__ = [ValueType.TNull,ValueType.TInt,ValueType.TFloat,ValueType.TBool,ValueType.TObject,ValueType.TFunction,ValueType.TUnknown];
var Type = function() { };
$hxClasses["Type"] = Type;
Type.__name__ = ["Type"];
Type.getClass = function(o) {
	if(o == null) {
		return null;
	} else {
		return js_Boot.getClass(o);
	}
};
Type.getEnum = function(o) {
	if(o == null) {
		return null;
	}
	return o.__enum__;
};
Type.getSuperClass = function(c) {
	return c.__super__;
};
Type.getClassName = function(c) {
	var a = c.__name__;
	if(a == null) {
		return null;
	}
	return a.join(".");
};
Type.getEnumName = function(e) {
	var a = e.__ename__;
	return a.join(".");
};
Type.resolveClass = function(name) {
	var cl = $hxClasses[name];
	if(cl == null || !cl.__name__) {
		return null;
	}
	return cl;
};
Type.resolveEnum = function(name) {
	var e = $hxClasses[name];
	if(e == null || !e.__ename__) {
		return null;
	}
	return e;
};
Type.createInstance = function(cl,args) {
	var _g = args.length;
	switch(_g) {
	case 0:
		return new cl();
	case 1:
		return new cl(args[0]);
	case 2:
		return new cl(args[0],args[1]);
	case 3:
		return new cl(args[0],args[1],args[2]);
	case 4:
		return new cl(args[0],args[1],args[2],args[3]);
	case 5:
		return new cl(args[0],args[1],args[2],args[3],args[4]);
	case 6:
		return new cl(args[0],args[1],args[2],args[3],args[4],args[5]);
	case 7:
		return new cl(args[0],args[1],args[2],args[3],args[4],args[5],args[6]);
	case 8:
		return new cl(args[0],args[1],args[2],args[3],args[4],args[5],args[6],args[7]);
	case 9:
		return new cl(args[0],args[1],args[2],args[3],args[4],args[5],args[6],args[7],args[8]);
	case 10:
		return new cl(args[0],args[1],args[2],args[3],args[4],args[5],args[6],args[7],args[8],args[9]);
	case 11:
		return new cl(args[0],args[1],args[2],args[3],args[4],args[5],args[6],args[7],args[8],args[9],args[10]);
	case 12:
		return new cl(args[0],args[1],args[2],args[3],args[4],args[5],args[6],args[7],args[8],args[9],args[10],args[11]);
	case 13:
		return new cl(args[0],args[1],args[2],args[3],args[4],args[5],args[6],args[7],args[8],args[9],args[10],args[11],args[12]);
	case 14:
		return new cl(args[0],args[1],args[2],args[3],args[4],args[5],args[6],args[7],args[8],args[9],args[10],args[11],args[12],args[13]);
	default:
		throw new js__$Boot_HaxeError("Too many arguments");
	}
};
Type.createEmptyInstance = function(cl) {
	function empty() {}; empty.prototype = cl.prototype;
	return new empty();
};
Type.createEnum = function(e,constr,params) {
	var f = Reflect.field(e,constr);
	if(f == null) {
		throw new js__$Boot_HaxeError("No such constructor " + constr);
	}
	if(Reflect.isFunction(f)) {
		if(params == null) {
			throw new js__$Boot_HaxeError("Constructor " + constr + " need parameters");
		}
		return f.apply(e,params);
	}
	if(params != null && params.length != 0) {
		throw new js__$Boot_HaxeError("Constructor " + constr + " does not need parameters");
	}
	return f;
};
Type.createEnumIndex = function(e,index,params) {
	var c = e.__constructs__[index];
	if(c == null) {
		throw new js__$Boot_HaxeError(index + " is not a valid enum constructor index");
	}
	return Type.createEnum(e,c,params);
};
Type.getInstanceFields = function(c) {
	var a = [];
	for(var i in c.prototype) a.push(i);
	HxOverrides.remove(a,"__class__");
	HxOverrides.remove(a,"__properties__");
	return a;
};
Type.getClassFields = function(c) {
	var a = Reflect.fields(c);
	HxOverrides.remove(a,"__name__");
	HxOverrides.remove(a,"__interfaces__");
	HxOverrides.remove(a,"__properties__");
	HxOverrides.remove(a,"__super__");
	HxOverrides.remove(a,"__meta__");
	HxOverrides.remove(a,"prototype");
	return a;
};
Type.getEnumConstructs = function(e) {
	return e.__constructs__.slice();
};
Type["typeof"] = function(v) {
	var _g = typeof(v);
	switch(_g) {
	case "boolean":
		return ValueType.TBool;
	case "function":
		if(v.__name__ || v.__ename__) {
			return ValueType.TObject;
		}
		return ValueType.TFunction;
	case "number":
		if(Math.ceil(v) == v % 2147483648.0) {
			return ValueType.TInt;
		}
		return ValueType.TFloat;
	case "object":
		if(v == null) {
			return ValueType.TNull;
		}
		var e = v.__enum__;
		if(e != null) {
			return ValueType.TEnum(e);
		}
		var c = js_Boot.getClass(v);
		if(c != null) {
			return ValueType.TClass(c);
		}
		return ValueType.TObject;
	case "string":
		return ValueType.TClass(String);
	case "undefined":
		return ValueType.TNull;
	default:
		return ValueType.TUnknown;
	}
};
Type.enumEq = function(a,b) {
	if(a == b) {
		return true;
	}
	try {
		if(a[0] != b[0]) {
			return false;
		}
		var _g1 = 2;
		var _g = a.length;
		while(_g1 < _g) {
			var i = _g1++;
			if(!Type.enumEq(a[i],b[i])) {
				return false;
			}
		}
		var e = a.__enum__;
		if(e != b.__enum__ || e == null) {
			return false;
		}
	} catch( e1 ) {
		return false;
	}
	return true;
};
Type.enumConstructor = function(e) {
	return e[0];
};
Type.enumParameters = function(e) {
	return e.slice(2);
};
Type.enumIndex = function(e) {
	return e[1];
};
Type.allEnums = function(e) {
	return e.__empty_constructs__;
};
var haxe_IMap = function() { };
$hxClasses["haxe.IMap"] = haxe_IMap;
haxe_IMap.__name__ = ["haxe","IMap"];
haxe_IMap.prototype = {
	get: null
	,set: null
	,exists: null
	,remove: null
	,keys: null
	,iterator: null
	,toString: null
	,__class__: haxe_IMap
};
var haxe_Log = function() { };
$hxClasses["haxe.Log"] = haxe_Log;
haxe_Log.__name__ = ["haxe","Log"];
haxe_Log.trace = function(v,infos) {
	js_Boot.__trace(v,infos);
};
haxe_Log.clear = function() {
	js_Boot.__clear_trace();
};
var haxe_ds_ListSort = function() { };
$hxClasses["haxe.ds.ListSort"] = haxe_ds_ListSort;
haxe_ds_ListSort.__name__ = ["haxe","ds","ListSort"];
haxe_ds_ListSort.sort = function(list,cmp) {
	if(list == null) {
		return null;
	}
	var insize = 1;
	var nmerges;
	var psize = 0;
	var qsize = 0;
	var p;
	var q;
	var e;
	var tail = null;
	while(true) {
		p = list;
		list = null;
		tail = null;
		nmerges = 0;
		while(p != null) {
			++nmerges;
			q = p;
			psize = 0;
			var _g1 = 0;
			var _g = insize;
			while(_g1 < _g) {
				var i = _g1++;
				++psize;
				q = q.next;
				if(q == null) {
					break;
				}
			}
			qsize = insize;
			while(psize > 0 || qsize > 0 && q != null) {
				if(psize == 0) {
					e = q;
					q = q.next;
					--qsize;
				} else if(qsize == 0 || q == null || cmp(p,q) <= 0) {
					e = p;
					p = p.next;
					--psize;
				} else {
					e = q;
					q = q.next;
					--qsize;
				}
				if(tail != null) {
					tail.next = e;
				} else {
					list = e;
				}
				e.prev = tail;
				tail = e;
			}
			p = q;
		}
		tail.next = null;
		if(nmerges <= 1) {
			break;
		}
		insize *= 2;
	}
	list.prev = tail;
	return list;
};
haxe_ds_ListSort.sortSingleLinked = function(list,cmp) {
	if(list == null) {
		return null;
	}
	var insize = 1;
	var nmerges;
	var psize = 0;
	var qsize = 0;
	var p;
	var q;
	var e;
	var tail;
	while(true) {
		p = list;
		list = null;
		tail = null;
		nmerges = 0;
		while(p != null) {
			++nmerges;
			q = p;
			psize = 0;
			var _g1 = 0;
			var _g = insize;
			while(_g1 < _g) {
				var i = _g1++;
				++psize;
				q = q.next;
				if(q == null) {
					break;
				}
			}
			qsize = insize;
			while(psize > 0 || qsize > 0 && q != null) {
				if(psize == 0) {
					e = q;
					q = q.next;
					--qsize;
				} else if(qsize == 0 || q == null || cmp(p,q) <= 0) {
					e = p;
					p = p.next;
					--psize;
				} else {
					e = q;
					q = q.next;
					--qsize;
				}
				if(tail != null) {
					tail.next = e;
				} else {
					list = e;
				}
				tail = e;
			}
			p = q;
		}
		tail.next = null;
		if(nmerges <= 1) {
			break;
		}
		insize *= 2;
	}
	return list;
};
var haxe_ds__$Vector_Vector_$Impl_$ = {};
$hxClasses["haxe.ds._Vector.Vector_Impl_"] = haxe_ds__$Vector_Vector_$Impl_$;
haxe_ds__$Vector_Vector_$Impl_$.__name__ = ["haxe","ds","_Vector","Vector_Impl_"];
haxe_ds__$Vector_Vector_$Impl_$.__properties__ = {get_length:"get_length"};
haxe_ds__$Vector_Vector_$Impl_$._new = function(length) {
	var this1 = new Array(length);
	return this1;
};
haxe_ds__$Vector_Vector_$Impl_$.get = function(this1,index) {
	return this1[index];
};
haxe_ds__$Vector_Vector_$Impl_$.set = function(this1,index,val) {
	return this1[index] = val;
};
haxe_ds__$Vector_Vector_$Impl_$.get_length = function(this1) {
	return this1.length;
};
haxe_ds__$Vector_Vector_$Impl_$.blit = function(src,srcPos,dest,destPos,len) {
	if(src == dest) {
		if(srcPos < destPos) {
			var i = srcPos + len;
			var j = destPos + len;
			var _g1 = 0;
			var _g = len;
			while(_g1 < _g) {
				var k = _g1++;
				--i;
				--j;
				src[j] = src[i];
			}
		} else if(srcPos > destPos) {
			var i1 = srcPos;
			var j1 = destPos;
			var _g11 = 0;
			var _g2 = len;
			while(_g11 < _g2) {
				var k1 = _g11++;
				src[j1] = src[i1];
				++i1;
				++j1;
			}
		}
	} else {
		var _g12 = 0;
		var _g3 = len;
		while(_g12 < _g3) {
			var i2 = _g12++;
			dest[destPos + i2] = src[srcPos + i2];
		}
	}
};
haxe_ds__$Vector_Vector_$Impl_$.toArray = function(this1) {
	return this1.slice(0);
};
haxe_ds__$Vector_Vector_$Impl_$.toData = function(this1) {
	return this1;
};
haxe_ds__$Vector_Vector_$Impl_$.fromData = function(data) {
	return data;
};
haxe_ds__$Vector_Vector_$Impl_$.fromArrayCopy = function(array) {
	return array.slice(0);
};
haxe_ds__$Vector_Vector_$Impl_$.copy = function(this1) {
	var length = this1.length;
	var this2 = new Array(length);
	var r = this2;
	haxe_ds__$Vector_Vector_$Impl_$.blit(this1,0,r,0,this1.length);
	return r;
};
haxe_ds__$Vector_Vector_$Impl_$.join = function(this1,sep) {
	var b_b = "";
	var i = 0;
	var len = this1.length;
	var _g1 = 0;
	var _g = len;
	while(_g1 < _g) {
		var i1 = _g1++;
		b_b += Std.string(Std.string(this1[i1]));
		if(i1 < len - 1) {
			b_b += sep == null ? "null" : "" + sep;
		}
	}
	return b_b;
};
haxe_ds__$Vector_Vector_$Impl_$.map = function(this1,f) {
	var length = this1.length;
	var this2 = new Array(length);
	var r = this2;
	var i = 0;
	var len = length;
	var _g1 = 0;
	var _g = len;
	while(_g1 < _g) {
		var i1 = _g1++;
		var v = f(this1[i1]);
		r[i1] = v;
	}
	return r;
};
haxe_ds__$Vector_Vector_$Impl_$.sort = function(this1,f) {
	this1.sort(f);
};
var interfaces_Printer = function() {
	this.indent = "  ";
	this.newline = "\n";
	this.countingOffset = 1;
};
$hxClasses["interfaces.Printer"] = interfaces_Printer;
interfaces_Printer.__name__ = ["interfaces","Printer"];
interfaces_Printer.prototype = {
	countingOffset: null
	,newline: null
	,indent: null
	,printString: null
	,close: null
	,__class__: interfaces_Printer
};
var js__$Boot_HaxeError = function(val) {
	Error.call(this);
	this.val = val;
	this.message = String(val);
	if(Error.captureStackTrace) {
		Error.captureStackTrace(this,js__$Boot_HaxeError);
	}
};
$hxClasses["js._Boot.HaxeError"] = js__$Boot_HaxeError;
js__$Boot_HaxeError.__name__ = ["js","_Boot","HaxeError"];
js__$Boot_HaxeError.wrap = function(val) {
	if((val instanceof Error)) {
		return val;
	} else {
		return new js__$Boot_HaxeError(val);
	}
};
js__$Boot_HaxeError.__super__ = Error;
js__$Boot_HaxeError.prototype = $extend(Error.prototype,{
	val: null
	,__class__: js__$Boot_HaxeError
});
var js_Boot = function() { };
$hxClasses["js.Boot"] = js_Boot;
js_Boot.__name__ = ["js","Boot"];
js_Boot.__unhtml = function(s) {
	return s.split("&").join("&amp;").split("<").join("&lt;").split(">").join("&gt;");
};
js_Boot.__trace = function(v,i) {
	var msg = i != null ? i.fileName + ":" + i.lineNumber + ": " : "";
	msg += js_Boot.__string_rec(v,"");
	if(i != null && i.customParams != null) {
		var _g = 0;
		var _g1 = i.customParams;
		while(_g < _g1.length) {
			var v1 = _g1[_g];
			++_g;
			msg += "," + js_Boot.__string_rec(v1,"");
		}
	}
	var d;
	var tmp;
	if(typeof(document) != "undefined") {
		d = document.getElementById("haxe:trace");
		tmp = d != null;
	} else {
		tmp = false;
	}
	if(tmp) {
		d.innerHTML += js_Boot.__unhtml(msg) + "<br/>";
	} else if(typeof console != "undefined" && console.log != null) {
		console.log(msg);
	}
};
js_Boot.__clear_trace = function() {
	var d = document.getElementById("haxe:trace");
	if(d != null) {
		d.innerHTML = "";
	}
};
js_Boot.isClass = function(o) {
	return o.__name__;
};
js_Boot.isEnum = function(e) {
	return e.__ename__;
};
js_Boot.getClass = function(o) {
	if((o instanceof Array) && o.__enum__ == null) {
		return Array;
	} else {
		var cl = o.__class__;
		if(cl != null) {
			return cl;
		}
		var name = js_Boot.__nativeClassName(o);
		if(name != null) {
			return js_Boot.__resolveNativeClass(name);
		}
		return null;
	}
};
js_Boot.__string_rec = function(o,s) {
	if(o == null) {
		return "null";
	}
	if(s.length >= 5) {
		return "<...>";
	}
	var t = typeof(o);
	if(t == "function" && (o.__name__ || o.__ename__)) {
		t = "object";
	}
	switch(t) {
	case "function":
		return "<function>";
	case "object":
		if(o instanceof Array) {
			if(o.__enum__) {
				if(o.length == 2) {
					return o[0];
				}
				var str = o[0] + "(";
				s += "\t";
				var _g1 = 2;
				var _g = o.length;
				while(_g1 < _g) {
					var i = _g1++;
					if(i != 2) {
						str += "," + js_Boot.__string_rec(o[i],s);
					} else {
						str += js_Boot.__string_rec(o[i],s);
					}
				}
				return str + ")";
			}
			var l = o.length;
			var i1;
			var str1 = "[";
			s += "\t";
			var _g11 = 0;
			var _g2 = l;
			while(_g11 < _g2) {
				var i2 = _g11++;
				str1 += (i2 > 0 ? "," : "") + js_Boot.__string_rec(o[i2],s);
			}
			str1 += "]";
			return str1;
		}
		var tostr;
		try {
			tostr = o.toString;
		} catch( e ) {
			return "???";
		}
		if(tostr != null && tostr != Object.toString && typeof(tostr) == "function") {
			var s2 = o.toString();
			if(s2 != "[object Object]") {
				return s2;
			}
		}
		var k = null;
		var str2 = "{\n";
		s += "\t";
		var hasp = o.hasOwnProperty != null;
		for( var k in o ) {
		if(hasp && !o.hasOwnProperty(k)) {
			continue;
		}
		if(k == "prototype" || k == "__class__" || k == "__super__" || k == "__interfaces__" || k == "__properties__") {
			continue;
		}
		if(str2.length != 2) {
			str2 += ", \n";
		}
		str2 += s + k + " : " + js_Boot.__string_rec(o[k],s);
		}
		s = s.substring(1);
		str2 += "\n" + s + "}";
		return str2;
	case "string":
		return o;
	default:
		return String(o);
	}
};
js_Boot.__interfLoop = function(cc,cl) {
	if(cc == null) {
		return false;
	}
	if(cc == cl) {
		return true;
	}
	var intf = cc.__interfaces__;
	if(intf != null) {
		var _g1 = 0;
		var _g = intf.length;
		while(_g1 < _g) {
			var i = _g1++;
			var i1 = intf[i];
			if(i1 == cl || js_Boot.__interfLoop(i1,cl)) {
				return true;
			}
		}
	}
	return js_Boot.__interfLoop(cc.__super__,cl);
};
js_Boot.__instanceof = function(o,cl) {
	if(cl == null) {
		return false;
	}
	switch(cl) {
	case Array:
		if((o instanceof Array)) {
			return o.__enum__ == null;
		} else {
			return false;
		}
		break;
	case Bool:
		return typeof(o) == "boolean";
	case Dynamic:
		return true;
	case Float:
		return typeof(o) == "number";
	case Int:
		if(typeof(o) == "number") {
			return (o|0) === o;
		} else {
			return false;
		}
		break;
	case String:
		return typeof(o) == "string";
	default:
		if(o != null) {
			if(typeof(cl) == "function") {
				if(o instanceof cl) {
					return true;
				}
				if(js_Boot.__interfLoop(js_Boot.getClass(o),cl)) {
					return true;
				}
			} else if(typeof(cl) == "object" && js_Boot.__isNativeObj(cl)) {
				if(o instanceof cl) {
					return true;
				}
			}
		} else {
			return false;
		}
		if(cl == Class ? o.__name__ != null : false) {
			return true;
		}
		if(cl == Enum ? o.__ename__ != null : false) {
			return true;
		}
		return o.__enum__ == cl;
	}
};
js_Boot.__cast = function(o,t) {
	if(js_Boot.__instanceof(o,t)) {
		return o;
	} else {
		throw new js__$Boot_HaxeError("Cannot cast " + Std.string(o) + " to " + Std.string(t));
	}
};
js_Boot.__nativeClassName = function(o) {
	var name = js_Boot.__toStr.call(o).slice(8,-1);
	if(name == "Object" || name == "Function" || name == "Math" || name == "JSON") {
		return null;
	}
	return name;
};
js_Boot.__isNativeObj = function(o) {
	return js_Boot.__nativeClassName(o) != null;
};
js_Boot.__resolveNativeClass = function(name) {
	return $global[name];
};
var js_Lib = function() { };
$hxClasses["js.Lib"] = js_Lib;
js_Lib.__name__ = ["js","Lib"];
js_Lib.__properties__ = {get_undefined:"get_undefined"};
js_Lib.debug = function() {
	debugger;
};
js_Lib.alert = function(v) {
	alert(js_Boot.__string_rec(v,""));
};
js_Lib["eval"] = function(code) {
	return eval(code);
};
js_Lib.get_undefined = function() {
	return undefined;
};
var mj_Connection = function(conT,dist) {
	this.connectedTo = conT;
	this.dist = dist;
};
$hxClasses["mj.Connection"] = mj_Connection;
mj_Connection.__name__ = ["mj","Connection"];
mj_Connection.prototype = {
	next: null
	,connectedTo: null
	,dist: null
	,__class__: mj_Connection
};
var mj_Delta = function(s1,s2,dist) {
	this.s1 = s1;
	this.s2 = s2;
	this.dist = dist;
};
$hxClasses["mj.Delta"] = mj_Delta;
mj_Delta.__name__ = ["mj","Delta"];
mj_Delta.prototype = {
	s1: null
	,s2: null
	,dist: null
	,__class__: mj_Delta
};
var mj_Link = function() {
};
$hxClasses["mj.Link"] = mj_Link;
mj_Link.__name__ = ["mj","Link"];
mj_Link.prototype = {
	to: null
	,names: null
	,countInd: function() {
		return this.names.length;
	}
	,__class__: mj_Link
};
var mj_MJAlgo = function() {
	this.seqs = new mj_Seqs();
	this.rdeltas = new List();
	this.seqCount = 0;
	this.nextSpId = 0;
};
$hxClasses["mj.MJAlgo"] = mj_MJAlgo;
mj_MJAlgo.__name__ = ["mj","MJAlgo"];
mj_MJAlgo.main = function() {
};
mj_MJAlgo.prototype = {
	seqs: null
	,weights: null
	,rweights: null
	,rdeltas: null
	,seqCount: null
	,nextSpId: null
	,distStr: function(s1,s2) {
		var result = 0.0;
		var _g1 = 0;
		var _g = s1.length;
		while(_g1 < _g) {
			var pos = _g1++;
			if(s1.charAt(pos) != s2.charAt(pos)) {
				result += this.rweights[pos];
			}
		}
		return result;
	}
	,addSequence: function(name,seq) {
		this.seqs.addSample(name,seq);
		this.seqCount++;
	}
	,finishedAddingSequences: function() {
		if(this.seqs.size == 0) {
			throw new js__$Boot_HaxeError("Need at least one sequence to run the mj algorithm on ...");
		}
		var _this = this.seqs;
		if(_this.origSeqLen <= 1) {
			throw new js__$Boot_HaxeError("Need at least two sampled sequences!");
		}
		var _g1 = 0;
		var _g = _this.origSeqLen;
		while(_g1 < _g) {
			var pos = _g1++;
			var current = _this.first.next;
			while(current != null) {
				if(_this.first.origSeq.charAt(pos) != current.origSeq.charAt(pos)) {
					_this.ipos.add(pos);
					break;
				}
				current = current.next;
			}
		}
		var current1 = _this.first;
		while(current1 != null) {
			var ipos = _this.ipos;
			var l = new List();
			var _g_head = ipos.h;
			while(_g_head != null) {
				var val = _g_head.item;
				_g_head = _g_head.next;
				var e = val;
				l.add(current1.origSeq.charAt(e));
			}
			current1.redSeq = l.join("");
			var s = current1.redSeq;
			var result = 7;
			var _g11 = 0;
			var _g2 = s.length;
			while(_g11 < _g2) {
				var pos1 = _g11++;
				result = 31 * result + HxOverrides.cca(s,pos1);
			}
			current1.hashCode = result;
			current1 = current1.next;
		}
		var newSize = _this.hashTable.length << 1;
		var this1 = new Array(newSize);
		_this.hashTable = this1;
		var c = _this.first;
		while(c != null) {
			c.nextWithHash = null;
			c.prevWithHash = null;
			var hc = c.hashCode;
			var index = hc >= 0 ? hc % _this.hashTable.length : -hc % _this.hashTable.length;
			if(_this.hashTable[index] == null) {
				_this.hashTable[index] = c;
			} else {
				c.nextWithHash = _this.hashTable[index];
				_this.hashTable[index].prevWithHash = c;
				_this.hashTable[index] = c;
			}
			c = c.next;
		}
		if(this.weights == null) {
			var length = this.seqs.ipos.length;
			var this2 = new Array(length);
			this.rweights = this2;
			var _g12 = 0;
			var _g3 = this.seqs.ipos.length;
			while(_g12 < _g3) {
				var i = _g12++;
				this.rweights[i] = 1;
			}
		} else {
			if(this.weights.length != this.seqs.first.origSeq.length) {
				throw new js__$Boot_HaxeError("Expected " + this.seqs.first.origSeq.length + " weights but got " + this.weights.length + " weights!");
			}
			var length1 = this.seqs.ipos.length;
			var this3 = new Array(length1);
			this.rweights = this3;
			var iii = 0;
			var _g_head1 = this.seqs.ipos.h;
			while(_g_head1 != null) {
				var val1 = _g_head1.item;
				_g_head1 = _g_head1.next;
				var e1 = val1;
				this.rweights[iii++] = this.weights[e1];
			}
		}
	}
	,runMJ: function(epsilon,onlyMinimumSpanning) {
		if(onlyMinimumSpanning == null) {
			onlyMinimumSpanning = false;
		}
		if(this.seqs.size > 1) {
			var i;
			while(true) {
				var deltas = new List();
				var current = this.seqs.first;
				while(current != null) {
					var current2 = current.next;
					while(current2 != null) {
						var s1 = current.redSeq;
						var s2 = current2.redSeq;
						var result = 0.0;
						var _g1 = 0;
						var _g = s1.length;
						while(_g1 < _g) {
							var pos = _g1++;
							if(s1.charAt(pos) != s2.charAt(pos)) {
								result += this.rweights[pos];
							}
						}
						var d = new mj_Delta(current,current2,result);
						deltas.add(d);
						current2 = current2.next;
					}
					current = current.next;
				}
				var sortedLists = new List();
				var _g_head = deltas.h;
				while(_g_head != null) {
					var val = _g_head.item;
					_g_head = _g_head.next;
					var delta = val;
					if(sortedLists.last() != null && sortedLists.last().last() != null && sortedLists.last().last().dist <= delta.dist) {
						sortedLists.last().add(delta);
					} else {
						var newL = new List();
						newL.add(delta);
						sortedLists.add(newL);
					}
				}
				while(sortedLists.length > 1) {
					var l1 = sortedLists.pop();
					var l2 = sortedLists.pop();
					var nL = new List();
					while(!l1.isEmpty() && !l2.isEmpty()) if(l1.first().dist <= l2.first().dist) {
						nL.add(l1.pop());
					} else {
						nL.add(l2.pop());
					}
					while(!l1.isEmpty()) nL.add(l1.pop());
					while(!l2.isEmpty()) nL.add(l2.pop());
					sortedLists.add(nL);
				}
				deltas = sortedLists.first();
				this.rdeltas.clear();
				var lastDeltaValue = -1.0;
				var c = null;
				var _g_head1 = deltas.h;
				while(_g_head1 != null) {
					var val1 = _g_head1.item;
					_g_head1 = _g_head1.next;
					var delta1 = val1;
					if(lastDeltaValue != delta1.dist) {
						lastDeltaValue = delta1.dist;
						if(c != null) {
							this.rdeltas.add(c);
						}
						c = new List();
					}
					c.add(delta1);
				}
				if(c != null) {
					this.rdeltas.add(c);
				}
				var current1 = this.seqs.first;
				while(current1 != null) {
					current1.nrConnections = 0;
					current1.connectedTo = null;
					current1.visitedId = 0;
					current1 = current1.next;
				}
				var nextVisitedId = 1;
				var _g_head2 = this.rdeltas.h;
				while(_g_head2 != null) {
					var val2 = _g_head2.item;
					_g_head2 = _g_head2.next;
					var deltas1 = val2;
					var _g_head3 = deltas1.h;
					while(_g_head3 != null) {
						var val3 = _g_head3.item;
						_g_head3 = _g_head3.next;
						var delta2 = val3;
						var isConnected = false;
						var l = new List();
						l.add(delta2.s1);
						delta2.s1.visitedId = nextVisitedId;
						while(!l.isEmpty()) {
							var c1 = l.pop();
							if(c1 == delta2.s2) {
								isConnected = true;
							}
							var p = c1.connectedTo;
							while(p != null) {
								if(p.connectedTo.visitedId != nextVisitedId && p.dist < delta2.dist - epsilon) {
									l.add(p.connectedTo);
									p.connectedTo.visitedId = nextVisitedId;
								}
								p = p.next;
							}
						}
						++nextVisitedId;
						if(!isConnected) {
							var _this = delta2.s1;
							var c2 = new mj_Connection(delta2.s2,delta2.dist);
							c2.next = _this.connectedTo;
							_this.connectedTo = c2;
							_this.nrConnections++;
							var _this1 = delta2.s2;
							var c3 = new mj_Connection(delta2.s1,delta2.dist);
							c3.next = _this1.connectedTo;
							_this1.connectedTo = c3;
							_this1.nrConnections++;
						}
					}
				}
				if(onlyMinimumSpanning) {
					return;
				}
				var nrRem = 0;
				var current3 = this.seqs.firstMed;
				var markDel = new List();
				while(current3 != null) {
					if(current3.nrConnections <= 2) {
						markDel.add(current3);
						++nrRem;
					}
					current3 = current3.next;
				}
				var _g_head4 = markDel.h;
				while(_g_head4 != null) {
					var val4 = _g_head4.item;
					_g_head4 = _g_head4.next;
					var current4 = val4;
					var _this2 = this.seqs;
					current4.linkedTo.clear();
					if(_this2.firstMed == current4) {
						_this2.firstMed = current4.next;
					}
					if(_this2.last == current4) {
						_this2.last = current4.prev;
					}
					var hc = current4.hashCode;
					var index = hc >= 0 ? hc % _this2.hashTable.length : -hc % _this2.hashTable.length;
					if(_this2.hashTable[index] == current4) {
						_this2.hashTable[index] = current4.nextWithHash;
					}
					if(current4.next != null) {
						current4.next.prev = current4.prev;
					}
					if(current4.prev != null) {
						current4.prev.next = current4.next;
					}
					if(current4.nextWithHash != null) {
						current4.nextWithHash.prevWithHash = current4.prevWithHash;
					}
					if(current4.prevWithHash != null) {
						current4.prevWithHash.nextWithHash = current4.nextWithHash;
					}
					_this2.size--;
					current4.next = null;
					current4.prev = null;
					current4.nextWithHash = null;
					current4.prevWithHash = null;
				}
				i = nrRem;
				if(i != 0) {
					if(!(i != 0)) {
						break;
					} else {
						continue;
					}
				}
				var medLst = new List();
				var s11 = this.seqs.first;
				while(s11 != null) {
					var s2_ = s11.connectedTo;
					while(s2_ != null) {
						var s12 = s11.redSeq;
						var s21 = s2_.connectedTo.redSeq;
						var result1 = 0.0;
						var _g11 = 0;
						var _g2 = s12.length;
						while(_g11 < _g2) {
							var pos1 = _g11++;
							if(s12.charAt(pos1) != s21.charAt(pos1)) {
								result1 += this.rweights[pos1];
							}
						}
						var c12 = result1;
						var s3_ = s2_.next;
						while(s3_ != null) {
							var s13 = s2_.connectedTo.redSeq;
							var s22 = s3_.connectedTo.redSeq;
							var result2 = 0.0;
							var _g12 = 0;
							var _g3 = s13.length;
							while(_g12 < _g3) {
								var pos2 = _g12++;
								if(s13.charAt(pos2) != s22.charAt(pos2)) {
									result2 += this.rweights[pos2];
								}
							}
							var c23 = result2;
							var cDist = c12 + c23;
							medLst.add(new mj_Median(s11.redSeq,s2_.connectedTo.redSeq,s3_.connectedTo.redSeq,this.rweights,cDist));
							s3_ = s3_.next;
						}
						s2_ = s2_.next;
					}
					s11 = s11.next;
				}
				var sortedMeds = new List();
				var _g_head5 = medLst.h;
				while(_g_head5 != null) {
					var val5 = _g_head5.item;
					_g_head5 = _g_head5.next;
					var med = val5;
					if(sortedMeds.last() != null && sortedMeds.last().last() != null && sortedMeds.last().last().dist <= med.dist) {
						sortedMeds.last().add(med);
					} else {
						var l3 = new List();
						l3.add(med);
						sortedMeds.add(l3);
					}
				}
				while(sortedMeds.length > 1) {
					var l11 = sortedMeds.pop();
					var l21 = sortedMeds.pop();
					var nL1 = new List();
					while(!l11.isEmpty() && !l21.isEmpty()) if(l11.first().dist <= l21.first().dist) {
						nL1.add(l11.pop());
					} else {
						nL1.add(l21.pop());
					}
					while(!l11.isEmpty()) nL1.add(l11.pop());
					while(!l21.isEmpty()) nL1.add(l21.pop());
					sortedMeds.add(nL1);
				}
				medLst = sortedMeds.pop();
				if(medLst == null) {
					medLst = new List();
				}
				var nrSeqsAdded = 0;
				var lambda = Infinity;
				var _g_head6 = medLst.h;
				while(_g_head6 != null) {
					var val6 = _g_head6.item;
					_g_head6 = _g_head6.next;
					var med1 = val6;
					if(med1.makesSense && med1.diffPos >= 1 && med1.dist <= lambda + epsilon) {
						var _g_head7 = med1.constructMedians().h;
						while(_g_head7 != null) {
							var val7 = _g_head7.item;
							_g_head7 = _g_head7.next;
							var medV = val7;
							var _this3 = this.seqs;
							var result3 = false;
							var result4 = 7;
							var _g13 = 0;
							var _g4 = medV.length;
							while(_g13 < _g4) {
								var pos3 = _g13++;
								result4 = 31 * result4 + HxOverrides.cca(medV,pos3);
							}
							var hc1 = result4;
							var hc2 = hc1 >= 0 ? hc1 % _this3.hashTable.length : -hc1 % _this3.hashTable.length;
							var s = _this3.hashTable[hc2];
							while(s != null) {
								if(s.redSeq == medV) {
									result3 = true;
									break;
								}
								s = s.nextWithHash;
							}
							if(result3) {
								continue;
							}
							lambda = Math.min(lambda,med1.dist);
							var _this4 = this.seqs;
							var result5 = false;
							var result6 = 7;
							var _g14 = 0;
							var _g5 = medV.length;
							while(_g14 < _g5) {
								var pos4 = _g14++;
								result6 = 31 * result6 + HxOverrides.cca(medV,pos4);
							}
							var hc3 = result6;
							var hc4 = hc3 >= 0 ? hc3 % _this4.hashTable.length : -hc3 % _this4.hashTable.length;
							var s3 = _this4.hashTable[hc4];
							while(s3 != null) {
								if(s3.redSeq == medV) {
									result5 = true;
									break;
								}
								s3 = s3.nextWithHash;
							}
							if(!result5) {
								var id = _this4.nextSeqId++;
								var result7 = new mj_Seq();
								result7.id = id;
								result7.redSeq = medV;
								var s4 = result7.redSeq;
								var result8 = 7;
								var _g15 = 0;
								var _g6 = s4.length;
								while(_g15 < _g6) {
									var pos5 = _g15++;
									result8 = 31 * result8 + HxOverrides.cca(s4,pos5);
								}
								result7.hashCode = result8;
								result7.isSample = false;
								var s5 = result7;
								_this4.size++;
								if(_this4.hashTable.length >> 1 < _this4.size) {
									var newSize = _this4.hashTable.length << 1;
									var this1 = new Array(newSize);
									_this4.hashTable = this1;
									var c4 = _this4.first;
									while(c4 != null) {
										c4.nextWithHash = null;
										c4.prevWithHash = null;
										var hc5 = c4.hashCode;
										var index1 = hc5 >= 0 ? hc5 % _this4.hashTable.length : -hc5 % _this4.hashTable.length;
										if(_this4.hashTable[index1] == null) {
											_this4.hashTable[index1] = c4;
										} else {
											c4.nextWithHash = _this4.hashTable[index1];
											_this4.hashTable[index1].prevWithHash = c4;
											_this4.hashTable[index1] = c4;
										}
										c4 = c4.next;
									}
								}
								s5.nextWithHash = null;
								s5.prevWithHash = null;
								var hc6 = s5.hashCode;
								var index2 = hc6 >= 0 ? hc6 % _this4.hashTable.length : -hc6 % _this4.hashTable.length;
								if(_this4.hashTable[index2] == null) {
									_this4.hashTable[index2] = s5;
								} else {
									s5.nextWithHash = _this4.hashTable[index2];
									_this4.hashTable[index2].prevWithHash = s5;
									_this4.hashTable[index2] = s5;
								}
								if(_this4.first == null) {
									_this4.first = s5;
								} else {
									s5.prev = _this4.last;
									_this4.last.next = s5;
								}
								_this4.last = s5;
								if(_this4.firstMed == null && !s5.isSample) {
									_this4.firstMed = s5;
								}
							}
							++nrSeqsAdded;
						}
					} else {
						break;
					}
				}
				i = nrSeqsAdded;
				if(!(i != 0)) {
					break;
				}
			}
			var i1;
			while(true) {
				var deltas2 = new List();
				var current5 = this.seqs.first;
				while(current5 != null) {
					var current21 = current5.next;
					while(current21 != null) {
						var s14 = current5.redSeq;
						var s23 = current21.redSeq;
						var result9 = 0.0;
						var _g16 = 0;
						var _g7 = s14.length;
						while(_g16 < _g7) {
							var pos6 = _g16++;
							if(s14.charAt(pos6) != s23.charAt(pos6)) {
								result9 += this.rweights[pos6];
							}
						}
						var d1 = new mj_Delta(current5,current21,result9);
						deltas2.add(d1);
						current21 = current21.next;
					}
					current5 = current5.next;
				}
				var sortedLists1 = new List();
				var _g_head8 = deltas2.h;
				while(_g_head8 != null) {
					var val8 = _g_head8.item;
					_g_head8 = _g_head8.next;
					var delta3 = val8;
					if(sortedLists1.last() != null && sortedLists1.last().last() != null && sortedLists1.last().last().dist <= delta3.dist) {
						sortedLists1.last().add(delta3);
					} else {
						var newL1 = new List();
						newL1.add(delta3);
						sortedLists1.add(newL1);
					}
				}
				while(sortedLists1.length > 1) {
					var l12 = sortedLists1.pop();
					var l22 = sortedLists1.pop();
					var nL2 = new List();
					while(!l12.isEmpty() && !l22.isEmpty()) if(l12.first().dist <= l22.first().dist) {
						nL2.add(l12.pop());
					} else {
						nL2.add(l22.pop());
					}
					while(!l12.isEmpty()) nL2.add(l12.pop());
					while(!l22.isEmpty()) nL2.add(l22.pop());
					sortedLists1.add(nL2);
				}
				deltas2 = sortedLists1.first();
				this.rdeltas.clear();
				var lastDeltaValue1 = -1.0;
				var c5 = null;
				var _g_head9 = deltas2.h;
				while(_g_head9 != null) {
					var val9 = _g_head9.item;
					_g_head9 = _g_head9.next;
					var delta4 = val9;
					if(lastDeltaValue1 != delta4.dist) {
						lastDeltaValue1 = delta4.dist;
						if(c5 != null) {
							this.rdeltas.add(c5);
						}
						c5 = new List();
					}
					c5.add(delta4);
				}
				if(c5 != null) {
					this.rdeltas.add(c5);
				}
				var current6 = this.seqs.first;
				while(current6 != null) {
					current6.nrConnections = 0;
					current6.connectedTo = null;
					current6.visitedId = 0;
					current6 = current6.next;
				}
				var nextVisitedId1 = 1;
				var _g_head10 = this.rdeltas.h;
				while(_g_head10 != null) {
					var val10 = _g_head10.item;
					_g_head10 = _g_head10.next;
					var deltas3 = val10;
					var _g_head11 = deltas3.h;
					while(_g_head11 != null) {
						var val11 = _g_head11.item;
						_g_head11 = _g_head11.next;
						var delta5 = val11;
						var isConnected1 = false;
						var l4 = new List();
						l4.add(delta5.s1);
						delta5.s1.visitedId = nextVisitedId1;
						while(!l4.isEmpty()) {
							var c6 = l4.pop();
							if(c6 == delta5.s2) {
								isConnected1 = true;
							}
							var p1 = c6.connectedTo;
							while(p1 != null) {
								if(p1.connectedTo.visitedId != nextVisitedId1 && p1.dist < delta5.dist) {
									l4.add(p1.connectedTo);
									p1.connectedTo.visitedId = nextVisitedId1;
								}
								p1 = p1.next;
							}
						}
						++nextVisitedId1;
						if(!isConnected1) {
							var _this5 = delta5.s1;
							var c7 = new mj_Connection(delta5.s2,delta5.dist);
							c7.next = _this5.connectedTo;
							_this5.connectedTo = c7;
							_this5.nrConnections++;
							var _this6 = delta5.s2;
							var c8 = new mj_Connection(delta5.s1,delta5.dist);
							c8.next = _this6.connectedTo;
							_this6.connectedTo = c8;
							_this6.nrConnections++;
						}
					}
				}
				var nrRem1 = 0;
				var current7 = this.seqs.firstMed;
				var markDel1 = new List();
				while(current7 != null) {
					if(current7.nrConnections <= 2) {
						markDel1.add(current7);
						++nrRem1;
					}
					current7 = current7.next;
				}
				var _g_head12 = markDel1.h;
				while(_g_head12 != null) {
					var val12 = _g_head12.item;
					_g_head12 = _g_head12.next;
					var current8 = val12;
					var _this7 = this.seqs;
					current8.linkedTo.clear();
					if(_this7.firstMed == current8) {
						_this7.firstMed = current8.next;
					}
					if(_this7.last == current8) {
						_this7.last = current8.prev;
					}
					var hc7 = current8.hashCode;
					var index3 = hc7 >= 0 ? hc7 % _this7.hashTable.length : -hc7 % _this7.hashTable.length;
					if(_this7.hashTable[index3] == current8) {
						_this7.hashTable[index3] = current8.nextWithHash;
					}
					if(current8.next != null) {
						current8.next.prev = current8.prev;
					}
					if(current8.prev != null) {
						current8.prev.next = current8.next;
					}
					if(current8.nextWithHash != null) {
						current8.nextWithHash.prevWithHash = current8.prevWithHash;
					}
					if(current8.prevWithHash != null) {
						current8.prevWithHash.nextWithHash = current8.nextWithHash;
					}
					_this7.size--;
					current8.next = null;
					current8.prev = null;
					current8.nextWithHash = null;
					current8.prevWithHash = null;
				}
				i1 = nrRem1;
				if(!(i1 != 0)) {
					break;
				}
			}
		}
	}
	,step1: function() {
		var deltas = new List();
		var current = this.seqs.first;
		while(current != null) {
			var current2 = current.next;
			while(current2 != null) {
				var s1 = current.redSeq;
				var s2 = current2.redSeq;
				var result = 0.0;
				var _g1 = 0;
				var _g = s1.length;
				while(_g1 < _g) {
					var pos = _g1++;
					if(s1.charAt(pos) != s2.charAt(pos)) {
						result += this.rweights[pos];
					}
				}
				var d = new mj_Delta(current,current2,result);
				deltas.add(d);
				current2 = current2.next;
			}
			current = current.next;
		}
		var sortedLists = new List();
		var _g_head = deltas.h;
		while(_g_head != null) {
			var val = _g_head.item;
			_g_head = _g_head.next;
			var delta = val;
			if(sortedLists.last() != null && sortedLists.last().last() != null && sortedLists.last().last().dist <= delta.dist) {
				sortedLists.last().add(delta);
			} else {
				var newL = new List();
				newL.add(delta);
				sortedLists.add(newL);
			}
		}
		while(sortedLists.length > 1) {
			var l1 = sortedLists.pop();
			var l2 = sortedLists.pop();
			var nL = new List();
			while(!l1.isEmpty() && !l2.isEmpty()) if(l1.first().dist <= l2.first().dist) {
				nL.add(l1.pop());
			} else {
				nL.add(l2.pop());
			}
			while(!l1.isEmpty()) nL.add(l1.pop());
			while(!l2.isEmpty()) nL.add(l2.pop());
			sortedLists.add(nL);
		}
		deltas = sortedLists.first();
		this.rdeltas.clear();
		var lastDeltaValue = -1.0;
		var c = null;
		var _g_head1 = deltas.h;
		while(_g_head1 != null) {
			var val1 = _g_head1.item;
			_g_head1 = _g_head1.next;
			var delta1 = val1;
			if(lastDeltaValue != delta1.dist) {
				lastDeltaValue = delta1.dist;
				if(c != null) {
					this.rdeltas.add(c);
				}
				c = new List();
			}
			c.add(delta1);
		}
		if(c != null) {
			this.rdeltas.add(c);
		}
	}
	,step2: function(epsilon) {
		var current = this.seqs.first;
		while(current != null) {
			current.nrConnections = 0;
			current.connectedTo = null;
			current.visitedId = 0;
			current = current.next;
		}
		var nextVisitedId = 1;
		var _g_head = this.rdeltas.h;
		while(_g_head != null) {
			var val = _g_head.item;
			_g_head = _g_head.next;
			var deltas = val;
			var _g_head1 = deltas.h;
			while(_g_head1 != null) {
				var val1 = _g_head1.item;
				_g_head1 = _g_head1.next;
				var delta = val1;
				var isConnected = false;
				var l = new List();
				l.add(delta.s1);
				delta.s1.visitedId = nextVisitedId;
				while(!l.isEmpty()) {
					var c = l.pop();
					if(c == delta.s2) {
						isConnected = true;
					}
					var p = c.connectedTo;
					while(p != null) {
						if(p.connectedTo.visitedId != nextVisitedId && p.dist < delta.dist - epsilon) {
							l.add(p.connectedTo);
							p.connectedTo.visitedId = nextVisitedId;
						}
						p = p.next;
					}
				}
				++nextVisitedId;
				if(!isConnected) {
					var _this = delta.s1;
					var c1 = new mj_Connection(delta.s2,delta.dist);
					c1.next = _this.connectedTo;
					_this.connectedTo = c1;
					_this.nrConnections++;
					var _this1 = delta.s2;
					var c2 = new mj_Connection(delta.s1,delta.dist);
					c2.next = _this1.connectedTo;
					_this1.connectedTo = c2;
					_this1.nrConnections++;
				}
			}
		}
	}
	,step3: function() {
		var nrRem = 0;
		var current = this.seqs.firstMed;
		var markDel = new List();
		while(current != null) {
			if(current.nrConnections <= 2) {
				markDel.add(current);
				++nrRem;
			}
			current = current.next;
		}
		var _g_head = markDel.h;
		while(_g_head != null) {
			var val = _g_head.item;
			_g_head = _g_head.next;
			var current1 = val;
			var _this = this.seqs;
			current1.linkedTo.clear();
			if(_this.firstMed == current1) {
				_this.firstMed = current1.next;
			}
			if(_this.last == current1) {
				_this.last = current1.prev;
			}
			var hc = current1.hashCode;
			var index = hc >= 0 ? hc % _this.hashTable.length : -hc % _this.hashTable.length;
			if(_this.hashTable[index] == current1) {
				_this.hashTable[index] = current1.nextWithHash;
			}
			if(current1.next != null) {
				current1.next.prev = current1.prev;
			}
			if(current1.prev != null) {
				current1.prev.next = current1.next;
			}
			if(current1.nextWithHash != null) {
				current1.nextWithHash.prevWithHash = current1.prevWithHash;
			}
			if(current1.prevWithHash != null) {
				current1.prevWithHash.nextWithHash = current1.nextWithHash;
			}
			_this.size--;
			current1.next = null;
			current1.prev = null;
			current1.nextWithHash = null;
			current1.prevWithHash = null;
		}
		return nrRem;
	}
	,step4: function(epsilon) {
		var medLst = new List();
		var s1 = this.seqs.first;
		while(s1 != null) {
			var s2_ = s1.connectedTo;
			while(s2_ != null) {
				var s11 = s1.redSeq;
				var s2 = s2_.connectedTo.redSeq;
				var result = 0.0;
				var _g1 = 0;
				var _g = s11.length;
				while(_g1 < _g) {
					var pos = _g1++;
					if(s11.charAt(pos) != s2.charAt(pos)) {
						result += this.rweights[pos];
					}
				}
				var c12 = result;
				var s3_ = s2_.next;
				while(s3_ != null) {
					var s12 = s2_.connectedTo.redSeq;
					var s21 = s3_.connectedTo.redSeq;
					var result1 = 0.0;
					var _g11 = 0;
					var _g2 = s12.length;
					while(_g11 < _g2) {
						var pos1 = _g11++;
						if(s12.charAt(pos1) != s21.charAt(pos1)) {
							result1 += this.rweights[pos1];
						}
					}
					var c23 = result1;
					var cDist = c12 + c23;
					medLst.add(new mj_Median(s1.redSeq,s2_.connectedTo.redSeq,s3_.connectedTo.redSeq,this.rweights,cDist));
					s3_ = s3_.next;
				}
				s2_ = s2_.next;
			}
			s1 = s1.next;
		}
		var sortedMeds = new List();
		var _g_head = medLst.h;
		while(_g_head != null) {
			var val = _g_head.item;
			_g_head = _g_head.next;
			var med = val;
			if(sortedMeds.last() != null && sortedMeds.last().last() != null && sortedMeds.last().last().dist <= med.dist) {
				sortedMeds.last().add(med);
			} else {
				var l = new List();
				l.add(med);
				sortedMeds.add(l);
			}
		}
		while(sortedMeds.length > 1) {
			var l1 = sortedMeds.pop();
			var l2 = sortedMeds.pop();
			var nL = new List();
			while(!l1.isEmpty() && !l2.isEmpty()) if(l1.first().dist <= l2.first().dist) {
				nL.add(l1.pop());
			} else {
				nL.add(l2.pop());
			}
			while(!l1.isEmpty()) nL.add(l1.pop());
			while(!l2.isEmpty()) nL.add(l2.pop());
			sortedMeds.add(nL);
		}
		medLst = sortedMeds.pop();
		if(medLst == null) {
			medLst = new List();
		}
		var nrSeqsAdded = 0;
		var lambda = Infinity;
		var _g_head1 = medLst.h;
		while(_g_head1 != null) {
			var val1 = _g_head1.item;
			_g_head1 = _g_head1.next;
			var med1 = val1;
			if(med1.makesSense && med1.diffPos >= 1 && med1.dist <= lambda + epsilon) {
				var _g_head2 = med1.constructMedians().h;
				while(_g_head2 != null) {
					var val2 = _g_head2.item;
					_g_head2 = _g_head2.next;
					var medV = val2;
					var _this = this.seqs;
					var result2 = false;
					var result3 = 7;
					var _g12 = 0;
					var _g3 = medV.length;
					while(_g12 < _g3) {
						var pos2 = _g12++;
						result3 = 31 * result3 + HxOverrides.cca(medV,pos2);
					}
					var hc = result3;
					var hc1 = hc >= 0 ? hc % _this.hashTable.length : -hc % _this.hashTable.length;
					var s = _this.hashTable[hc1];
					while(s != null) {
						if(s.redSeq == medV) {
							result2 = true;
							break;
						}
						s = s.nextWithHash;
					}
					if(result2) {
						continue;
					}
					lambda = Math.min(lambda,med1.dist);
					var _this1 = this.seqs;
					var result4 = false;
					var result5 = 7;
					var _g13 = 0;
					var _g4 = medV.length;
					while(_g13 < _g4) {
						var pos3 = _g13++;
						result5 = 31 * result5 + HxOverrides.cca(medV,pos3);
					}
					var hc2 = result5;
					var hc3 = hc2 >= 0 ? hc2 % _this1.hashTable.length : -hc2 % _this1.hashTable.length;
					var s3 = _this1.hashTable[hc3];
					while(s3 != null) {
						if(s3.redSeq == medV) {
							result4 = true;
							break;
						}
						s3 = s3.nextWithHash;
					}
					if(!result4) {
						var id = _this1.nextSeqId++;
						var result6 = new mj_Seq();
						result6.id = id;
						result6.redSeq = medV;
						var s4 = result6.redSeq;
						var result7 = 7;
						var _g14 = 0;
						var _g5 = s4.length;
						while(_g14 < _g5) {
							var pos4 = _g14++;
							result7 = 31 * result7 + HxOverrides.cca(s4,pos4);
						}
						result6.hashCode = result7;
						result6.isSample = false;
						var s5 = result6;
						_this1.size++;
						if(_this1.hashTable.length >> 1 < _this1.size) {
							var newSize = _this1.hashTable.length << 1;
							var this1 = new Array(newSize);
							_this1.hashTable = this1;
							var c = _this1.first;
							while(c != null) {
								c.nextWithHash = null;
								c.prevWithHash = null;
								var hc4 = c.hashCode;
								var index = hc4 >= 0 ? hc4 % _this1.hashTable.length : -hc4 % _this1.hashTable.length;
								if(_this1.hashTable[index] == null) {
									_this1.hashTable[index] = c;
								} else {
									c.nextWithHash = _this1.hashTable[index];
									_this1.hashTable[index].prevWithHash = c;
									_this1.hashTable[index] = c;
								}
								c = c.next;
							}
						}
						s5.nextWithHash = null;
						s5.prevWithHash = null;
						var hc5 = s5.hashCode;
						var index1 = hc5 >= 0 ? hc5 % _this1.hashTable.length : -hc5 % _this1.hashTable.length;
						if(_this1.hashTable[index1] == null) {
							_this1.hashTable[index1] = s5;
						} else {
							s5.nextWithHash = _this1.hashTable[index1];
							_this1.hashTable[index1].prevWithHash = s5;
							_this1.hashTable[index1] = s5;
						}
						if(_this1.first == null) {
							_this1.first = s5;
						} else {
							s5.prev = _this1.last;
							_this1.last.next = s5;
						}
						_this1.last = s5;
						if(_this1.firstMed == null && !s5.isSample) {
							_this1.firstMed = s5;
						}
					}
					++nrSeqsAdded;
				}
			} else {
				break;
			}
		}
		return nrSeqsAdded;
	}
	,step5: function() {
		var i;
		while(true) {
			var deltas = new List();
			var current = this.seqs.first;
			while(current != null) {
				var current2 = current.next;
				while(current2 != null) {
					var s1 = current.redSeq;
					var s2 = current2.redSeq;
					var result = 0.0;
					var _g1 = 0;
					var _g = s1.length;
					while(_g1 < _g) {
						var pos = _g1++;
						if(s1.charAt(pos) != s2.charAt(pos)) {
							result += this.rweights[pos];
						}
					}
					var d = new mj_Delta(current,current2,result);
					deltas.add(d);
					current2 = current2.next;
				}
				current = current.next;
			}
			var sortedLists = new List();
			var _g_head = deltas.h;
			while(_g_head != null) {
				var val = _g_head.item;
				_g_head = _g_head.next;
				var delta = val;
				if(sortedLists.last() != null && sortedLists.last().last() != null && sortedLists.last().last().dist <= delta.dist) {
					sortedLists.last().add(delta);
				} else {
					var newL = new List();
					newL.add(delta);
					sortedLists.add(newL);
				}
			}
			while(sortedLists.length > 1) {
				var l1 = sortedLists.pop();
				var l2 = sortedLists.pop();
				var nL = new List();
				while(!l1.isEmpty() && !l2.isEmpty()) if(l1.first().dist <= l2.first().dist) {
					nL.add(l1.pop());
				} else {
					nL.add(l2.pop());
				}
				while(!l1.isEmpty()) nL.add(l1.pop());
				while(!l2.isEmpty()) nL.add(l2.pop());
				sortedLists.add(nL);
			}
			deltas = sortedLists.first();
			this.rdeltas.clear();
			var lastDeltaValue = -1.0;
			var c = null;
			var _g_head1 = deltas.h;
			while(_g_head1 != null) {
				var val1 = _g_head1.item;
				_g_head1 = _g_head1.next;
				var delta1 = val1;
				if(lastDeltaValue != delta1.dist) {
					lastDeltaValue = delta1.dist;
					if(c != null) {
						this.rdeltas.add(c);
					}
					c = new List();
				}
				c.add(delta1);
			}
			if(c != null) {
				this.rdeltas.add(c);
			}
			var current1 = this.seqs.first;
			while(current1 != null) {
				current1.nrConnections = 0;
				current1.connectedTo = null;
				current1.visitedId = 0;
				current1 = current1.next;
			}
			var nextVisitedId = 1;
			var _g_head2 = this.rdeltas.h;
			while(_g_head2 != null) {
				var val2 = _g_head2.item;
				_g_head2 = _g_head2.next;
				var deltas1 = val2;
				var _g_head3 = deltas1.h;
				while(_g_head3 != null) {
					var val3 = _g_head3.item;
					_g_head3 = _g_head3.next;
					var delta2 = val3;
					var isConnected = false;
					var l = new List();
					l.add(delta2.s1);
					delta2.s1.visitedId = nextVisitedId;
					while(!l.isEmpty()) {
						var c1 = l.pop();
						if(c1 == delta2.s2) {
							isConnected = true;
						}
						var p = c1.connectedTo;
						while(p != null) {
							if(p.connectedTo.visitedId != nextVisitedId && p.dist < delta2.dist) {
								l.add(p.connectedTo);
								p.connectedTo.visitedId = nextVisitedId;
							}
							p = p.next;
						}
					}
					++nextVisitedId;
					if(!isConnected) {
						var _this = delta2.s1;
						var c2 = new mj_Connection(delta2.s2,delta2.dist);
						c2.next = _this.connectedTo;
						_this.connectedTo = c2;
						_this.nrConnections++;
						var _this1 = delta2.s2;
						var c3 = new mj_Connection(delta2.s1,delta2.dist);
						c3.next = _this1.connectedTo;
						_this1.connectedTo = c3;
						_this1.nrConnections++;
					}
				}
			}
			var nrRem = 0;
			var current3 = this.seqs.firstMed;
			var markDel = new List();
			while(current3 != null) {
				if(current3.nrConnections <= 2) {
					markDel.add(current3);
					++nrRem;
				}
				current3 = current3.next;
			}
			var _g_head4 = markDel.h;
			while(_g_head4 != null) {
				var val4 = _g_head4.item;
				_g_head4 = _g_head4.next;
				var current4 = val4;
				var _this2 = this.seqs;
				current4.linkedTo.clear();
				if(_this2.firstMed == current4) {
					_this2.firstMed = current4.next;
				}
				if(_this2.last == current4) {
					_this2.last = current4.prev;
				}
				var hc = current4.hashCode;
				var index = hc >= 0 ? hc % _this2.hashTable.length : -hc % _this2.hashTable.length;
				if(_this2.hashTable[index] == current4) {
					_this2.hashTable[index] = current4.nextWithHash;
				}
				if(current4.next != null) {
					current4.next.prev = current4.prev;
				}
				if(current4.prev != null) {
					current4.prev.next = current4.next;
				}
				if(current4.nextWithHash != null) {
					current4.nextWithHash.prevWithHash = current4.prevWithHash;
				}
				if(current4.prevWithHash != null) {
					current4.prevWithHash.nextWithHash = current4.nextWithHash;
				}
				_this2.size--;
				current4.next = null;
				current4.prev = null;
				current4.nextWithHash = null;
				current4.prevWithHash = null;
			}
			i = nrRem;
			if(!(i != 0)) {
				break;
			}
		}
	}
	,finalizeNetwork: function() {
		var list = this.seqs.first;
		var tmp;
		if(list == null) {
			tmp = null;
		} else {
			var insize = 1;
			var nmerges;
			var psize = 0;
			var qsize = 0;
			var p;
			var q;
			var e;
			var tail = null;
			while(true) {
				p = list;
				list = null;
				tail = null;
				nmerges = 0;
				while(p != null) {
					++nmerges;
					q = p;
					psize = 0;
					var _g1 = 0;
					var _g = insize;
					while(_g1 < _g) {
						var i = _g1++;
						++psize;
						q = q.next;
						if(q == null) {
							break;
						}
					}
					qsize = insize;
					while(psize > 0 || qsize > 0 && q != null) {
						if(psize == 0) {
							e = q;
							q = q.next;
							--qsize;
						} else if(qsize == 0 || q == null || q.names.length - p.names.length <= 0) {
							e = p;
							p = p.next;
							--psize;
						} else {
							e = q;
							q = q.next;
							--qsize;
						}
						if(tail != null) {
							tail.next = e;
						} else {
							list = e;
						}
						e.prev = tail;
						tail = e;
					}
					p = q;
				}
				tail.next = null;
				if(nmerges <= 1) {
					break;
				}
				insize *= 2;
			}
			list.prev = tail;
			tmp = list;
		}
		this.seqs.first = tmp;
		var count = 0;
		var current = this.seqs.first;
		var length = current.origSeq.length;
		var this1 = new Array(length);
		var v = this1;
		var _g11 = 0;
		var _g2 = current.origSeq.length;
		while(_g11 < _g2) {
			var i1 = _g11++;
			v[i1] = current.origSeq.charAt(i1);
		}
		while(current != null) {
			current.id = ++count;
			if(!current.isSample) {
				var i2 = 0;
				var _g_head = this.seqs.ipos.h;
				while(_g_head != null) {
					var val = _g_head.item;
					_g_head = _g_head.next;
					var pos = val;
					v[pos] = current.redSeq.charAt(i2++);
				}
				var b_b = "";
				var i3 = 0;
				var len = v.length;
				var _g12 = 0;
				var _g3 = len;
				while(_g12 < _g3) {
					var i4 = _g12++;
					b_b += Std.string(Std.string(v[i4]));
					if(i4 < len - 1) {
						b_b += "";
					}
				}
				current.origSeq = b_b;
			}
			var current2 = current.next;
			while(current2 != null && current2.isSample) {
				var o = current2.indNames;
				var result = new List();
				var _g_head1 = o.h;
				while(_g_head1 != null) {
					var val1 = _g_head1.item;
					_g_head1 = _g_head1.next;
					var e1 = val1;
					var result1 = false;
					var _g_head2 = current.indNames.h;
					while(_g_head2 != null) {
						var val2 = _g_head2.item;
						_g_head2 = _g_head2.next;
						var indName = val2;
						if(indName == e1) {
							result1 = true;
							break;
						}
					}
					if(result1) {
						result.add(e1);
					}
				}
				var l = result;
				if(l != null && !l.isEmpty()) {
					var l1 = new mj_Link();
					l1.to = current2;
					l1.names = l;
					current.linkedTo.add(l1);
				}
				if(l != null && !l.isEmpty()) {
					var l2 = new mj_Link();
					l2.to = current;
					l2.names = l;
					current2.linkedTo.add(l2);
				}
				current2 = current2.next;
			}
			current = current.next;
		}
		var l3 = new List();
		current = this.seqs.first;
		while(current != null && current.isSample) {
			if(current.spId == 0) {
				this.nextSpId++;
				current.spId = this.nextSpId;
				l3.clear();
				l3.add(current);
				while(!l3.isEmpty()) {
					var c = l3.pop();
					var _g_head3 = c.linkedTo.h;
					while(_g_head3 != null) {
						var val3 = _g_head3.item;
						_g_head3 = _g_head3.next;
						var n = val3;
						var n1 = n.to;
						if(n1.spId == 0) {
							n1.spId = this.nextSpId;
							l3.add(n1);
						} else if(n1.spId != this.nextSpId) {
							throw new js__$Boot_HaxeError("Something somewhere went terribly wrong (#1)!");
						}
					}
				}
			}
			current = current.next;
		}
		return this.seqs;
	}
	,getNrSeqs: function() {
		return this.seqCount;
	}
	,getNrDifSeqs: function() {
		var normal = 0;
		var median = 0;
		var current = this.seqs.first;
		while(current != null) {
			if(current.names.length != 0) {
				++normal;
			} else {
				++median;
			}
			current = current.next;
		}
		return normal + "+" + median;
	}
	,getSeqLength: function() {
		return this.seqs.origSeqLen;
	}
	,getNrInterestingPositions: function() {
		return this.seqs.ipos;
	}
	,getNrFFRs: function() {
		return this.nextSpId;
	}
	,countIndiv: function() {
		var l = new List();
		var current = this.seqs.first;
		var inLst = false;
		while(current != null && current.isSample) {
			var _g_head = current.indNames.h;
			while(_g_head != null) {
				var val = _g_head.item;
				_g_head = _g_head.next;
				var indName = val;
				inLst = false;
				var _g_head1 = l.h;
				while(_g_head1 != null) {
					var val1 = _g_head1.item;
					_g_head1 = _g_head1.next;
					var name = val1;
					if(name == indName) {
						inLst = true;
						break;
					}
				}
				if(!inLst) {
					l.add(indName);
				}
			}
			current = current.next;
		}
		return l.length;
	}
	,__class__: mj_MJAlgo
};
var mj_Median = function(s1,s2,s3,w,cDist) {
	this.makesSense = false;
	this.s1 = s1;
	this.s2 = s2;
	this.s3 = s3;
	this.dist = 0;
	this.diffPos = 0;
	this.meds = 1;
	var _g1 = 0;
	var _g = s1.length;
	while(_g1 < _g) {
		var pos = _g1++;
		if(s1.charAt(pos) == s2.charAt(pos) && s2.charAt(pos) == s3.charAt(pos)) {
			continue;
		}
		this.diffPos++;
		if(s1.charAt(pos) != s2.charAt(pos) && s2.charAt(pos) != s3.charAt(pos) && s1.charAt(pos) != s3.charAt(pos)) {
			this.dist += 2 * w[pos];
			this.meds *= 3;
			continue;
		}
		this.dist += w[pos];
	}
	this.makesSense = true;
};
$hxClasses["mj.Median"] = mj_Median;
mj_Median.__name__ = ["mj","Median"];
mj_Median.prototype = {
	s1: null
	,s2: null
	,s3: null
	,dist: null
	,diffPos: null
	,meds: null
	,makesSense: null
	,continueMedians: function(l,c,pos) {
		var _g_head = l.h;
		while(_g_head != null) {
			var val = _g_head.item;
			_g_head = _g_head.next;
			var e = val;
			e[pos] = c;
		}
	}
	,constructMediansOld: function() {
		var presult = new List();
		var length = this.s1.length;
		var this1 = new Array(length);
		presult.add(this1);
		var _g1 = 0;
		var _g = this.s1.length;
		while(_g1 < _g) {
			var pos = _g1++;
			if(this.s1.charAt(pos) == this.s2.charAt(pos)) {
				var c = this.s1.charAt(pos);
				var _g_head = presult.h;
				while(_g_head != null) {
					var val = _g_head.item;
					_g_head = _g_head.next;
					var e = val;
					e[pos] = c;
				}
				continue;
			}
			if(this.s1.charAt(pos) == this.s3.charAt(pos)) {
				var c1 = this.s1.charAt(pos);
				var _g_head1 = presult.h;
				while(_g_head1 != null) {
					var val1 = _g_head1.item;
					_g_head1 = _g_head1.next;
					var e1 = val1;
					e1[pos] = c1;
				}
				continue;
			}
			if(this.s2.charAt(pos) == this.s3.charAt(pos)) {
				var c2 = this.s2.charAt(pos);
				var _g_head2 = presult.h;
				while(_g_head2 != null) {
					var val2 = _g_head2.item;
					_g_head2 = _g_head2.next;
					var e2 = val2;
					e2[pos] = c2;
				}
				continue;
			}
			var limit = presult.length;
			var _g2 = 0;
			while(_g2 < 2) {
				var zzzzz = _g2++;
				var i = 0;
				var _g3_head = presult.h;
				while(_g3_head != null) {
					var val3 = _g3_head.item;
					_g3_head = _g3_head.next;
					var ele = val3;
					if(i < limit) {
						++i;
					} else {
						break;
					}
					var length1 = ele.length;
					var this2 = new Array(length1);
					var r = this2;
					haxe_ds__$Vector_Vector_$Impl_$.blit(ele,0,r,0,ele.length);
					presult.add(r);
				}
			}
			var pp = 0;
			var _g2_head = presult.h;
			while(_g2_head != null) {
				var val4 = _g2_head.item;
				_g2_head = _g2_head.next;
				var ele1 = val4;
				var c3 = pp < limit ? this.s1.charAt(pos) : pp < limit << 1 ? this.s2.charAt(pos) : this.s3.charAt(pos);
				ele1[pos] = c3;
				++pp;
			}
		}
		var result = new List();
		var _g_head3 = presult.h;
		while(_g_head3 != null) {
			var val5 = _g_head3.item;
			_g_head3 = _g_head3.next;
			var s = val5;
			var b_b = "";
			var i1 = 0;
			var len = s.length;
			var _g11 = 0;
			var _g3 = len;
			while(_g11 < _g3) {
				var i2 = _g11++;
				b_b += Std.string(Std.string(s[i2]));
				if(i2 < len - 1) {
					b_b += "";
				}
			}
			result.add(b_b);
		}
		return result;
	}
	,constructMedians: function() {
		if(this.meds <= 3) {
			var presult = new List();
			var length = this.s1.length;
			var this1 = new Array(length);
			presult.add(this1);
			var _g1 = 0;
			var _g = this.s1.length;
			while(_g1 < _g) {
				var pos = _g1++;
				if(this.s1.charAt(pos) == this.s2.charAt(pos)) {
					var c = this.s1.charAt(pos);
					var _g_head = presult.h;
					while(_g_head != null) {
						var val = _g_head.item;
						_g_head = _g_head.next;
						var e = val;
						e[pos] = c;
					}
					continue;
				}
				if(this.s1.charAt(pos) == this.s3.charAt(pos)) {
					var c1 = this.s1.charAt(pos);
					var _g_head1 = presult.h;
					while(_g_head1 != null) {
						var val1 = _g_head1.item;
						_g_head1 = _g_head1.next;
						var e1 = val1;
						e1[pos] = c1;
					}
					continue;
				}
				if(this.s2.charAt(pos) == this.s3.charAt(pos)) {
					var c2 = this.s2.charAt(pos);
					var _g_head2 = presult.h;
					while(_g_head2 != null) {
						var val2 = _g_head2.item;
						_g_head2 = _g_head2.next;
						var e2 = val2;
						e2[pos] = c2;
					}
					continue;
				}
				var limit = presult.length;
				var _g2 = 0;
				while(_g2 < 2) {
					var zzzzz = _g2++;
					var i = 0;
					var _g3_head = presult.h;
					while(_g3_head != null) {
						var val3 = _g3_head.item;
						_g3_head = _g3_head.next;
						var ele = val3;
						if(i < limit) {
							++i;
						} else {
							break;
						}
						var length1 = ele.length;
						var this2 = new Array(length1);
						var r = this2;
						haxe_ds__$Vector_Vector_$Impl_$.blit(ele,0,r,0,ele.length);
						presult.add(r);
					}
				}
				var pp = 0;
				var _g2_head = presult.h;
				while(_g2_head != null) {
					var val4 = _g2_head.item;
					_g2_head = _g2_head.next;
					var ele1 = val4;
					var c3 = pp < limit ? this.s1.charAt(pos) : pp < limit << 1 ? this.s2.charAt(pos) : this.s3.charAt(pos);
					ele1[pos] = c3;
					++pp;
				}
			}
			var result = new List();
			var _g_head3 = presult.h;
			while(_g_head3 != null) {
				var val5 = _g_head3.item;
				_g_head3 = _g_head3.next;
				var s = val5;
				var b_b = "";
				var i1 = 0;
				var len = s.length;
				var _g11 = 0;
				var _g3 = len;
				while(_g11 < _g3) {
					var i2 = _g11++;
					b_b += Std.string(Std.string(s[i2]));
					if(i2 < len - 1) {
						b_b += "";
					}
				}
				result.add(b_b);
			}
			return result;
		}
		var length2 = this.s1.length;
		var this3 = new Array(length2);
		var s1v = this3;
		var length3 = this.s1.length;
		var this4 = new Array(length3);
		var s2v = this4;
		var length4 = this.s1.length;
		var this5 = new Array(length4);
		var s3v = this5;
		var _g12 = 0;
		var _g4 = this.s1.length;
		while(_g12 < _g4) {
			var pos1 = _g12++;
			if(this.s1.charAt(pos1) == this.s2.charAt(pos1) && this.s2.charAt(pos1) == this.s3.charAt(pos1) || this.s1.charAt(pos1) != this.s2.charAt(pos1) && this.s2.charAt(pos1) != this.s3.charAt(pos1) && this.s1.charAt(pos1) != this.s3.charAt(pos1)) {
				s1v[pos1] = this.s1.charAt(pos1);
				s2v[pos1] = this.s2.charAt(pos1);
				s3v[pos1] = this.s3.charAt(pos1);
				continue;
			}
			var c4 = "";
			if(this.s1.charAt(pos1) == this.s2.charAt(pos1)) {
				c4 = this.s1.charAt(pos1);
			} else if(this.s2.charAt(pos1) == this.s3.charAt(pos1)) {
				c4 = this.s2.charAt(pos1);
			} else {
				c4 = this.s3.charAt(pos1);
			}
			s1v[pos1] = c4;
			s2v[pos1] = c4;
			s3v[pos1] = c4;
		}
		var result1 = new List();
		var b_b1 = "";
		var i3 = 0;
		var len1 = s1v.length;
		var _g13 = 0;
		var _g5 = len1;
		while(_g13 < _g5) {
			var i4 = _g13++;
			b_b1 += Std.string(Std.string(s1v[i4]));
			if(i4 < len1 - 1) {
				b_b1 += "";
			}
		}
		result1.add(b_b1);
		var b_b2 = "";
		var i5 = 0;
		var len2 = s2v.length;
		var _g14 = 0;
		var _g6 = len2;
		while(_g14 < _g6) {
			var i6 = _g14++;
			b_b2 += Std.string(Std.string(s2v[i6]));
			if(i6 < len2 - 1) {
				b_b2 += "";
			}
		}
		result1.add(b_b2);
		var b_b3 = "";
		var i7 = 0;
		var len3 = s3v.length;
		var _g15 = 0;
		var _g7 = len3;
		while(_g15 < _g7) {
			var i8 = _g15++;
			b_b3 += Std.string(Std.string(s3v[i8]));
			if(i8 < len3 - 1) {
				b_b3 += "";
			}
		}
		result1.add(b_b3);
		return result1;
	}
	,__class__: mj_Median
};
var mj_Seq = function() {
	this.names = new List();
	this.indNames = new List();
	this.linkedTo = new List();
	this.spId = 0;
};
$hxClasses["mj.Seq"] = mj_Seq;
mj_Seq.__name__ = ["mj","Seq"];
mj_Seq.calcHash = function(s) {
	var result = 7;
	var _g1 = 0;
	var _g = s.length;
	while(_g1 < _g) {
		var pos = _g1++;
		result = 31 * result + HxOverrides.cca(s,pos);
	}
	return result;
};
mj_Seq.getIndIdentifier = function(s) {
	var result = s;
	if(s != null) {
		var pos = s.lastIndexOf(mj_Seq.delimiter);
		if(pos != -1) {
			result = HxOverrides.substr(s,0,pos);
		}
	}
	return result;
};
mj_Seq.createSample = function(id,name,seq) {
	var result = new mj_Seq();
	result.id = id;
	if(name != null && name != "") {
		result.names.add(name);
		var result1 = name;
		if(name != null) {
			var pos = name.lastIndexOf(mj_Seq.delimiter);
			if(pos != -1) {
				result1 = HxOverrides.substr(name,0,pos);
			}
		}
		var indId = result1;
		var result2 = false;
		var _g_head = result.indNames.h;
		while(_g_head != null) {
			var val = _g_head.item;
			_g_head = _g_head.next;
			var indName = val;
			if(indName == indId) {
				result2 = true;
				break;
			}
		}
		if(!result2) {
			result.indNames.add(indId);
		}
	}
	result.origSeq = seq;
	var s = result.origSeq;
	var result3 = 7;
	var _g1 = 0;
	var _g = s.length;
	while(_g1 < _g) {
		var pos1 = _g1++;
		result3 = 31 * result3 + HxOverrides.cca(s,pos1);
	}
	result.hashCode = result3;
	result.isSample = true;
	return result;
};
mj_Seq.createMedian = function(id,seq) {
	var result = new mj_Seq();
	result.id = id;
	result.redSeq = seq;
	var s = result.redSeq;
	var result1 = 7;
	var _g1 = 0;
	var _g = s.length;
	while(_g1 < _g) {
		var pos = _g1++;
		result1 = 31 * result1 + HxOverrides.cca(s,pos);
	}
	result.hashCode = result1;
	result.isSample = false;
	return result;
};
mj_Seq.prototype = {
	next: null
	,prev: null
	,hashCode: null
	,nextWithHash: null
	,prevWithHash: null
	,calcHashForOrig: function() {
		var s = this.origSeq;
		var result = 7;
		var _g1 = 0;
		var _g = s.length;
		while(_g1 < _g) {
			var pos = _g1++;
			result = 31 * result + HxOverrides.cca(s,pos);
		}
		this.hashCode = result;
	}
	,calcHashForRed: function() {
		var s = this.redSeq;
		var result = 7;
		var _g1 = 0;
		var _g = s.length;
		while(_g1 < _g) {
			var pos = _g1++;
			result = 31 * result + HxOverrides.cca(s,pos);
		}
		this.hashCode = result;
	}
	,names: null
	,indNames: null
	,addName: function(s) {
		if(s != null && s != "") {
			this.names.add(s);
			var result = s;
			if(s != null) {
				var pos = s.lastIndexOf(mj_Seq.delimiter);
				if(pos != -1) {
					result = HxOverrides.substr(s,0,pos);
				}
			}
			var indId = result;
			var result1 = false;
			var _g_head = this.indNames.h;
			while(_g_head != null) {
				var val = _g_head.item;
				_g_head = _g_head.next;
				var indName = val;
				if(indName == indId) {
					result1 = true;
					break;
				}
			}
			if(!result1) {
				this.indNames.add(indId);
			}
		}
	}
	,hasIndIdentifier: function(s) {
		var result = false;
		var _g_head = this.indNames.h;
		while(_g_head != null) {
			var val = _g_head.item;
			_g_head = _g_head.next;
			var indName = val;
			if(indName == s) {
				result = true;
				break;
			}
		}
		return result;
	}
	,cmpIndIdentifiers: function(o) {
		var result = new List();
		var _g_head = o.h;
		while(_g_head != null) {
			var val = _g_head.item;
			_g_head = _g_head.next;
			var e = val;
			var result1 = false;
			var _g_head1 = this.indNames.h;
			while(_g_head1 != null) {
				var val1 = _g_head1.item;
				_g_head1 = _g_head1.next;
				var indName = val1;
				if(indName == e) {
					result1 = true;
					break;
				}
			}
			if(result1) {
				result.add(e);
			}
		}
		return result;
	}
	,origSeq: null
	,redSeq: null
	,reduceSequence: function(ipos) {
		var l = new List();
		var _g_head = ipos.h;
		while(_g_head != null) {
			var val = _g_head.item;
			_g_head = _g_head.next;
			var e = val;
			l.add(this.origSeq.charAt(e));
		}
		this.redSeq = l.join("");
	}
	,constructSeq: function(s,ipos) {
		var i = 0;
		var _g_head = ipos.h;
		while(_g_head != null) {
			var val = _g_head.item;
			_g_head = _g_head.next;
			var pos = val;
			s[pos] = this.redSeq.charAt(i++);
		}
		var b_b = "";
		var i1 = 0;
		var len = s.length;
		var _g1 = 0;
		var _g = len;
		while(_g1 < _g) {
			var i2 = _g1++;
			b_b += Std.string(Std.string(s[i2]));
			if(i2 < len - 1) {
				b_b += "";
			}
		}
		this.origSeq = b_b;
	}
	,isSample: null
	,id: null
	,spId: null
	,visitedId: null
	,connectedTo: null
	,nrConnections: null
	,linkedTo: null
	,addConnection: function(c) {
		c.next = this.connectedTo;
		this.connectedTo = c;
		this.nrConnections++;
	}
	,clearConnections: function() {
		this.nrConnections = 0;
		this.connectedTo = null;
	}
	,addLinkTo: function(o,names) {
		if(names != null && !names.isEmpty()) {
			var l = new mj_Link();
			l.to = o;
			l.names = names;
			this.linkedTo.add(l);
		}
	}
	,addLinkBySeq: function(os) {
		var o = os.indNames;
		var result = new List();
		var _g_head = o.h;
		while(_g_head != null) {
			var val = _g_head.item;
			_g_head = _g_head.next;
			var e = val;
			var result1 = false;
			var _g_head1 = this.indNames.h;
			while(_g_head1 != null) {
				var val1 = _g_head1.item;
				_g_head1 = _g_head1.next;
				var indName = val1;
				if(indName == e) {
					result1 = true;
					break;
				}
			}
			if(result1) {
				result.add(e);
			}
		}
		var l = result;
		if(l != null && !l.isEmpty()) {
			var l1 = new mj_Link();
			l1.to = os;
			l1.names = l;
			this.linkedTo.add(l1);
		}
		if(l != null && !l.isEmpty()) {
			var l2 = new mj_Link();
			l2.to = this;
			l2.names = l;
			os.linkedTo.add(l2);
		}
	}
	,__class__: mj_Seq
};
var mj_Seqs = function() {
	var this1 = new Array(100);
	this.hashTable = this1;
	this.nextSeqId = 1;
	this.origSeqLen = -1;
	this.ipos = new List();
	this.size = 0;
};
$hxClasses["mj.Seqs"] = mj_Seqs;
mj_Seqs.__name__ = ["mj","Seqs"];
mj_Seqs.prototype = {
	first: null
	,firstMed: null
	,last: null
	,size: null
	,hashTable: null
	,nextSeqId: null
	,origSeqLen: null
	,ipos: null
	,hashCodeToIndex: function(hc) {
		if(hc >= 0) {
			return hc % this.hashTable.length;
		} else {
			return -hc % this.hashTable.length;
		}
	}
	,rehash: function(newSize) {
		var this1 = new Array(newSize);
		this.hashTable = this1;
		var c = this.first;
		while(c != null) {
			c.nextWithHash = null;
			c.prevWithHash = null;
			var hc = c.hashCode;
			var index = hc >= 0 ? hc % this.hashTable.length : -hc % this.hashTable.length;
			if(this.hashTable[index] == null) {
				this.hashTable[index] = c;
			} else {
				c.nextWithHash = this.hashTable[index];
				this.hashTable[index].prevWithHash = c;
				this.hashTable[index] = c;
			}
			c = c.next;
		}
	}
	,addSeqToHashtable: function(s) {
		s.nextWithHash = null;
		s.prevWithHash = null;
		var hc = s.hashCode;
		var index = hc >= 0 ? hc % this.hashTable.length : -hc % this.hashTable.length;
		if(this.hashTable[index] == null) {
			this.hashTable[index] = s;
		} else {
			s.nextWithHash = this.hashTable[index];
			this.hashTable[index].prevWithHash = s;
			this.hashTable[index] = s;
		}
	}
	,addSeq: function(s) {
		this.size++;
		if(this.hashTable.length >> 1 < this.size) {
			var newSize = this.hashTable.length << 1;
			var this1 = new Array(newSize);
			this.hashTable = this1;
			var c = this.first;
			while(c != null) {
				c.nextWithHash = null;
				c.prevWithHash = null;
				var hc = c.hashCode;
				var index = hc >= 0 ? hc % this.hashTable.length : -hc % this.hashTable.length;
				if(this.hashTable[index] == null) {
					this.hashTable[index] = c;
				} else {
					c.nextWithHash = this.hashTable[index];
					this.hashTable[index].prevWithHash = c;
					this.hashTable[index] = c;
				}
				c = c.next;
			}
		}
		s.nextWithHash = null;
		s.prevWithHash = null;
		var hc1 = s.hashCode;
		var index1 = hc1 >= 0 ? hc1 % this.hashTable.length : -hc1 % this.hashTable.length;
		if(this.hashTable[index1] == null) {
			this.hashTable[index1] = s;
		} else {
			s.nextWithHash = this.hashTable[index1];
			this.hashTable[index1].prevWithHash = s;
			this.hashTable[index1] = s;
		}
		if(this.first == null) {
			this.first = s;
		} else {
			s.prev = this.last;
			this.last.next = s;
		}
		this.last = s;
		if(this.firstMed == null && !s.isSample) {
			this.firstMed = s;
		}
	}
	,addSample: function(name,seq) {
		if(this.origSeqLen != -1 && this.origSeqLen != seq.length) {
			throw new js__$Boot_HaxeError("Sequence differentiate in length! Please align sequences first!");
		} else if(seq.length == 0) {
			throw new js__$Boot_HaxeError("Cannot add empty string!");
		}
		this.origSeqLen = seq.length;
		var result = 7;
		var _g1 = 0;
		var _g = seq.length;
		while(_g1 < _g) {
			var pos = _g1++;
			result = 31 * result + HxOverrides.cca(seq,pos);
		}
		var hc = result;
		var hc1 = hc >= 0 ? hc % this.hashTable.length : -hc % this.hashTable.length;
		var s = this.hashTable[hc1];
		while(s != null) {
			if(s.origSeq == seq) {
				if(name != null && name != "") {
					s.names.add(name);
					var result1 = name;
					if(name != null) {
						var pos1 = name.lastIndexOf(mj_Seq.delimiter);
						if(pos1 != -1) {
							result1 = HxOverrides.substr(name,0,pos1);
						}
					}
					var indId = result1;
					var result2 = false;
					var _g_head = s.indNames.h;
					while(_g_head != null) {
						var val = _g_head.item;
						_g_head = _g_head.next;
						var indName = val;
						if(indName == indId) {
							result2 = true;
							break;
						}
					}
					if(!result2) {
						s.indNames.add(indId);
					}
				}
				return;
			}
			s = s.nextWithHash;
		}
		var id = this.nextSeqId++;
		var result3 = new mj_Seq();
		result3.id = id;
		if(name != null && name != "") {
			result3.names.add(name);
			var result4 = name;
			if(name != null) {
				var pos2 = name.lastIndexOf(mj_Seq.delimiter);
				if(pos2 != -1) {
					result4 = HxOverrides.substr(name,0,pos2);
				}
			}
			var indId1 = result4;
			var result5 = false;
			var _g_head1 = result3.indNames.h;
			while(_g_head1 != null) {
				var val1 = _g_head1.item;
				_g_head1 = _g_head1.next;
				var indName1 = val1;
				if(indName1 == indId1) {
					result5 = true;
					break;
				}
			}
			if(!result5) {
				result3.indNames.add(indId1);
			}
		}
		result3.origSeq = seq;
		var s1 = result3.origSeq;
		var result6 = 7;
		var _g11 = 0;
		var _g2 = s1.length;
		while(_g11 < _g2) {
			var pos3 = _g11++;
			result6 = 31 * result6 + HxOverrides.cca(s1,pos3);
		}
		result3.hashCode = result6;
		result3.isSample = true;
		var s2 = result3;
		this.size++;
		if(this.hashTable.length >> 1 < this.size) {
			var newSize = this.hashTable.length << 1;
			var this1 = new Array(newSize);
			this.hashTable = this1;
			var c = this.first;
			while(c != null) {
				c.nextWithHash = null;
				c.prevWithHash = null;
				var hc2 = c.hashCode;
				var index = hc2 >= 0 ? hc2 % this.hashTable.length : -hc2 % this.hashTable.length;
				if(this.hashTable[index] == null) {
					this.hashTable[index] = c;
				} else {
					c.nextWithHash = this.hashTable[index];
					this.hashTable[index].prevWithHash = c;
					this.hashTable[index] = c;
				}
				c = c.next;
			}
		}
		s2.nextWithHash = null;
		s2.prevWithHash = null;
		var hc3 = s2.hashCode;
		var index1 = hc3 >= 0 ? hc3 % this.hashTable.length : -hc3 % this.hashTable.length;
		if(this.hashTable[index1] == null) {
			this.hashTable[index1] = s2;
		} else {
			s2.nextWithHash = this.hashTable[index1];
			this.hashTable[index1].prevWithHash = s2;
			this.hashTable[index1] = s2;
		}
		if(this.first == null) {
			this.first = s2;
		} else {
			s2.prev = this.last;
			this.last.next = s2;
		}
		this.last = s2;
		if(this.firstMed == null && !s2.isSample) {
			this.firstMed = s2;
		}
	}
	,containsMed: function(seq) {
		var result = false;
		var result1 = 7;
		var _g1 = 0;
		var _g = seq.length;
		while(_g1 < _g) {
			var pos = _g1++;
			result1 = 31 * result1 + HxOverrides.cca(seq,pos);
		}
		var hc = result1;
		var hc1 = hc >= 0 ? hc % this.hashTable.length : -hc % this.hashTable.length;
		var s = this.hashTable[hc1];
		while(s != null) {
			if(s.redSeq == seq) {
				result = true;
				break;
			}
			s = s.nextWithHash;
		}
		return result;
	}
	,addMedian: function(seq) {
		var result = false;
		var result1 = 7;
		var _g1 = 0;
		var _g = seq.length;
		while(_g1 < _g) {
			var pos = _g1++;
			result1 = 31 * result1 + HxOverrides.cca(seq,pos);
		}
		var hc = result1;
		var hc1 = hc >= 0 ? hc % this.hashTable.length : -hc % this.hashTable.length;
		var s = this.hashTable[hc1];
		while(s != null) {
			if(s.redSeq == seq) {
				result = true;
				break;
			}
			s = s.nextWithHash;
		}
		if(!result) {
			var id = this.nextSeqId++;
			var result2 = new mj_Seq();
			result2.id = id;
			result2.redSeq = seq;
			var s1 = result2.redSeq;
			var result3 = 7;
			var _g11 = 0;
			var _g2 = s1.length;
			while(_g11 < _g2) {
				var pos1 = _g11++;
				result3 = 31 * result3 + HxOverrides.cca(s1,pos1);
			}
			result2.hashCode = result3;
			result2.isSample = false;
			var s2 = result2;
			this.size++;
			if(this.hashTable.length >> 1 < this.size) {
				var newSize = this.hashTable.length << 1;
				var this1 = new Array(newSize);
				this.hashTable = this1;
				var c = this.first;
				while(c != null) {
					c.nextWithHash = null;
					c.prevWithHash = null;
					var hc2 = c.hashCode;
					var index = hc2 >= 0 ? hc2 % this.hashTable.length : -hc2 % this.hashTable.length;
					if(this.hashTable[index] == null) {
						this.hashTable[index] = c;
					} else {
						c.nextWithHash = this.hashTable[index];
						this.hashTable[index].prevWithHash = c;
						this.hashTable[index] = c;
					}
					c = c.next;
				}
			}
			s2.nextWithHash = null;
			s2.prevWithHash = null;
			var hc3 = s2.hashCode;
			var index1 = hc3 >= 0 ? hc3 % this.hashTable.length : -hc3 % this.hashTable.length;
			if(this.hashTable[index1] == null) {
				this.hashTable[index1] = s2;
			} else {
				s2.nextWithHash = this.hashTable[index1];
				this.hashTable[index1].prevWithHash = s2;
				this.hashTable[index1] = s2;
			}
			if(this.first == null) {
				this.first = s2;
			} else {
				s2.prev = this.last;
				this.last.next = s2;
			}
			this.last = s2;
			if(this.firstMed == null && !s2.isSample) {
				this.firstMed = s2;
			}
		}
	}
	,removeMed: function(s) {
		s.linkedTo.clear();
		if(this.firstMed == s) {
			this.firstMed = s.next;
		}
		if(this.last == s) {
			this.last = s.prev;
		}
		var hc = s.hashCode;
		var index = hc >= 0 ? hc % this.hashTable.length : -hc % this.hashTable.length;
		if(this.hashTable[index] == s) {
			this.hashTable[index] = s.nextWithHash;
		}
		if(s.next != null) {
			s.next.prev = s.prev;
		}
		if(s.prev != null) {
			s.prev.next = s.next;
		}
		if(s.nextWithHash != null) {
			s.nextWithHash.prevWithHash = s.prevWithHash;
		}
		if(s.prevWithHash != null) {
			s.prevWithHash.nextWithHash = s.nextWithHash;
		}
		this.size--;
		s.next = null;
		s.prev = null;
		s.nextWithHash = null;
		s.prevWithHash = null;
	}
	,finishedAddingSamples: function() {
		if(this.origSeqLen <= 1) {
			throw new js__$Boot_HaxeError("Need at least two sampled sequences!");
		}
		var _g1 = 0;
		var _g = this.origSeqLen;
		while(_g1 < _g) {
			var pos = _g1++;
			var current = this.first.next;
			while(current != null) {
				if(this.first.origSeq.charAt(pos) != current.origSeq.charAt(pos)) {
					this.ipos.add(pos);
					break;
				}
				current = current.next;
			}
		}
		var current1 = this.first;
		while(current1 != null) {
			var ipos = this.ipos;
			var l = new List();
			var _g_head = ipos.h;
			while(_g_head != null) {
				var val = _g_head.item;
				_g_head = _g_head.next;
				var e = val;
				l.add(current1.origSeq.charAt(e));
			}
			current1.redSeq = l.join("");
			var s = current1.redSeq;
			var result = 7;
			var _g11 = 0;
			var _g2 = s.length;
			while(_g11 < _g2) {
				var pos1 = _g11++;
				result = 31 * result + HxOverrides.cca(s,pos1);
			}
			current1.hashCode = result;
			current1 = current1.next;
		}
		var newSize = this.hashTable.length << 1;
		var this1 = new Array(newSize);
		this.hashTable = this1;
		var c = this.first;
		while(c != null) {
			c.nextWithHash = null;
			c.prevWithHash = null;
			var hc = c.hashCode;
			var index = hc >= 0 ? hc % this.hashTable.length : -hc % this.hashTable.length;
			if(this.hashTable[index] == null) {
				this.hashTable[index] = c;
			} else {
				c.nextWithHash = this.hashTable[index];
				this.hashTable[index].prevWithHash = c;
				this.hashTable[index] = c;
			}
			c = c.next;
		}
	}
	,printTxt: function(printer) {
		printer.printString("#Calculated via HaplowebMaker version ");
		printer.printString(mj_MJAlgo.version);
		printer.printString(printer.newline);
		var c = this.first;
		while(c != null) {
			printer.printString(c.isSample ? "SAMPLED_SEQUENCE" : "MEDIAN_VECTOR");
			printer.printString(printer.newline);
			printer.printString(printer.indent);
			printer.printString("ID ");
			printer.printString("" + c.id);
			printer.printString(printer.newline);
			if(c.isSample) {
				printer.printString(printer.indent);
				printer.printString("FFR_ID ");
				printer.printString("" + c.spId);
				printer.printString(printer.newline);
			}
			printer.printString(printer.indent);
			printer.printString("SEQUENCE ");
			printer.printString("" + c.origSeq);
			printer.printString(printer.newline);
			if(c.names != null && c.names.length > 0) {
				printer.printString(printer.indent);
				printer.printString("NB_NAMES ");
				printer.printString("" + c.names.length);
				printer.printString(printer.newline);
				printer.printString(printer.indent);
				printer.printString("NAMES");
				printer.printString(printer.newline);
				var _g_head = c.names.h;
				while(_g_head != null) {
					var val = _g_head.item;
					_g_head = _g_head.next;
					var name = val;
					printer.printString(printer.indent);
					printer.printString(printer.indent);
					printer.printString(name);
					printer.printString(printer.newline);
				}
			}
			if(c.connectedTo != null && c.nrConnections > 0) {
				printer.printString(printer.indent);
				printer.printString("CONNECTED_TO ");
				printer.printString(printer.newline);
				var con = c.connectedTo;
				while(con != null) {
					printer.printString(printer.indent);
					printer.printString(printer.indent);
					printer.printString("ID " + con.connectedTo.id);
					printer.printString(" COSTS " + con.dist + " @");
					var _g1 = 0;
					var _g = c.origSeq.length;
					while(_g1 < _g) {
						var pos = _g1++;
						if(c.origSeq.charAt(pos) != con.connectedTo.origSeq.charAt(pos)) {
							printer.printString(" " + (pos + printer.countingOffset));
						}
					}
					printer.printString(printer.newline);
					con = con.next;
				}
			}
			if(c.linkedTo != null && c.linkedTo.length > 0) {
				printer.printString(printer.indent);
				printer.printString("LINKED_TO ");
				printer.printString(printer.newline);
				var _g_head1 = c.linkedTo.h;
				while(_g_head1 != null) {
					var val1 = _g_head1.item;
					_g_head1 = _g_head1.next;
					var link = val1;
					printer.printString(printer.indent);
					printer.printString(printer.indent);
					printer.printString("ID " + link.to.id + " COUNT " + link.names.length);
					printer.printString(printer.newline);
				}
			}
			c = c.next;
		}
		printer.close();
	}
	,printOldTxt: function(printer) {
		printer.printString("+");
		var _g_head = this.ipos.h;
		while(_g_head != null) {
			var val = _g_head.item;
			_g_head = _g_head.next;
			var e = val;
			printer.printString(" " + e);
		}
		printer.printString(printer.newline);
		var c = this.first;
		while(c != null) {
			printer.printString("+NODE " + (c.id - 1) + " " + (c.names == null ? 0 : c.names.length));
			printer.printString(printer.newline);
			if(c.names != null && c.names.length > 0) {
				var _g_head1 = c.names.h;
				while(_g_head1 != null) {
					var val1 = _g_head1.item;
					_g_head1 = _g_head1.next;
					var name = val1;
					printer.printString("NAME ");
					printer.printString(name);
					printer.printString(printer.newline);
				}
			}
			printer.printString("SEQ " + c.origSeq);
			printer.printString(printer.newline);
			c = c.next;
		}
		var c1 = this.first;
		while(c1 != null) {
			if(c1.connectedTo != null && c1.nrConnections > 0) {
				var con = c1.connectedTo;
				while(con != null) {
					if(c1.id < con.connectedTo.id) {
						var l = new List();
						var _g1 = 0;
						var _g = c1.origSeq.length;
						while(_g1 < _g) {
							var pos = _g1++;
							if(c1.origSeq.charAt(pos) != con.connectedTo.origSeq.charAt(pos)) {
								l.add(pos);
							}
						}
						printer.printString("+CON " + (c1.id - 1) + " " + (con.connectedTo.id - 1) + " " + con.dist + " " + l.length);
						printer.printString(printer.newline);
						printer.printString("POS");
						var _g_head2 = l.h;
						while(_g_head2 != null) {
							var val2 = _g_head2.item;
							_g_head2 = _g_head2.next;
							var e1 = val2;
							printer.printString(" " + e1);
						}
						printer.printString(printer.newline);
					}
					con = con.next;
				}
			}
			if(c1.linkedTo != null && c1.linkedTo.length > 0) {
				var _g_head3 = c1.linkedTo.h;
				while(_g_head3 != null) {
					var val3 = _g_head3.item;
					_g_head3 = _g_head3.next;
					var link = val3;
					if(c1.id - 1 > link.to.id - 1) {
						printer.printString("+LINK " + (c1.id - 1) + " " + (link.to.id - 1) + " " + link.names.length + " " + link.names.length + " " + link.names.length);
						printer.printString(printer.newline);
					}
				}
			}
			c1 = c1.next;
		}
	}
	,__class__: mj_Seqs
};
var util_StdOutPrinter = function() {
	this.indent = "  ";
	this.newline = "\n";
	this.countingOffset = 1;
};
$hxClasses["util.StdOutPrinter"] = util_StdOutPrinter;
util_StdOutPrinter.__name__ = ["util","StdOutPrinter"];
util_StdOutPrinter.__interfaces__ = [interfaces_Printer];
util_StdOutPrinter.prototype = {
	countingOffset: null
	,newline: null
	,indent: null
	,printString: function(s) {
		haxe_Log.trace(s,{ fileName : "StdOutPrinter.hx", lineNumber : 15, className : "util.StdOutPrinter", methodName : "printString"});
	}
	,close: function() {
	}
	,__class__: util_StdOutPrinter
};
function $iterator(o) { if( o instanceof Array ) return function() { return HxOverrides.iter(o); }; return typeof(o.iterator) == 'function' ? $bind(o,o.iterator) : o.iterator; }
var $_, $fid = 0;
function $bind(o,m) { if( m == null ) return null; if( m.__id__ == null ) m.__id__ = $fid++; var f; if( o.hx__closures__ == null ) o.hx__closures__ = {}; else f = o.hx__closures__[m.__id__]; if( f == null ) { f = function(){ return f.method.apply(f.scope, arguments); }; f.scope = o; f.method = m; o.hx__closures__[m.__id__] = f; } return f; }
function $arrayPush(x) { this.push(x); }
$hxClasses["Math"] = Math;
String.prototype.__class__ = $hxClasses["String"] = String;
String.__name__ = ["String"];
$hxClasses["Array"] = Array;
Array.__name__ = ["Array"];
Date.prototype.__class__ = $hxClasses["Date"] = Date;
Date.__name__ = ["Date"];
var Int = $hxClasses["Int"] = { __name__ : ["Int"]};
var Dynamic = $hxClasses["Dynamic"] = { __name__ : ["Dynamic"]};
var Float = $hxClasses["Float"] = Number;
Float.__name__ = ["Float"];
var Bool = $hxClasses["Bool"] = Boolean;
Bool.__ename__ = ["Bool"];
var Class = $hxClasses["Class"] = { __name__ : ["Class"]};
var Enum = { };
var Void = $hxClasses["Void"] = { __ename__ : ["Void"]};
js_Boot.__toStr = ({ }).toString;
mj_MJAlgo.version = "1.0.2";
mj_Seq.delimiter = "_";
