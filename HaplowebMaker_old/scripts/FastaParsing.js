// Generated by Haxe 3.4.2
"use strict";
function $extend(from, fields) {
	function Inherit() {} Inherit.prototype = from; var proto = new Inherit();
	for (var name in fields) proto[name] = fields[name];
	if( fields.toString !== Object.prototype.toString ) proto.toString = fields.toString;
	return proto;
}
var HxOverrides = function() { };
HxOverrides.cca = function(s,index) {
	var x = s.charCodeAt(index);
	if(x != x) {
		return undefined;
	}
	return x;
};
HxOverrides.substr = function(s,pos,len) {
	if(len == null) {
		len = s.length;
	} else if(len < 0) {
		if(pos == 0) {
			len = s.length + len;
		} else {
			return "";
		}
	}
	return s.substr(pos,len);
};
var List = function() {
	this.length = 0;
};
List.prototype = {
	add: function(item) {
		var x = new _$List_ListNode(item,null);
		if(this.h == null) {
			this.h = x;
		} else {
			this.q.next = x;
		}
		this.q = x;
		this.length++;
	}
};
var _$List_ListNode = function(item,next) {
	this.item = item;
	this.next = next;
};
var js__$Boot_HaxeError = function(val) {
	Error.call(this);
	this.val = val;
	this.message = String(val);
	if(Error.captureStackTrace) {
		Error.captureStackTrace(this,js__$Boot_HaxeError);
	}
};
js__$Boot_HaxeError.wrap = function(val) {
	if((val instanceof Error)) {
		return val;
	} else {
		return new js__$Boot_HaxeError(val);
	}
};
js__$Boot_HaxeError.__super__ = Error;
js__$Boot_HaxeError.prototype = $extend(Error.prototype,{
});
var parsing_FastaParser = function() { };
parsing_FastaParser.parseFasta = function(fileContent) {
	var faSeqs = new List();
	var lines = fileContent.split("\n");
	var header = null;
	var content = null;
	var lineNo = 0;
	var _g = 0;
	while(_g < lines.length) {
		var line = lines[_g];
		++_g;
		++lineNo;
		var end = line.length;
		while(true) {
			var line1;
			if(end > 0) {
				var cCode = HxOverrides.cca(line,end - 1);
				var result = false;
				var _g1 = 0;
				var _g11 = [9,10,11,12,13,32,133,160,5760,8192,8192,8193,8194,8195,8196,8197,8198,8199,8200,8201,8202,8232,8233,8239,8287,12288,6158,8203,8204,8205,8288,65279];
				while(_g1 < _g11.length) {
					var ele = _g11[_g1];
					++_g1;
					if(ele == cCode) {
						result = true;
						break;
					}
				}
				line1 = result;
			} else {
				line1 = false;
			}
			if(!line1) {
				break;
			}
			--end;
		}
		var s = line.substring(0,end);
		var begin = 0;
		var sLen = s.length;
		while(true) {
			var line2;
			if(begin < sLen) {
				var cCode1 = HxOverrides.cca(s,begin);
				var result1 = false;
				var _g2 = 0;
				var _g12 = [9,10,11,12,13,32,133,160,5760,8192,8192,8193,8194,8195,8196,8197,8198,8199,8200,8201,8202,8232,8233,8239,8287,12288,6158,8203,8204,8205,8288,65279];
				while(_g2 < _g12.length) {
					var ele1 = _g12[_g2];
					++_g2;
					if(ele1 == cCode1) {
						result1 = true;
						break;
					}
				}
				line2 = result1;
			} else {
				line2 = false;
			}
			if(!line2) {
				break;
			}
			++begin;
		}
		line = HxOverrides.substr(s,begin,null);
		if(line == null || line == "" || line.charAt(0) == ";" || line.charAt(0) == "#") {
			continue;
		}
		if(line.charAt(0) == ">") {
			if(header != null) {
				if(content == null) {
					throw new js__$Boot_HaxeError("Missing content for sequence \"" + header + "\" in line " + lineNo);
				}
				faSeqs.add(new util_Pair(header,content));
			} else if(content != null) {
				throw new js__$Boot_HaxeError("Missing header for content previous to line " + lineNo);
			}
			var s1 = HxOverrides.substr(line,1,null);
			var begin1 = 0;
			var sLen1 = s1.length;
			while(true) {
				var header1;
				if(begin1 < sLen1) {
					var cCode2 = HxOverrides.cca(s1,begin1);
					var result2 = false;
					var _g3 = 0;
					var _g13 = [9,10,11,12,13,32,133,160,5760,8192,8192,8193,8194,8195,8196,8197,8198,8199,8200,8201,8202,8232,8233,8239,8287,12288,6158,8203,8204,8205,8288,65279];
					while(_g3 < _g13.length) {
						var ele2 = _g13[_g3];
						++_g3;
						if(ele2 == cCode2) {
							result2 = true;
							break;
						}
					}
					header1 = result2;
				} else {
					header1 = false;
				}
				if(!header1) {
					break;
				}
				++begin1;
			}
			header = HxOverrides.substr(s1,begin1,null);
			content = null;
		} else if(content == null) {
			content = line;
		} else {
			content += line;
		}
	}
	if(header != null) {
		if(content == null) {
			throw new js__$Boot_HaxeError("Missing content for sequence \"" + header + "\" in line " + lineNo);
		}
		faSeqs.add(new util_Pair(header,content));
	}
	return faSeqs;
};
parsing_FastaParser.main = function() {
};
var parsing_Parse = function() { };
parsing_Parse.startsWith = function(t,s) {
	return HxOverrides.substr(t,0,s.length) == s;
};
parsing_Parse.isWhitespace = function(s,pos) {
	var cCode = HxOverrides.cca(s,pos);
	var result = false;
	var _g = 0;
	var _g1 = [9,10,11,12,13,32,133,160,5760,8192,8192,8193,8194,8195,8196,8197,8198,8199,8200,8201,8202,8232,8233,8239,8287,12288,6158,8203,8204,8205,8288,65279];
	while(_g < _g1.length) {
		var ele = _g1[_g];
		++_g;
		if(ele == cCode) {
			result = true;
			break;
		}
	}
	return result;
};
parsing_Parse.stripStringBegin = function(s) {
	var begin = 0;
	var sLen = s.length;
	while(true) {
		var tmp;
		if(begin < sLen) {
			var cCode = HxOverrides.cca(s,begin);
			var result = false;
			var _g = 0;
			var _g1 = [9,10,11,12,13,32,133,160,5760,8192,8192,8193,8194,8195,8196,8197,8198,8199,8200,8201,8202,8232,8233,8239,8287,12288,6158,8203,8204,8205,8288,65279];
			while(_g < _g1.length) {
				var ele = _g1[_g];
				++_g;
				if(ele == cCode) {
					result = true;
					break;
				}
			}
			tmp = result;
		} else {
			tmp = false;
		}
		if(!tmp) {
			break;
		}
		++begin;
	}
	return HxOverrides.substr(s,begin,null);
};
parsing_Parse.stripStringEnd = function(s) {
	var end = s.length;
	while(true) {
		var tmp;
		if(end > 0) {
			var cCode = HxOverrides.cca(s,end - 1);
			var result = false;
			var _g = 0;
			var _g1 = [9,10,11,12,13,32,133,160,5760,8192,8192,8193,8194,8195,8196,8197,8198,8199,8200,8201,8202,8232,8233,8239,8287,12288,6158,8203,8204,8205,8288,65279];
			while(_g < _g1.length) {
				var ele = _g1[_g];
				++_g;
				if(ele == cCode) {
					result = true;
					break;
				}
			}
			tmp = result;
		} else {
			tmp = false;
		}
		if(!tmp) {
			break;
		}
		--end;
	}
	return s.substring(0,end);
};
parsing_Parse.stripString = function(s) {
	var end = s.length;
	while(true) {
		var tmp;
		if(end > 0) {
			var cCode = HxOverrides.cca(s,end - 1);
			var result = false;
			var _g = 0;
			var _g1 = [9,10,11,12,13,32,133,160,5760,8192,8192,8193,8194,8195,8196,8197,8198,8199,8200,8201,8202,8232,8233,8239,8287,12288,6158,8203,8204,8205,8288,65279];
			while(_g < _g1.length) {
				var ele = _g1[_g];
				++_g;
				if(ele == cCode) {
					result = true;
					break;
				}
			}
			tmp = result;
		} else {
			tmp = false;
		}
		if(!tmp) {
			break;
		}
		--end;
	}
	var s1 = s.substring(0,end);
	var begin = 0;
	var sLen = s1.length;
	while(true) {
		var tmp1;
		if(begin < sLen) {
			var cCode1 = HxOverrides.cca(s1,begin);
			var result1 = false;
			var _g2 = 0;
			var _g11 = [9,10,11,12,13,32,133,160,5760,8192,8192,8193,8194,8195,8196,8197,8198,8199,8200,8201,8202,8232,8233,8239,8287,12288,6158,8203,8204,8205,8288,65279];
			while(_g2 < _g11.length) {
				var ele1 = _g11[_g2];
				++_g2;
				if(ele1 == cCode1) {
					result1 = true;
					break;
				}
			}
			tmp1 = result1;
		} else {
			tmp1 = false;
		}
		if(!tmp1) {
			break;
		}
		++begin;
	}
	return HxOverrides.substr(s1,begin,null);
};
var util_Pair = function(u,v) {
	this.second = null;
	this.first = null;
	this.first = u;
	this.second = v;
};
util_Pair.prototype = {
	swapFirst: function(p) {
		var tmp = this.first;
		this.first = p.first;
		p.first = tmp;
	}
	,swapSecond: function(p) {
		var tmp = this.second;
		this.second = p.second;
		p.second = tmp;
	}
	,swap: function(p) {
		this.swapFirst(p);
		this.swapSecond(p);
	}
};
