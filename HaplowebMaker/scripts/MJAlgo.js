// Generated by Haxe 3.4.2
//(function () {
"use strict";
function $extend(from, fields) {
	function Inherit() {} Inherit.prototype = from; var proto = new Inherit();
	for (var name in fields) proto[name] = fields[name];
	if( fields.toString !== Object.prototype.toString ) proto.toString = fields.toString;
	return proto;
}
var HxOverrides = function() { };
HxOverrides.__name__ = true;
HxOverrides.cca = function(s,index) {
	var x = s.charCodeAt(index);
	if(x != x) {
		return undefined;
	}
	return x;
};
HxOverrides.substr = function(s,pos,len) {
	if(len == null) {
		len = s.length;
	} else if(len < 0) {
		if(pos == 0) {
			len = s.length + len;
		} else {
			return "";
		}
	}
	return s.substr(pos,len);
};
var List = function() {
	this.length = 0;
};
List.__name__ = true;
List.prototype = {
	add: function(item) {
		var x = new _$List_ListNode(item,null);
		if(this.h == null) {
			this.h = x;
		} else {
			this.q.next = x;
		}
		this.q = x;
		this.length++;
	}
	,first: function() {
		if(this.h == null) {
			return null;
		} else {
			return this.h.item;
		}
	}
	,last: function() {
		if(this.q == null) {
			return null;
		} else {
			return this.q.item;
		}
	}
	,pop: function() {
		if(this.h == null) {
			return null;
		}
		var x = this.h.item;
		this.h = this.h.next;
		if(this.h == null) {
			this.q = null;
		}
		this.length--;
		return x;
	}
	,isEmpty: function() {
		return this.h == null;
	}
	,clear: function() {
		this.h = null;
		this.q = null;
		this.length = 0;
	}
	,join: function(sep) {
		var s_b = "";
		var first = true;
		var l = this.h;
		while(l != null) {
			if(first) {
				first = false;
			} else {
				s_b += sep == null ? "null" : "" + sep;
			}
			s_b += Std.string(l.item);
			l = l.next;
		}
		return s_b;
	}
};
var _$List_ListNode = function(item,next) {
	this.item = item;
	this.next = next;
};
_$List_ListNode.__name__ = true;
Math.__name__ = true;
var Std = function() { };
Std.__name__ = true;
Std.string = function(s) {
	return js_Boot.__string_rec(s,"");
};
var haxe_ds__$Vector_Vector_$Impl_$ = {};
haxe_ds__$Vector_Vector_$Impl_$.__name__ = true;
haxe_ds__$Vector_Vector_$Impl_$.blit = function(src,srcPos,dest,destPos,len) {
	if(src == dest) {
		if(srcPos < destPos) {
			var i = srcPos + len;
			var j = destPos + len;
			var _g1 = 0;
			var _g = len;
			while(_g1 < _g) {
				var k = _g1++;
				--i;
				--j;
				src[j] = src[i];
			}
		} else if(srcPos > destPos) {
			var i1 = srcPos;
			var j1 = destPos;
			var _g11 = 0;
			var _g2 = len;
			while(_g11 < _g2) {
				var k1 = _g11++;
				src[j1] = src[i1];
				++i1;
				++j1;
			}
		}
	} else {
		var _g12 = 0;
		var _g3 = len;
		while(_g12 < _g3) {
			var i2 = _g12++;
			dest[destPos + i2] = src[srcPos + i2];
		}
	}
};
var interfaces_Printer = function() {
	this.indent = "  ";
	this.newline = "\n";
	this.countingOffset = 1;
};
interfaces_Printer.__name__ = true;
var js__$Boot_HaxeError = function(val) {
	Error.call(this);
	this.val = val;
	this.message = String(val);
	if(Error.captureStackTrace) {
		Error.captureStackTrace(this,js__$Boot_HaxeError);
	}
};
js__$Boot_HaxeError.__name__ = true;
js__$Boot_HaxeError.wrap = function(val) {
	if((val instanceof Error)) {
		return val;
	} else {
		return new js__$Boot_HaxeError(val);
	}
};
js__$Boot_HaxeError.__super__ = Error;
js__$Boot_HaxeError.prototype = $extend(Error.prototype,{
});
var js_Boot = function() { };
js_Boot.__name__ = true;
js_Boot.__string_rec = function(o,s) {
	if(o == null) {
		return "null";
	}
	if(s.length >= 5) {
		return "<...>";
	}
	var t = typeof(o);
	if(t == "function" && (o.__name__ || o.__ename__)) {
		t = "object";
	}
	switch(t) {
	case "function":
		return "<function>";
	case "object":
		if(o instanceof Array) {
			if(o.__enum__) {
				if(o.length == 2) {
					return o[0];
				}
				var str = o[0] + "(";
				s += "\t";
				var _g1 = 2;
				var _g = o.length;
				while(_g1 < _g) {
					var i = _g1++;
					if(i != 2) {
						str += "," + js_Boot.__string_rec(o[i],s);
					} else {
						str += js_Boot.__string_rec(o[i],s);
					}
				}
				return str + ")";
			}
			var l = o.length;
			var i1;
			var str1 = "[";
			s += "\t";
			var _g11 = 0;
			var _g2 = l;
			while(_g11 < _g2) {
				var i2 = _g11++;
				str1 += (i2 > 0 ? "," : "") + js_Boot.__string_rec(o[i2],s);
			}
			str1 += "]";
			return str1;
		}
		var tostr;
		try {
			tostr = o.toString;
		} catch( e ) {
			return "???";
		}
		if(tostr != null && tostr != Object.toString && typeof(tostr) == "function") {
			var s2 = o.toString();
			if(s2 != "[object Object]") {
				return s2;
			}
		}
		var k = null;
		var str2 = "{\n";
		s += "\t";
		var hasp = o.hasOwnProperty != null;
		for( var k in o ) {
		if(hasp && !o.hasOwnProperty(k)) {
			continue;
		}
		if(k == "prototype" || k == "__class__" || k == "__super__" || k == "__interfaces__" || k == "__properties__") {
			continue;
		}
		if(str2.length != 2) {
			str2 += ", \n";
		}
		str2 += s + k + " : " + js_Boot.__string_rec(o[k],s);
		}
		s = s.substring(1);
		str2 += "\n" + s + "}";
		return str2;
	case "string":
		return o;
	default:
		return String(o);
	}
};
var mj_Connection = function(conT,dist) {
	this.connectedTo = conT;
	this.dist = dist;
};
mj_Connection.__name__ = true;
var mj_Delta = function(s1,s2,dist) {
	this.s1 = s1;
	this.s2 = s2;
	this.dist = dist;
};
mj_Delta.__name__ = true;
var mj_Link = function() {
};
mj_Link.__name__ = true;
mj_Link.prototype = {
	countInd: function() {
		return this.names.length;
	}
};
var mj_MJAlgo = function() {
	this.seqs = new mj_Seqs();
	this.rdeltas = new List();
};
mj_MJAlgo.__name__ = true;
mj_MJAlgo.main = function() {
};
mj_MJAlgo.prototype = {
	distStr: function(s1,s2) {
		var result = 0.0;
		var _g1 = 0;
		var _g = s1.length;
		while(_g1 < _g) {
			var pos = _g1++;
			if(s1.charAt(pos) != s2.charAt(pos)) {
				result += this.rweights[pos];
			}
		}
		return result;
	}
	,addSequence: function(name,seq) {
		this.seqs.addSample(name,seq);
	}
	,finishedAddingSequences: function() {
		if(this.seqs.size == 0) {
			throw new js__$Boot_HaxeError("Need at least one sequence to run the mj algorithm on ...");
		}
		var _this = this.seqs;
		if(_this.origSeqLen <= 1) {
			throw new js__$Boot_HaxeError("Need at least two sampled sequences!");
		}
		var _g1 = 0;
		var _g = _this.origSeqLen;
		while(_g1 < _g) {
			var pos = _g1++;
			var current = _this.first.next;
			while(current != null) {
				if(_this.first.origSeq.charAt(pos) != current.origSeq.charAt(pos)) {
					_this.ipos.add(pos);
					break;
				}
				current = current.next;
			}
		}
		var current1 = _this.first;
		while(current1 != null) {
			var ipos = _this.ipos;
			var l = new List();
			var _g_head = ipos.h;
			while(_g_head != null) {
				var val = _g_head.item;
				_g_head = _g_head.next;
				var e = val;
				l.add(current1.origSeq.charAt(e));
			}
			current1.redSeq = l.join("");
			var s = current1.redSeq;
			var result = 7;
			var _g11 = 0;
			var _g2 = s.length;
			while(_g11 < _g2) {
				var pos1 = _g11++;
				result = 31 * result + HxOverrides.cca(s,pos1);
			}
			current1.hashCode = result;
			current1 = current1.next;
		}
		var newSize = _this.hashTable.length << 1;
		var this1 = new Array(newSize);
		_this.hashTable = this1;
		var c = _this.first;
		while(c != null) {
			c.nextWithHash = null;
			c.prevWithHash = null;
			var hc = c.hashCode;
			var index = hc >= 0 ? hc % _this.hashTable.length : -hc % _this.hashTable.length;
			if(_this.hashTable[index] == null) {
				_this.hashTable[index] = c;
			} else {
				c.nextWithHash = _this.hashTable[index];
				_this.hashTable[index].prevWithHash = c;
				_this.hashTable[index] = c;
			}
			c = c.next;
		}
		if(this.weights == null) {
			var length = this.seqs.ipos.length;
			var this2 = new Array(length);
			this.rweights = this2;
			var _g12 = 0;
			var _g3 = this.seqs.ipos.length;
			while(_g12 < _g3) {
				var i = _g12++;
				this.rweights[i] = 1;
			}
		} else {
			if(this.weights.length != this.seqs.first.origSeq.length) {
				throw new js__$Boot_HaxeError("Expected " + this.seqs.first.origSeq.length + " weights but got " + this.weights.length + " weights!");
			}
			var length1 = this.seqs.ipos.length;
			var this3 = new Array(length1);
			this.rweights = this3;
			var iii = 0;
			var _g_head1 = this.seqs.ipos.h;
			while(_g_head1 != null) {
				var val1 = _g_head1.item;
				_g_head1 = _g_head1.next;
				var e1 = val1;
				this.rweights[iii++] = this.weights[e1];
			}
		}
	}
	,runMJ: function(epsilon) {
		if(this.seqs.size > 1) {
			var i;
			while(true) {
				var deltas = new List();
				var current = this.seqs.first;
				while(current != null) {
					var current2 = current.next;
					while(current2 != null) {
						var s1 = current.redSeq;
						var s2 = current2.redSeq;
						var result = 0.0;
						var _g1 = 0;
						var _g = s1.length;
						while(_g1 < _g) {
							var pos = _g1++;
							if(s1.charAt(pos) != s2.charAt(pos)) {
								result += this.rweights[pos];
							}
						}
						var d = new mj_Delta(current,current2,result);
						deltas.add(d);
						current2 = current2.next;
					}
					current = current.next;
				}
				var sortedLists = new List();
				var _g_head = deltas.h;
				while(_g_head != null) {
					var val = _g_head.item;
					_g_head = _g_head.next;
					var delta = val;
					if(sortedLists.last() != null && sortedLists.last().last() != null && sortedLists.last().last().dist <= delta.dist) {
						sortedLists.last().add(delta);
					} else {
						var newL = new List();
						newL.add(delta);
						sortedLists.add(newL);
					}
				}
				while(sortedLists.length > 1) {
					var l1 = sortedLists.pop();
					var l2 = sortedLists.pop();
					var nL = new List();
					while(!l1.isEmpty() && !l2.isEmpty()) if(l1.first().dist <= l2.first().dist) {
						nL.add(l1.pop());
					} else {
						nL.add(l2.pop());
					}
					while(!l1.isEmpty()) nL.add(l1.pop());
					while(!l2.isEmpty()) nL.add(l2.pop());
					sortedLists.add(nL);
				}
				deltas = sortedLists.first();
				this.rdeltas.clear();
				var lastDeltaValue = -1.0;
				var c = null;
				var _g_head1 = deltas.h;
				while(_g_head1 != null) {
					var val1 = _g_head1.item;
					_g_head1 = _g_head1.next;
					var delta1 = val1;
					if(lastDeltaValue != delta1.dist) {
						lastDeltaValue = delta1.dist;
						if(c != null) {
							this.rdeltas.add(c);
						}
						c = new List();
					}
					c.add(delta1);
				}
				if(c != null) {
					this.rdeltas.add(c);
				}
				var current1 = this.seqs.first;
				while(current1 != null) {
					current1.nrConnections = 0;
					current1.connectedTo = null;
					current1.visitedId = 0;
					current1 = current1.next;
				}
				var nextVisitedId = 1;
				var _g_head2 = this.rdeltas.h;
				while(_g_head2 != null) {
					var val2 = _g_head2.item;
					_g_head2 = _g_head2.next;
					var deltas1 = val2;
					var _g_head3 = deltas1.h;
					while(_g_head3 != null) {
						var val3 = _g_head3.item;
						_g_head3 = _g_head3.next;
						var delta2 = val3;
						var isConnected = false;
						var l = new List();
						l.add(delta2.s1);
						delta2.s1.visitedId = nextVisitedId;
						while(!l.isEmpty()) {
							var c1 = l.pop();
							if(c1 == delta2.s2) {
								isConnected = true;
							}
							var p = c1.connectedTo;
							while(p != null) {
								if(p.connectedTo.visitedId != nextVisitedId && p.dist < delta2.dist - epsilon) {
									l.add(p.connectedTo);
									p.connectedTo.visitedId = nextVisitedId;
								}
								p = p.next;
							}
						}
						++nextVisitedId;
						if(!isConnected) {
							var _this = delta2.s1;
							var c2 = new mj_Connection(delta2.s2,delta2.dist);
							c2.next = _this.connectedTo;
							_this.connectedTo = c2;
							_this.nrConnections++;
							var _this1 = delta2.s2;
							var c3 = new mj_Connection(delta2.s1,delta2.dist);
							c3.next = _this1.connectedTo;
							_this1.connectedTo = c3;
							_this1.nrConnections++;
						}
					}
				}
				var nrRem = 0;
				var current3 = this.seqs.firstMed;
				var markDel = new List();
				while(current3 != null) {
					if(current3.nrConnections <= 2) {
						markDel.add(current3);
						++nrRem;
					}
					current3 = current3.next;
				}
				var _g_head4 = markDel.h;
				while(_g_head4 != null) {
					var val4 = _g_head4.item;
					_g_head4 = _g_head4.next;
					var current4 = val4;
					var _this2 = this.seqs;
					current4.linkedTo.clear();
					if(_this2.firstMed == current4) {
						_this2.firstMed = current4.next;
					}
					if(_this2.last == current4) {
						_this2.last = current4.prev;
					}
					var hc = current4.hashCode;
					var index = hc >= 0 ? hc % _this2.hashTable.length : -hc % _this2.hashTable.length;
					if(_this2.hashTable[index] == current4) {
						_this2.hashTable[index] = current4.nextWithHash;
					}
					if(current4.next != null) {
						current4.next.prev = current4.prev;
					}
					if(current4.prev != null) {
						current4.prev.next = current4.next;
					}
					if(current4.nextWithHash != null) {
						current4.nextWithHash.prevWithHash = current4.prevWithHash;
					}
					if(current4.prevWithHash != null) {
						current4.prevWithHash.nextWithHash = current4.nextWithHash;
					}
					_this2.size--;
					current4.next = null;
					current4.prev = null;
					current4.nextWithHash = null;
					current4.prevWithHash = null;
				}
				i = nrRem;
				if(i != 0) {
					if(!(i != 0)) {
						break;
					} else {
						continue;
					}
				}
				var medLst = new List();
				var s11 = this.seqs.first;
				while(s11 != null) {
					var s2_ = s11.connectedTo;
					while(s2_ != null) {
						var s3_ = s2_.next;
						while(s3_ != null) {
							medLst.add(new mj_Median(s11.redSeq,s2_.connectedTo.redSeq,s3_.connectedTo.redSeq,this.rweights));
							s3_ = s3_.next;
						}
						s2_ = s2_.next;
					}
					s11 = s11.next;
				}
				var nrSeqsAdded = 0;
				var sortedMeds = new List();
				var _g_head5 = medLst.h;
				while(_g_head5 != null) {
					var val5 = _g_head5.item;
					_g_head5 = _g_head5.next;
					var med = val5;
					if(sortedMeds.last() != null && sortedMeds.last().last() != null && sortedMeds.last().last().dist <= med.dist) {
						sortedMeds.last().add(med);
					} else {
						var l3 = new List();
						l3.add(med);
						sortedMeds.add(l3);
					}
				}
				while(sortedMeds.length > 1) {
					var l11 = sortedMeds.pop();
					var l21 = sortedMeds.pop();
					var nL1 = new List();
					while(!l11.isEmpty() && !l21.isEmpty()) if(l11.first().dist <= l21.first().dist) {
						nL1.add(l11.pop());
					} else {
						nL1.add(l21.pop());
					}
					while(!l11.isEmpty()) nL1.add(l11.pop());
					while(!l21.isEmpty()) nL1.add(l21.pop());
					sortedMeds.add(nL1);
				}
				medLst = sortedMeds.pop();
				if(medLst == null) {
					medLst = new List();
				}
				var lambda = Infinity;
				var _g_head6 = medLst.h;
				while(_g_head6 != null) {
					var val6 = _g_head6.item;
					_g_head6 = _g_head6.next;
					var med1 = val6;
					if(med1.diffPos > 1 && med1.dist <= lambda + epsilon) {
						var _g_head7;
						var presult = new List();
						var length = med1.s1.length;
						var this1 = new Array(length);
						presult.add(this1);
						var _g11 = 0;
						var _g2 = med1.s1.length;
						while(_g11 < _g2) {
							var pos1 = _g11++;
							if(med1.s1.charAt(pos1) == med1.s2.charAt(pos1)) {
								var c4 = med1.s1.charAt(pos1);
								var _g_head8 = presult.h;
								while(_g_head8 != null) {
									var val7 = _g_head8.item;
									_g_head8 = _g_head8.next;
									var e = val7;
									e[pos1] = c4;
								}
								continue;
							}
							if(med1.s1.charAt(pos1) == med1.s3.charAt(pos1)) {
								var c5 = med1.s1.charAt(pos1);
								var _g_head9 = presult.h;
								while(_g_head9 != null) {
									var val8 = _g_head9.item;
									_g_head9 = _g_head9.next;
									var e1 = val8;
									e1[pos1] = c5;
								}
								continue;
							}
							if(med1.s2.charAt(pos1) == med1.s3.charAt(pos1)) {
								var c6 = med1.s2.charAt(pos1);
								var _g_head10 = presult.h;
								while(_g_head10 != null) {
									var val9 = _g_head10.item;
									_g_head10 = _g_head10.next;
									var e2 = val9;
									e2[pos1] = c6;
								}
								continue;
							}
							var limit = presult.length;
							var _g21 = 0;
							while(_g21 < 2) {
								var zzzzz = _g21++;
								var i1 = 0;
								var _g3_head = presult.h;
								while(_g3_head != null) {
									var val10 = _g3_head.item;
									_g3_head = _g3_head.next;
									var ele = val10;
									if(i1 < limit) {
										++i1;
									} else {
										break;
									}
									var length1 = ele.length;
									var this2 = new Array(length1);
									var r = this2;
									haxe_ds__$Vector_Vector_$Impl_$.blit(ele,0,r,0,ele.length);
									presult.add(r);
								}
							}
							var pp = 0;
							var _g2_head = presult.h;
							while(_g2_head != null) {
								var val11 = _g2_head.item;
								_g2_head = _g2_head.next;
								var ele1 = val11;
								var c7 = pp < limit ? med1.s1.charAt(pos1) : pp < limit << 1 ? med1.s2.charAt(pos1) : med1.s3.charAt(pos1);
								ele1[pos1] = c7;
								++pp;
							}
						}
						var result1 = new List();
						var _g_head11 = presult.h;
						while(_g_head11 != null) {
							var val12 = _g_head11.item;
							_g_head11 = _g_head11.next;
							var s = val12;
							var b_b = "";
							var i2 = 0;
							var len = s.length;
							var _g12 = 0;
							var _g3 = len;
							while(_g12 < _g3) {
								var i3 = _g12++;
								b_b += Std.string(Std.string(s[i3]));
								if(i3 < len - 1) {
									b_b += "";
								}
							}
							result1.add(b_b);
						}
						_g_head7 = result1.h;
						while(_g_head7 != null) {
							var val13 = _g_head7.item;
							_g_head7 = _g_head7.next;
							var medV = val13;
							var _this3 = this.seqs;
							var result2 = false;
							var result3 = 7;
							var _g13 = 0;
							var _g4 = medV.length;
							while(_g13 < _g4) {
								var pos2 = _g13++;
								result3 = 31 * result3 + HxOverrides.cca(medV,pos2);
							}
							var hc1 = result3;
							var hc2 = hc1 >= 0 ? hc1 % _this3.hashTable.length : -hc1 % _this3.hashTable.length;
							var s3 = _this3.hashTable[hc2];
							while(s3 != null) {
								if(s3.redSeq == medV) {
									result2 = true;
									break;
								}
								s3 = s3.nextWithHash;
							}
							if(result2) {
								continue;
							}
							lambda = Math.min(lambda,med1.dist);
							var _this4 = this.seqs;
							var result4 = false;
							var result5 = 7;
							var _g14 = 0;
							var _g5 = medV.length;
							while(_g14 < _g5) {
								var pos3 = _g14++;
								result5 = 31 * result5 + HxOverrides.cca(medV,pos3);
							}
							var hc3 = result5;
							var hc4 = hc3 >= 0 ? hc3 % _this4.hashTable.length : -hc3 % _this4.hashTable.length;
							var s4 = _this4.hashTable[hc4];
							while(s4 != null) {
								if(s4.redSeq == medV) {
									result4 = true;
									break;
								}
								s4 = s4.nextWithHash;
							}
							if(!result4) {
								var id = _this4.nextSeqId++;
								var result6 = new mj_Seq();
								result6.id = id;
								result6.redSeq = medV;
								var s5 = result6.redSeq;
								var result7 = 7;
								var _g15 = 0;
								var _g6 = s5.length;
								while(_g15 < _g6) {
									var pos4 = _g15++;
									result7 = 31 * result7 + HxOverrides.cca(s5,pos4);
								}
								result6.hashCode = result7;
								result6.isSample = false;
								var s6 = result6;
								_this4.size++;
								if(_this4.hashTable.length >> 1 < _this4.size) {
									var newSize = _this4.hashTable.length << 1;
									var this3 = new Array(newSize);
									_this4.hashTable = this3;
									var c8 = _this4.first;
									while(c8 != null) {
										c8.nextWithHash = null;
										c8.prevWithHash = null;
										var hc5 = c8.hashCode;
										var index1 = hc5 >= 0 ? hc5 % _this4.hashTable.length : -hc5 % _this4.hashTable.length;
										if(_this4.hashTable[index1] == null) {
											_this4.hashTable[index1] = c8;
										} else {
											c8.nextWithHash = _this4.hashTable[index1];
											_this4.hashTable[index1].prevWithHash = c8;
											_this4.hashTable[index1] = c8;
										}
										c8 = c8.next;
									}
								}
								s6.nextWithHash = null;
								s6.prevWithHash = null;
								var hc6 = s6.hashCode;
								var index2 = hc6 >= 0 ? hc6 % _this4.hashTable.length : -hc6 % _this4.hashTable.length;
								if(_this4.hashTable[index2] == null) {
									_this4.hashTable[index2] = s6;
								} else {
									s6.nextWithHash = _this4.hashTable[index2];
									_this4.hashTable[index2].prevWithHash = s6;
									_this4.hashTable[index2] = s6;
								}
								if(_this4.first == null) {
									_this4.first = s6;
								} else {
									s6.prev = _this4.last;
									_this4.last.next = s6;
								}
								_this4.last = s6;
								if(_this4.firstMed == null && !s6.isSample) {
									_this4.firstMed = s6;
								}
							}
							++nrSeqsAdded;
						}
					} else {
						break;
					}
				}
				i = nrSeqsAdded;
				if(!(i != 0)) {
					break;
				}
			}
			var i4;
			while(true) {
				var deltas2 = new List();
				var current5 = this.seqs.first;
				while(current5 != null) {
					var current21 = current5.next;
					while(current21 != null) {
						var s12 = current5.redSeq;
						var s21 = current21.redSeq;
						var result8 = 0.0;
						var _g16 = 0;
						var _g7 = s12.length;
						while(_g16 < _g7) {
							var pos5 = _g16++;
							if(s12.charAt(pos5) != s21.charAt(pos5)) {
								result8 += this.rweights[pos5];
							}
						}
						var d1 = new mj_Delta(current5,current21,result8);
						deltas2.add(d1);
						current21 = current21.next;
					}
					current5 = current5.next;
				}
				var sortedLists1 = new List();
				var _g_head12 = deltas2.h;
				while(_g_head12 != null) {
					var val14 = _g_head12.item;
					_g_head12 = _g_head12.next;
					var delta3 = val14;
					if(sortedLists1.last() != null && sortedLists1.last().last() != null && sortedLists1.last().last().dist <= delta3.dist) {
						sortedLists1.last().add(delta3);
					} else {
						var newL1 = new List();
						newL1.add(delta3);
						sortedLists1.add(newL1);
					}
				}
				while(sortedLists1.length > 1) {
					var l12 = sortedLists1.pop();
					var l22 = sortedLists1.pop();
					var nL2 = new List();
					while(!l12.isEmpty() && !l22.isEmpty()) if(l12.first().dist <= l22.first().dist) {
						nL2.add(l12.pop());
					} else {
						nL2.add(l22.pop());
					}
					while(!l12.isEmpty()) nL2.add(l12.pop());
					while(!l22.isEmpty()) nL2.add(l22.pop());
					sortedLists1.add(nL2);
				}
				deltas2 = sortedLists1.first();
				this.rdeltas.clear();
				var lastDeltaValue1 = -1.0;
				var c9 = null;
				var _g_head13 = deltas2.h;
				while(_g_head13 != null) {
					var val15 = _g_head13.item;
					_g_head13 = _g_head13.next;
					var delta4 = val15;
					if(lastDeltaValue1 != delta4.dist) {
						lastDeltaValue1 = delta4.dist;
						if(c9 != null) {
							this.rdeltas.add(c9);
						}
						c9 = new List();
					}
					c9.add(delta4);
				}
				if(c9 != null) {
					this.rdeltas.add(c9);
				}
				var current6 = this.seqs.first;
				while(current6 != null) {
					current6.nrConnections = 0;
					current6.connectedTo = null;
					current6.visitedId = 0;
					current6 = current6.next;
				}
				var nextVisitedId1 = 1;
				var _g_head14 = this.rdeltas.h;
				while(_g_head14 != null) {
					var val16 = _g_head14.item;
					_g_head14 = _g_head14.next;
					var deltas3 = val16;
					var _g_head15 = deltas3.h;
					while(_g_head15 != null) {
						var val17 = _g_head15.item;
						_g_head15 = _g_head15.next;
						var delta5 = val17;
						var isConnected1 = false;
						var l4 = new List();
						l4.add(delta5.s1);
						delta5.s1.visitedId = nextVisitedId1;
						while(!l4.isEmpty()) {
							var c10 = l4.pop();
							if(c10 == delta5.s2) {
								isConnected1 = true;
							}
							var p1 = c10.connectedTo;
							while(p1 != null) {
								if(p1.connectedTo.visitedId != nextVisitedId1 && p1.dist < delta5.dist) {
									l4.add(p1.connectedTo);
									p1.connectedTo.visitedId = nextVisitedId1;
								}
								p1 = p1.next;
							}
						}
						++nextVisitedId1;
						if(!isConnected1) {
							var _this5 = delta5.s1;
							var c11 = new mj_Connection(delta5.s2,delta5.dist);
							c11.next = _this5.connectedTo;
							_this5.connectedTo = c11;
							_this5.nrConnections++;
							var _this6 = delta5.s2;
							var c12 = new mj_Connection(delta5.s1,delta5.dist);
							c12.next = _this6.connectedTo;
							_this6.connectedTo = c12;
							_this6.nrConnections++;
						}
					}
				}
				var nrRem1 = 0;
				var current7 = this.seqs.firstMed;
				var markDel1 = new List();
				while(current7 != null) {
					if(current7.nrConnections <= 2) {
						markDel1.add(current7);
						++nrRem1;
					}
					current7 = current7.next;
				}
				var _g_head16 = markDel1.h;
				while(_g_head16 != null) {
					var val18 = _g_head16.item;
					_g_head16 = _g_head16.next;
					var current8 = val18;
					var _this7 = this.seqs;
					current8.linkedTo.clear();
					if(_this7.firstMed == current8) {
						_this7.firstMed = current8.next;
					}
					if(_this7.last == current8) {
						_this7.last = current8.prev;
					}
					var hc7 = current8.hashCode;
					var index3 = hc7 >= 0 ? hc7 % _this7.hashTable.length : -hc7 % _this7.hashTable.length;
					if(_this7.hashTable[index3] == current8) {
						_this7.hashTable[index3] = current8.nextWithHash;
					}
					if(current8.next != null) {
						current8.next.prev = current8.prev;
					}
					if(current8.prev != null) {
						current8.prev.next = current8.next;
					}
					if(current8.nextWithHash != null) {
						current8.nextWithHash.prevWithHash = current8.prevWithHash;
					}
					if(current8.prevWithHash != null) {
						current8.prevWithHash.nextWithHash = current8.nextWithHash;
					}
					_this7.size--;
					current8.next = null;
					current8.prev = null;
					current8.nextWithHash = null;
					current8.prevWithHash = null;
				}
				i4 = nrRem1;
				if(!(i4 != 0)) {
					break;
				}
			}
		}
	}
	,step1: function() {
		var deltas = new List();
		var current = this.seqs.first;
		while(current != null) {
			var current2 = current.next;
			while(current2 != null) {
				var s1 = current.redSeq;
				var s2 = current2.redSeq;
				var result = 0.0;
				var _g1 = 0;
				var _g = s1.length;
				while(_g1 < _g) {
					var pos = _g1++;
					if(s1.charAt(pos) != s2.charAt(pos)) {
						result += this.rweights[pos];
					}
				}
				var d = new mj_Delta(current,current2,result);
				deltas.add(d);
				current2 = current2.next;
			}
			current = current.next;
		}
		var sortedLists = new List();
		var _g_head = deltas.h;
		while(_g_head != null) {
			var val = _g_head.item;
			_g_head = _g_head.next;
			var delta = val;
			if(sortedLists.last() != null && sortedLists.last().last() != null && sortedLists.last().last().dist <= delta.dist) {
				sortedLists.last().add(delta);
			} else {
				var newL = new List();
				newL.add(delta);
				sortedLists.add(newL);
			}
		}
		while(sortedLists.length > 1) {
			var l1 = sortedLists.pop();
			var l2 = sortedLists.pop();
			var nL = new List();
			while(!l1.isEmpty() && !l2.isEmpty()) if(l1.first().dist <= l2.first().dist) {
				nL.add(l1.pop());
			} else {
				nL.add(l2.pop());
			}
			while(!l1.isEmpty()) nL.add(l1.pop());
			while(!l2.isEmpty()) nL.add(l2.pop());
			sortedLists.add(nL);
		}
		deltas = sortedLists.first();
		this.rdeltas.clear();
		var lastDeltaValue = -1.0;
		var c = null;
		var _g_head1 = deltas.h;
		while(_g_head1 != null) {
			var val1 = _g_head1.item;
			_g_head1 = _g_head1.next;
			var delta1 = val1;
			if(lastDeltaValue != delta1.dist) {
				lastDeltaValue = delta1.dist;
				if(c != null) {
					this.rdeltas.add(c);
				}
				c = new List();
			}
			c.add(delta1);
		}
		if(c != null) {
			this.rdeltas.add(c);
		}
	}
	,step2: function(epsilon) {
		var current = this.seqs.first;
		while(current != null) {
			current.nrConnections = 0;
			current.connectedTo = null;
			current.visitedId = 0;
			current = current.next;
		}
		var nextVisitedId = 1;
		var _g_head = this.rdeltas.h;
		while(_g_head != null) {
			var val = _g_head.item;
			_g_head = _g_head.next;
			var deltas = val;
			var _g_head1 = deltas.h;
			while(_g_head1 != null) {
				var val1 = _g_head1.item;
				_g_head1 = _g_head1.next;
				var delta = val1;
				var isConnected = false;
				var l = new List();
				l.add(delta.s1);
				delta.s1.visitedId = nextVisitedId;
				while(!l.isEmpty()) {
					var c = l.pop();
					if(c == delta.s2) {
						isConnected = true;
					}
					var p = c.connectedTo;
					while(p != null) {
						if(p.connectedTo.visitedId != nextVisitedId && p.dist < delta.dist - epsilon) {
							l.add(p.connectedTo);
							p.connectedTo.visitedId = nextVisitedId;
						}
						p = p.next;
					}
				}
				++nextVisitedId;
				if(!isConnected) {
					var _this = delta.s1;
					var c1 = new mj_Connection(delta.s2,delta.dist);
					c1.next = _this.connectedTo;
					_this.connectedTo = c1;
					_this.nrConnections++;
					var _this1 = delta.s2;
					var c2 = new mj_Connection(delta.s1,delta.dist);
					c2.next = _this1.connectedTo;
					_this1.connectedTo = c2;
					_this1.nrConnections++;
				}
			}
		}
	}
	,step3: function() {
		var nrRem = 0;
		var current = this.seqs.firstMed;
		var markDel = new List();
		while(current != null) {
			if(current.nrConnections <= 2) {
				markDel.add(current);
				++nrRem;
			}
			current = current.next;
		}
		var _g_head = markDel.h;
		while(_g_head != null) {
			var val = _g_head.item;
			_g_head = _g_head.next;
			var current1 = val;
			var _this = this.seqs;
			current1.linkedTo.clear();
			if(_this.firstMed == current1) {
				_this.firstMed = current1.next;
			}
			if(_this.last == current1) {
				_this.last = current1.prev;
			}
			var hc = current1.hashCode;
			var index = hc >= 0 ? hc % _this.hashTable.length : -hc % _this.hashTable.length;
			if(_this.hashTable[index] == current1) {
				_this.hashTable[index] = current1.nextWithHash;
			}
			if(current1.next != null) {
				current1.next.prev = current1.prev;
			}
			if(current1.prev != null) {
				current1.prev.next = current1.next;
			}
			if(current1.nextWithHash != null) {
				current1.nextWithHash.prevWithHash = current1.prevWithHash;
			}
			if(current1.prevWithHash != null) {
				current1.prevWithHash.nextWithHash = current1.nextWithHash;
			}
			_this.size--;
			current1.next = null;
			current1.prev = null;
			current1.nextWithHash = null;
			current1.prevWithHash = null;
		}
		return nrRem;
	}
	,step4: function(epsilon) {
		var medLst = new List();
		var s1 = this.seqs.first;
		while(s1 != null) {
			var s2_ = s1.connectedTo;
			while(s2_ != null) {
				var s3_ = s2_.next;
				while(s3_ != null) {
					medLst.add(new mj_Median(s1.redSeq,s2_.connectedTo.redSeq,s3_.connectedTo.redSeq,this.rweights));
					s3_ = s3_.next;
				}
				s2_ = s2_.next;
			}
			s1 = s1.next;
		}
		var nrSeqsAdded = 0;
		var sortedMeds = new List();
		var _g_head = medLst.h;
		while(_g_head != null) {
			var val = _g_head.item;
			_g_head = _g_head.next;
			var med = val;
			if(sortedMeds.last() != null && sortedMeds.last().last() != null && sortedMeds.last().last().dist <= med.dist) {
				sortedMeds.last().add(med);
			} else {
				var l = new List();
				l.add(med);
				sortedMeds.add(l);
			}
		}
		while(sortedMeds.length > 1) {
			var l1 = sortedMeds.pop();
			var l2 = sortedMeds.pop();
			var nL = new List();
			while(!l1.isEmpty() && !l2.isEmpty()) if(l1.first().dist <= l2.first().dist) {
				nL.add(l1.pop());
			} else {
				nL.add(l2.pop());
			}
			while(!l1.isEmpty()) nL.add(l1.pop());
			while(!l2.isEmpty()) nL.add(l2.pop());
			sortedMeds.add(nL);
		}
		medLst = sortedMeds.pop();
		if(medLst == null) {
			medLst = new List();
		}
		var lambda = Infinity;
		var _g_head1 = medLst.h;
		while(_g_head1 != null) {
			var val1 = _g_head1.item;
			_g_head1 = _g_head1.next;
			var med1 = val1;
			if(med1.diffPos > 1 && med1.dist <= lambda + epsilon) {
				var _g_head2;
				var presult = new List();
				var length = med1.s1.length;
				var this1 = new Array(length);
				presult.add(this1);
				var _g1 = 0;
				var _g = med1.s1.length;
				while(_g1 < _g) {
					var pos = _g1++;
					if(med1.s1.charAt(pos) == med1.s2.charAt(pos)) {
						var c = med1.s1.charAt(pos);
						var _g_head3 = presult.h;
						while(_g_head3 != null) {
							var val2 = _g_head3.item;
							_g_head3 = _g_head3.next;
							var e = val2;
							e[pos] = c;
						}
						continue;
					}
					if(med1.s1.charAt(pos) == med1.s3.charAt(pos)) {
						var c1 = med1.s1.charAt(pos);
						var _g_head4 = presult.h;
						while(_g_head4 != null) {
							var val3 = _g_head4.item;
							_g_head4 = _g_head4.next;
							var e1 = val3;
							e1[pos] = c1;
						}
						continue;
					}
					if(med1.s2.charAt(pos) == med1.s3.charAt(pos)) {
						var c2 = med1.s2.charAt(pos);
						var _g_head5 = presult.h;
						while(_g_head5 != null) {
							var val4 = _g_head5.item;
							_g_head5 = _g_head5.next;
							var e2 = val4;
							e2[pos] = c2;
						}
						continue;
					}
					var limit = presult.length;
					var _g2 = 0;
					while(_g2 < 2) {
						var zzzzz = _g2++;
						var i = 0;
						var _g3_head = presult.h;
						while(_g3_head != null) {
							var val5 = _g3_head.item;
							_g3_head = _g3_head.next;
							var ele = val5;
							if(i < limit) {
								++i;
							} else {
								break;
							}
							var length1 = ele.length;
							var this2 = new Array(length1);
							var r = this2;
							haxe_ds__$Vector_Vector_$Impl_$.blit(ele,0,r,0,ele.length);
							presult.add(r);
						}
					}
					var pp = 0;
					var _g2_head = presult.h;
					while(_g2_head != null) {
						var val6 = _g2_head.item;
						_g2_head = _g2_head.next;
						var ele1 = val6;
						var c3 = pp < limit ? med1.s1.charAt(pos) : pp < limit << 1 ? med1.s2.charAt(pos) : med1.s3.charAt(pos);
						ele1[pos] = c3;
						++pp;
					}
				}
				var result = new List();
				var _g_head6 = presult.h;
				while(_g_head6 != null) {
					var val7 = _g_head6.item;
					_g_head6 = _g_head6.next;
					var s = val7;
					var b_b = "";
					var i1 = 0;
					var len = s.length;
					var _g11 = 0;
					var _g3 = len;
					while(_g11 < _g3) {
						var i2 = _g11++;
						b_b += Std.string(Std.string(s[i2]));
						if(i2 < len - 1) {
							b_b += "";
						}
					}
					result.add(b_b);
				}
				_g_head2 = result.h;
				while(_g_head2 != null) {
					var val8 = _g_head2.item;
					_g_head2 = _g_head2.next;
					var medV = val8;
					var _this = this.seqs;
					var result1 = false;
					var result2 = 7;
					var _g12 = 0;
					var _g4 = medV.length;
					while(_g12 < _g4) {
						var pos1 = _g12++;
						result2 = 31 * result2 + HxOverrides.cca(medV,pos1);
					}
					var hc = result2;
					var hc1 = hc >= 0 ? hc % _this.hashTable.length : -hc % _this.hashTable.length;
					var s2 = _this.hashTable[hc1];
					while(s2 != null) {
						if(s2.redSeq == medV) {
							result1 = true;
							break;
						}
						s2 = s2.nextWithHash;
					}
					if(result1) {
						continue;
					}
					lambda = Math.min(lambda,med1.dist);
					var _this1 = this.seqs;
					var result3 = false;
					var result4 = 7;
					var _g13 = 0;
					var _g5 = medV.length;
					while(_g13 < _g5) {
						var pos2 = _g13++;
						result4 = 31 * result4 + HxOverrides.cca(medV,pos2);
					}
					var hc2 = result4;
					var hc3 = hc2 >= 0 ? hc2 % _this1.hashTable.length : -hc2 % _this1.hashTable.length;
					var s3 = _this1.hashTable[hc3];
					while(s3 != null) {
						if(s3.redSeq == medV) {
							result3 = true;
							break;
						}
						s3 = s3.nextWithHash;
					}
					if(!result3) {
						var id = _this1.nextSeqId++;
						var result5 = new mj_Seq();
						result5.id = id;
						result5.redSeq = medV;
						var s4 = result5.redSeq;
						var result6 = 7;
						var _g14 = 0;
						var _g6 = s4.length;
						while(_g14 < _g6) {
							var pos3 = _g14++;
							result6 = 31 * result6 + HxOverrides.cca(s4,pos3);
						}
						result5.hashCode = result6;
						result5.isSample = false;
						var s5 = result5;
						_this1.size++;
						if(_this1.hashTable.length >> 1 < _this1.size) {
							var newSize = _this1.hashTable.length << 1;
							var this3 = new Array(newSize);
							_this1.hashTable = this3;
							var c4 = _this1.first;
							while(c4 != null) {
								c4.nextWithHash = null;
								c4.prevWithHash = null;
								var hc4 = c4.hashCode;
								var index = hc4 >= 0 ? hc4 % _this1.hashTable.length : -hc4 % _this1.hashTable.length;
								if(_this1.hashTable[index] == null) {
									_this1.hashTable[index] = c4;
								} else {
									c4.nextWithHash = _this1.hashTable[index];
									_this1.hashTable[index].prevWithHash = c4;
									_this1.hashTable[index] = c4;
								}
								c4 = c4.next;
							}
						}
						s5.nextWithHash = null;
						s5.prevWithHash = null;
						var hc5 = s5.hashCode;
						var index1 = hc5 >= 0 ? hc5 % _this1.hashTable.length : -hc5 % _this1.hashTable.length;
						if(_this1.hashTable[index1] == null) {
							_this1.hashTable[index1] = s5;
						} else {
							s5.nextWithHash = _this1.hashTable[index1];
							_this1.hashTable[index1].prevWithHash = s5;
							_this1.hashTable[index1] = s5;
						}
						if(_this1.first == null) {
							_this1.first = s5;
						} else {
							s5.prev = _this1.last;
							_this1.last.next = s5;
						}
						_this1.last = s5;
						if(_this1.firstMed == null && !s5.isSample) {
							_this1.firstMed = s5;
						}
					}
					++nrSeqsAdded;
				}
			} else {
				break;
			}
		}
		return nrSeqsAdded;
	}
	,step5: function() {
		var i;
		while(true) {
			var deltas = new List();
			var current = this.seqs.first;
			while(current != null) {
				var current2 = current.next;
				while(current2 != null) {
					var s1 = current.redSeq;
					var s2 = current2.redSeq;
					var result = 0.0;
					var _g1 = 0;
					var _g = s1.length;
					while(_g1 < _g) {
						var pos = _g1++;
						if(s1.charAt(pos) != s2.charAt(pos)) {
							result += this.rweights[pos];
						}
					}
					var d = new mj_Delta(current,current2,result);
					deltas.add(d);
					current2 = current2.next;
				}
				current = current.next;
			}
			var sortedLists = new List();
			var _g_head = deltas.h;
			while(_g_head != null) {
				var val = _g_head.item;
				_g_head = _g_head.next;
				var delta = val;
				if(sortedLists.last() != null && sortedLists.last().last() != null && sortedLists.last().last().dist <= delta.dist) {
					sortedLists.last().add(delta);
				} else {
					var newL = new List();
					newL.add(delta);
					sortedLists.add(newL);
				}
			}
			while(sortedLists.length > 1) {
				var l1 = sortedLists.pop();
				var l2 = sortedLists.pop();
				var nL = new List();
				while(!l1.isEmpty() && !l2.isEmpty()) if(l1.first().dist <= l2.first().dist) {
					nL.add(l1.pop());
				} else {
					nL.add(l2.pop());
				}
				while(!l1.isEmpty()) nL.add(l1.pop());
				while(!l2.isEmpty()) nL.add(l2.pop());
				sortedLists.add(nL);
			}
			deltas = sortedLists.first();
			this.rdeltas.clear();
			var lastDeltaValue = -1.0;
			var c = null;
			var _g_head1 = deltas.h;
			while(_g_head1 != null) {
				var val1 = _g_head1.item;
				_g_head1 = _g_head1.next;
				var delta1 = val1;
				if(lastDeltaValue != delta1.dist) {
					lastDeltaValue = delta1.dist;
					if(c != null) {
						this.rdeltas.add(c);
					}
					c = new List();
				}
				c.add(delta1);
			}
			if(c != null) {
				this.rdeltas.add(c);
			}
			var current1 = this.seqs.first;
			while(current1 != null) {
				current1.nrConnections = 0;
				current1.connectedTo = null;
				current1.visitedId = 0;
				current1 = current1.next;
			}
			var nextVisitedId = 1;
			var _g_head2 = this.rdeltas.h;
			while(_g_head2 != null) {
				var val2 = _g_head2.item;
				_g_head2 = _g_head2.next;
				var deltas1 = val2;
				var _g_head3 = deltas1.h;
				while(_g_head3 != null) {
					var val3 = _g_head3.item;
					_g_head3 = _g_head3.next;
					var delta2 = val3;
					var isConnected = false;
					var l = new List();
					l.add(delta2.s1);
					delta2.s1.visitedId = nextVisitedId;
					while(!l.isEmpty()) {
						var c1 = l.pop();
						if(c1 == delta2.s2) {
							isConnected = true;
						}
						var p = c1.connectedTo;
						while(p != null) {
							if(p.connectedTo.visitedId != nextVisitedId && p.dist < delta2.dist) {
								l.add(p.connectedTo);
								p.connectedTo.visitedId = nextVisitedId;
							}
							p = p.next;
						}
					}
					++nextVisitedId;
					if(!isConnected) {
						var _this = delta2.s1;
						var c2 = new mj_Connection(delta2.s2,delta2.dist);
						c2.next = _this.connectedTo;
						_this.connectedTo = c2;
						_this.nrConnections++;
						var _this1 = delta2.s2;
						var c3 = new mj_Connection(delta2.s1,delta2.dist);
						c3.next = _this1.connectedTo;
						_this1.connectedTo = c3;
						_this1.nrConnections++;
					}
				}
			}
			var nrRem = 0;
			var current3 = this.seqs.firstMed;
			var markDel = new List();
			while(current3 != null) {
				if(current3.nrConnections <= 2) {
					markDel.add(current3);
					++nrRem;
				}
				current3 = current3.next;
			}
			var _g_head4 = markDel.h;
			while(_g_head4 != null) {
				var val4 = _g_head4.item;
				_g_head4 = _g_head4.next;
				var current4 = val4;
				var _this2 = this.seqs;
				current4.linkedTo.clear();
				if(_this2.firstMed == current4) {
					_this2.firstMed = current4.next;
				}
				if(_this2.last == current4) {
					_this2.last = current4.prev;
				}
				var hc = current4.hashCode;
				var index = hc >= 0 ? hc % _this2.hashTable.length : -hc % _this2.hashTable.length;
				if(_this2.hashTable[index] == current4) {
					_this2.hashTable[index] = current4.nextWithHash;
				}
				if(current4.next != null) {
					current4.next.prev = current4.prev;
				}
				if(current4.prev != null) {
					current4.prev.next = current4.next;
				}
				if(current4.nextWithHash != null) {
					current4.nextWithHash.prevWithHash = current4.prevWithHash;
				}
				if(current4.prevWithHash != null) {
					current4.prevWithHash.nextWithHash = current4.nextWithHash;
				}
				_this2.size--;
				current4.next = null;
				current4.prev = null;
				current4.nextWithHash = null;
				current4.prevWithHash = null;
			}
			i = nrRem;
			if(!(i != 0)) {
				break;
			}
		}
	}
	,finalizeNetwork: function() {
		var list = this.seqs.first;
		var tmp;
		if(list == null) {
			tmp = null;
		} else {
			var insize = 1;
			var nmerges;
			var psize = 0;
			var qsize = 0;
			var p;
			var q;
			var e;
			var tail = null;
			while(true) {
				p = list;
				list = null;
				tail = null;
				nmerges = 0;
				while(p != null) {
					++nmerges;
					q = p;
					psize = 0;
					var _g1 = 0;
					var _g = insize;
					while(_g1 < _g) {
						var i = _g1++;
						++psize;
						q = q.next;
						if(q == null) {
							break;
						}
					}
					qsize = insize;
					while(psize > 0 || qsize > 0 && q != null) {
						if(psize == 0) {
							e = q;
							q = q.next;
							--qsize;
						} else if(qsize == 0 || q == null || q.names.length - p.names.length <= 0) {
							e = p;
							p = p.next;
							--psize;
						} else {
							e = q;
							q = q.next;
							--qsize;
						}
						if(tail != null) {
							tail.next = e;
						} else {
							list = e;
						}
						e.prev = tail;
						tail = e;
					}
					p = q;
				}
				tail.next = null;
				if(nmerges <= 1) {
					break;
				}
				insize *= 2;
			}
			list.prev = tail;
			tmp = list;
		}
		this.seqs.first = tmp;
		var count = 0;
		var current = this.seqs.first;
		var length = current.origSeq.length;
		var this1 = new Array(length);
		var v = this1;
		var _g11 = 0;
		var _g2 = current.origSeq.length;
		while(_g11 < _g2) {
			var i1 = _g11++;
			v[i1] = current.origSeq.charAt(i1);
		}
		while(current != null) {
			current.id = ++count;
			if(!current.isSample) {
				var i2 = 0;
				var _g_head = this.seqs.ipos.h;
				while(_g_head != null) {
					var val = _g_head.item;
					_g_head = _g_head.next;
					var pos = val;
					v[pos] = current.redSeq.charAt(i2++);
				}
				var b_b = "";
				var i3 = 0;
				var len = v.length;
				var _g12 = 0;
				var _g3 = len;
				while(_g12 < _g3) {
					var i4 = _g12++;
					b_b += Std.string(Std.string(v[i4]));
					if(i4 < len - 1) {
						b_b += "";
					}
				}
				current.origSeq = b_b;
			}
			var current2 = current.next;
			while(current2 != null && current2.isSample) {
				var o = current2.indNames;
				var result = new List();
				var _g_head1 = o.h;
				while(_g_head1 != null) {
					var val1 = _g_head1.item;
					_g_head1 = _g_head1.next;
					var e1 = val1;
					var result1 = false;
					var _g_head2 = current.indNames.h;
					while(_g_head2 != null) {
						var val2 = _g_head2.item;
						_g_head2 = _g_head2.next;
						var indName = val2;
						if(indName == e1) {
							result1 = true;
							break;
						}
					}
					if(result1) {
						result.add(e1);
					}
				}
				var l = result;
				if(l != null && !l.isEmpty()) {
					var l1 = new mj_Link();
					l1.to = current2;
					l1.names = l;
					current.linkedTo.add(l1);
				}
				if(l != null && !l.isEmpty()) {
					var l2 = new mj_Link();
					l2.to = current;
					l2.names = l;
					current2.linkedTo.add(l2);
				}
				current2 = current2.next;
			}
			current = current.next;
		}
		var nextSpId = 1;
		var l3 = new List();
		current = this.seqs.first;
		while(current != null && current.isSample) {
			if(current.spId == 0) {
				current.spId = nextSpId;
				l3.clear();
				l3.add(current);
				while(!l3.isEmpty()) {
					var c = l3.pop();
					var _g_head3 = c.linkedTo.h;
					while(_g_head3 != null) {
						var val3 = _g_head3.item;
						_g_head3 = _g_head3.next;
						var n = val3;
						var n1 = n.to;
						if(n1.spId == 0) {
							n1.spId = nextSpId;
							l3.add(n1);
						} else if(n1.spId != nextSpId) {
							throw new js__$Boot_HaxeError("Something somewhere went terribly wrong (#1)!");
						}
					}
				}
				++nextSpId;
			}
			current = current.next;
		}
		return this.seqs;
	}
};
var mj_Median = function(s1,s2,s3,w) {
	this.s1 = s1;
	this.s2 = s2;
	this.s3 = s3;
	this.dist = 0;
	this.diffPos = 0;
	this.meds = 1;
	var _g1 = 0;
	var _g = s1.length;
	while(_g1 < _g) {
		var pos = _g1++;
		if(s1.charAt(pos) == s2.charAt(pos) && s2.charAt(pos) == s3.charAt(pos)) {
			continue;
		}
		this.diffPos++;
		if(s1.charAt(pos) != s2.charAt(pos) && s2.charAt(pos) != s3.charAt(pos) && s1.charAt(pos) != s3.charAt(pos)) {
			this.dist += 2 * w[pos];
			this.meds *= 3;
			continue;
		}
		this.dist += w[pos];
	}
};
mj_Median.__name__ = true;
mj_Median.prototype = {
	continueMedians: function(l,c,pos) {
		var _g_head = l.h;
		while(_g_head != null) {
			var val = _g_head.item;
			_g_head = _g_head.next;
			var e = val;
			e[pos] = c;
		}
	}
	,constructMedians: function() {
		var presult = new List();
		var length = this.s1.length;
		var this1 = new Array(length);
		presult.add(this1);
		var _g1 = 0;
		var _g = this.s1.length;
		while(_g1 < _g) {
			var pos = _g1++;
			if(this.s1.charAt(pos) == this.s2.charAt(pos)) {
				var c = this.s1.charAt(pos);
				var _g_head = presult.h;
				while(_g_head != null) {
					var val = _g_head.item;
					_g_head = _g_head.next;
					var e = val;
					e[pos] = c;
				}
				continue;
			}
			if(this.s1.charAt(pos) == this.s3.charAt(pos)) {
				var c1 = this.s1.charAt(pos);
				var _g_head1 = presult.h;
				while(_g_head1 != null) {
					var val1 = _g_head1.item;
					_g_head1 = _g_head1.next;
					var e1 = val1;
					e1[pos] = c1;
				}
				continue;
			}
			if(this.s2.charAt(pos) == this.s3.charAt(pos)) {
				var c2 = this.s2.charAt(pos);
				var _g_head2 = presult.h;
				while(_g_head2 != null) {
					var val2 = _g_head2.item;
					_g_head2 = _g_head2.next;
					var e2 = val2;
					e2[pos] = c2;
				}
				continue;
			}
			var limit = presult.length;
			var _g2 = 0;
			while(_g2 < 2) {
				var zzzzz = _g2++;
				var i = 0;
				var _g3_head = presult.h;
				while(_g3_head != null) {
					var val3 = _g3_head.item;
					_g3_head = _g3_head.next;
					var ele = val3;
					if(i < limit) {
						++i;
					} else {
						break;
					}
					var length1 = ele.length;
					var this2 = new Array(length1);
					var r = this2;
					haxe_ds__$Vector_Vector_$Impl_$.blit(ele,0,r,0,ele.length);
					presult.add(r);
				}
			}
			var pp = 0;
			var _g2_head = presult.h;
			while(_g2_head != null) {
				var val4 = _g2_head.item;
				_g2_head = _g2_head.next;
				var ele1 = val4;
				var c3 = pp < limit ? this.s1.charAt(pos) : pp < limit << 1 ? this.s2.charAt(pos) : this.s3.charAt(pos);
				ele1[pos] = c3;
				++pp;
			}
		}
		var result = new List();
		var _g_head3 = presult.h;
		while(_g_head3 != null) {
			var val5 = _g_head3.item;
			_g_head3 = _g_head3.next;
			var s = val5;
			var b_b = "";
			var i1 = 0;
			var len = s.length;
			var _g11 = 0;
			var _g3 = len;
			while(_g11 < _g3) {
				var i2 = _g11++;
				b_b += Std.string(Std.string(s[i2]));
				if(i2 < len - 1) {
					b_b += "";
				}
			}
			result.add(b_b);
		}
		return result;
	}
};
var mj_Seq = function() {
	this.names = new List();
	this.indNames = new List();
	this.linkedTo = new List();
	this.spId = 0;
};
mj_Seq.__name__ = true;
mj_Seq.calcHash = function(s) {
	var result = 7;
	var _g1 = 0;
	var _g = s.length;
	while(_g1 < _g) {
		var pos = _g1++;
		result = 31 * result + HxOverrides.cca(s,pos);
	}
	return result;
};
mj_Seq.getIndIdentifier = function(s) {
	var result = null;
	if(s != null) {
		var pos = s.lastIndexOf("_");
		if(pos != -1) {
			result = HxOverrides.substr(s,0,pos + 1);
		}
	}
	return result;
};
mj_Seq.createSample = function(id,name,seq) {
	var result = new mj_Seq();
	result.id = id;
	if(name != null && name != "") {
		result.names.add(name);
		var result1 = null;
		if(name != null) {
			var pos = name.lastIndexOf("_");
			if(pos != -1) {
				result1 = HxOverrides.substr(name,0,pos + 1);
			}
		}
		var indId = result1;
		var result2 = false;
		var _g_head = result.indNames.h;
		while(_g_head != null) {
			var val = _g_head.item;
			_g_head = _g_head.next;
			var indName = val;
			if(indName == indId) {
				result2 = true;
				break;
			}
		}
		if(!result2) {
			result.indNames.add(indId);
		}
	}
	result.origSeq = seq;
	var s = result.origSeq;
	var result3 = 7;
	var _g1 = 0;
	var _g = s.length;
	while(_g1 < _g) {
		var pos1 = _g1++;
		result3 = 31 * result3 + HxOverrides.cca(s,pos1);
	}
	result.hashCode = result3;
	result.isSample = true;
	return result;
};
mj_Seq.createMedian = function(id,seq) {
	var result = new mj_Seq();
	result.id = id;
	result.redSeq = seq;
	var s = result.redSeq;
	var result1 = 7;
	var _g1 = 0;
	var _g = s.length;
	while(_g1 < _g) {
		var pos = _g1++;
		result1 = 31 * result1 + HxOverrides.cca(s,pos);
	}
	result.hashCode = result1;
	result.isSample = false;
	return result;
};
mj_Seq.prototype = {
	calcHashForOrig: function() {
		var s = this.origSeq;
		var result = 7;
		var _g1 = 0;
		var _g = s.length;
		while(_g1 < _g) {
			var pos = _g1++;
			result = 31 * result + HxOverrides.cca(s,pos);
		}
		this.hashCode = result;
	}
	,calcHashForRed: function() {
		var s = this.redSeq;
		var result = 7;
		var _g1 = 0;
		var _g = s.length;
		while(_g1 < _g) {
			var pos = _g1++;
			result = 31 * result + HxOverrides.cca(s,pos);
		}
		this.hashCode = result;
	}
	,addName: function(s) {
		if(s != null && s != "") {
			this.names.add(s);
			var result = null;
			if(s != null) {
				var pos = s.lastIndexOf("_");
				if(pos != -1) {
					result = HxOverrides.substr(s,0,pos + 1);
				}
			}
			var indId = result;
			var result1 = false;
			var _g_head = this.indNames.h;
			while(_g_head != null) {
				var val = _g_head.item;
				_g_head = _g_head.next;
				var indName = val;
				if(indName == indId) {
					result1 = true;
					break;
				}
			}
			if(!result1) {
				this.indNames.add(indId);
			}
		}
	}
	,hasIndIdentifier: function(s) {
		var result = false;
		var _g_head = this.indNames.h;
		while(_g_head != null) {
			var val = _g_head.item;
			_g_head = _g_head.next;
			var indName = val;
			if(indName == s) {
				result = true;
				break;
			}
		}
		return result;
	}
	,cmpIndIdentifiers: function(o) {
		var result = new List();
		var _g_head = o.h;
		while(_g_head != null) {
			var val = _g_head.item;
			_g_head = _g_head.next;
			var e = val;
			var result1 = false;
			var _g_head1 = this.indNames.h;
			while(_g_head1 != null) {
				var val1 = _g_head1.item;
				_g_head1 = _g_head1.next;
				var indName = val1;
				if(indName == e) {
					result1 = true;
					break;
				}
			}
			if(result1) {
				result.add(e);
			}
		}
		return result;
	}
	,reduceSequence: function(ipos) {
		var l = new List();
		var _g_head = ipos.h;
		while(_g_head != null) {
			var val = _g_head.item;
			_g_head = _g_head.next;
			var e = val;
			l.add(this.origSeq.charAt(e));
		}
		this.redSeq = l.join("");
	}
	,constructSeq: function(s,ipos) {
		var i = 0;
		var _g_head = ipos.h;
		while(_g_head != null) {
			var val = _g_head.item;
			_g_head = _g_head.next;
			var pos = val;
			s[pos] = this.redSeq.charAt(i++);
		}
		var b_b = "";
		var i1 = 0;
		var len = s.length;
		var _g1 = 0;
		var _g = len;
		while(_g1 < _g) {
			var i2 = _g1++;
			b_b += Std.string(Std.string(s[i2]));
			if(i2 < len - 1) {
				b_b += "";
			}
		}
		this.origSeq = b_b;
	}
	,addConnection: function(c) {
		c.next = this.connectedTo;
		this.connectedTo = c;
		this.nrConnections++;
	}
	,clearConnections: function() {
		this.nrConnections = 0;
		this.connectedTo = null;
	}
	,addLinkTo: function(o,names) {
		if(names != null && !names.isEmpty()) {
			var l = new mj_Link();
			l.to = o;
			l.names = names;
			this.linkedTo.add(l);
		}
	}
	,addLinkBySeq: function(os) {
		var o = os.indNames;
		var result = new List();
		var _g_head = o.h;
		while(_g_head != null) {
			var val = _g_head.item;
			_g_head = _g_head.next;
			var e = val;
			var result1 = false;
			var _g_head1 = this.indNames.h;
			while(_g_head1 != null) {
				var val1 = _g_head1.item;
				_g_head1 = _g_head1.next;
				var indName = val1;
				if(indName == e) {
					result1 = true;
					break;
				}
			}
			if(result1) {
				result.add(e);
			}
		}
		var l = result;
		if(l != null && !l.isEmpty()) {
			var l1 = new mj_Link();
			l1.to = os;
			l1.names = l;
			this.linkedTo.add(l1);
		}
		if(l != null && !l.isEmpty()) {
			var l2 = new mj_Link();
			l2.to = this;
			l2.names = l;
			os.linkedTo.add(l2);
		}
	}
};
var mj_Seqs = function() {
	var this1 = new Array(100);
	this.hashTable = this1;
	this.nextSeqId = 1;
	this.origSeqLen = -1;
	this.ipos = new List();
	this.size = 0;
};
mj_Seqs.__name__ = true;
mj_Seqs.prototype = {
	hashCodeToIndex: function(hc) {
		if(hc >= 0) {
			return hc % this.hashTable.length;
		} else {
			return -hc % this.hashTable.length;
		}
	}
	,rehash: function(newSize) {
		var this1 = new Array(newSize);
		this.hashTable = this1;
		var c = this.first;
		while(c != null) {
			c.nextWithHash = null;
			c.prevWithHash = null;
			var hc = c.hashCode;
			var index = hc >= 0 ? hc % this.hashTable.length : -hc % this.hashTable.length;
			if(this.hashTable[index] == null) {
				this.hashTable[index] = c;
			} else {
				c.nextWithHash = this.hashTable[index];
				this.hashTable[index].prevWithHash = c;
				this.hashTable[index] = c;
			}
			c = c.next;
		}
	}
	,addSeqToHashtable: function(s) {
		s.nextWithHash = null;
		s.prevWithHash = null;
		var hc = s.hashCode;
		var index = hc >= 0 ? hc % this.hashTable.length : -hc % this.hashTable.length;
		if(this.hashTable[index] == null) {
			this.hashTable[index] = s;
		} else {
			s.nextWithHash = this.hashTable[index];
			this.hashTable[index].prevWithHash = s;
			this.hashTable[index] = s;
		}
	}
	,addSeq: function(s) {
		this.size++;
		if(this.hashTable.length >> 1 < this.size) {
			var newSize = this.hashTable.length << 1;
			var this1 = new Array(newSize);
			this.hashTable = this1;
			var c = this.first;
			while(c != null) {
				c.nextWithHash = null;
				c.prevWithHash = null;
				var hc = c.hashCode;
				var index = hc >= 0 ? hc % this.hashTable.length : -hc % this.hashTable.length;
				if(this.hashTable[index] == null) {
					this.hashTable[index] = c;
				} else {
					c.nextWithHash = this.hashTable[index];
					this.hashTable[index].prevWithHash = c;
					this.hashTable[index] = c;
				}
				c = c.next;
			}
		}
		s.nextWithHash = null;
		s.prevWithHash = null;
		var hc1 = s.hashCode;
		var index1 = hc1 >= 0 ? hc1 % this.hashTable.length : -hc1 % this.hashTable.length;
		if(this.hashTable[index1] == null) {
			this.hashTable[index1] = s;
		} else {
			s.nextWithHash = this.hashTable[index1];
			this.hashTable[index1].prevWithHash = s;
			this.hashTable[index1] = s;
		}
		if(this.first == null) {
			this.first = s;
		} else {
			s.prev = this.last;
			this.last.next = s;
		}
		this.last = s;
		if(this.firstMed == null && !s.isSample) {
			this.firstMed = s;
		}
	}
	,addSample: function(name,seq) {
		if(this.origSeqLen != -1 && this.origSeqLen != seq.length) {
			throw new js__$Boot_HaxeError("Sequence differentiate in length! Please align sequences first!");
		} else if(seq.length == 0) {
			throw new js__$Boot_HaxeError("Cannot add empty string!");
		}
		this.origSeqLen = seq.length;
		var result = 7;
		var _g1 = 0;
		var _g = seq.length;
		while(_g1 < _g) {
			var pos = _g1++;
			result = 31 * result + HxOverrides.cca(seq,pos);
		}
		var hc = result;
		var hc1 = hc >= 0 ? hc % this.hashTable.length : -hc % this.hashTable.length;
		var s = this.hashTable[hc1];
		while(s != null) {
			if(s.origSeq == seq) {
				if(name != null && name != "") {
					s.names.add(name);
					var result1 = null;
					if(name != null) {
						var pos1 = name.lastIndexOf("_");
						if(pos1 != -1) {
							result1 = HxOverrides.substr(name,0,pos1 + 1);
						}
					}
					var indId = result1;
					var result2 = false;
					var _g_head = s.indNames.h;
					while(_g_head != null) {
						var val = _g_head.item;
						_g_head = _g_head.next;
						var indName = val;
						if(indName == indId) {
							result2 = true;
							break;
						}
					}
					if(!result2) {
						s.indNames.add(indId);
					}
				}
				return;
			}
			s = s.nextWithHash;
		}
		var id = this.nextSeqId++;
		var result3 = new mj_Seq();
		result3.id = id;
		if(name != null && name != "") {
			result3.names.add(name);
			var result4 = null;
			if(name != null) {
				var pos2 = name.lastIndexOf("_");
				if(pos2 != -1) {
					result4 = HxOverrides.substr(name,0,pos2 + 1);
				}
			}
			var indId1 = result4;
			var result5 = false;
			var _g_head1 = result3.indNames.h;
			while(_g_head1 != null) {
				var val1 = _g_head1.item;
				_g_head1 = _g_head1.next;
				var indName1 = val1;
				if(indName1 == indId1) {
					result5 = true;
					break;
				}
			}
			if(!result5) {
				result3.indNames.add(indId1);
			}
		}
		result3.origSeq = seq;
		var s1 = result3.origSeq;
		var result6 = 7;
		var _g11 = 0;
		var _g2 = s1.length;
		while(_g11 < _g2) {
			var pos3 = _g11++;
			result6 = 31 * result6 + HxOverrides.cca(s1,pos3);
		}
		result3.hashCode = result6;
		result3.isSample = true;
		var s2 = result3;
		this.size++;
		if(this.hashTable.length >> 1 < this.size) {
			var newSize = this.hashTable.length << 1;
			var this1 = new Array(newSize);
			this.hashTable = this1;
			var c = this.first;
			while(c != null) {
				c.nextWithHash = null;
				c.prevWithHash = null;
				var hc2 = c.hashCode;
				var index = hc2 >= 0 ? hc2 % this.hashTable.length : -hc2 % this.hashTable.length;
				if(this.hashTable[index] == null) {
					this.hashTable[index] = c;
				} else {
					c.nextWithHash = this.hashTable[index];
					this.hashTable[index].prevWithHash = c;
					this.hashTable[index] = c;
				}
				c = c.next;
			}
		}
		s2.nextWithHash = null;
		s2.prevWithHash = null;
		var hc3 = s2.hashCode;
		var index1 = hc3 >= 0 ? hc3 % this.hashTable.length : -hc3 % this.hashTable.length;
		if(this.hashTable[index1] == null) {
			this.hashTable[index1] = s2;
		} else {
			s2.nextWithHash = this.hashTable[index1];
			this.hashTable[index1].prevWithHash = s2;
			this.hashTable[index1] = s2;
		}
		if(this.first == null) {
			this.first = s2;
		} else {
			s2.prev = this.last;
			this.last.next = s2;
		}
		this.last = s2;
		if(this.firstMed == null && !s2.isSample) {
			this.firstMed = s2;
		}
	}
	,containsMed: function(seq) {
		var result = false;
		var result1 = 7;
		var _g1 = 0;
		var _g = seq.length;
		while(_g1 < _g) {
			var pos = _g1++;
			result1 = 31 * result1 + HxOverrides.cca(seq,pos);
		}
		var hc = result1;
		var hc1 = hc >= 0 ? hc % this.hashTable.length : -hc % this.hashTable.length;
		var s = this.hashTable[hc1];
		while(s != null) {
			if(s.redSeq == seq) {
				result = true;
				break;
			}
			s = s.nextWithHash;
		}
		return result;
	}
	,addMedian: function(seq) {
		var result = false;
		var result1 = 7;
		var _g1 = 0;
		var _g = seq.length;
		while(_g1 < _g) {
			var pos = _g1++;
			result1 = 31 * result1 + HxOverrides.cca(seq,pos);
		}
		var hc = result1;
		var hc1 = hc >= 0 ? hc % this.hashTable.length : -hc % this.hashTable.length;
		var s = this.hashTable[hc1];
		while(s != null) {
			if(s.redSeq == seq) {
				result = true;
				break;
			}
			s = s.nextWithHash;
		}
		if(!result) {
			var id = this.nextSeqId++;
			var result2 = new mj_Seq();
			result2.id = id;
			result2.redSeq = seq;
			var s1 = result2.redSeq;
			var result3 = 7;
			var _g11 = 0;
			var _g2 = s1.length;
			while(_g11 < _g2) {
				var pos1 = _g11++;
				result3 = 31 * result3 + HxOverrides.cca(s1,pos1);
			}
			result2.hashCode = result3;
			result2.isSample = false;
			var s2 = result2;
			this.size++;
			if(this.hashTable.length >> 1 < this.size) {
				var newSize = this.hashTable.length << 1;
				var this1 = new Array(newSize);
				this.hashTable = this1;
				var c = this.first;
				while(c != null) {
					c.nextWithHash = null;
					c.prevWithHash = null;
					var hc2 = c.hashCode;
					var index = hc2 >= 0 ? hc2 % this.hashTable.length : -hc2 % this.hashTable.length;
					if(this.hashTable[index] == null) {
						this.hashTable[index] = c;
					} else {
						c.nextWithHash = this.hashTable[index];
						this.hashTable[index].prevWithHash = c;
						this.hashTable[index] = c;
					}
					c = c.next;
				}
			}
			s2.nextWithHash = null;
			s2.prevWithHash = null;
			var hc3 = s2.hashCode;
			var index1 = hc3 >= 0 ? hc3 % this.hashTable.length : -hc3 % this.hashTable.length;
			if(this.hashTable[index1] == null) {
				this.hashTable[index1] = s2;
			} else {
				s2.nextWithHash = this.hashTable[index1];
				this.hashTable[index1].prevWithHash = s2;
				this.hashTable[index1] = s2;
			}
			if(this.first == null) {
				this.first = s2;
			} else {
				s2.prev = this.last;
				this.last.next = s2;
			}
			this.last = s2;
			if(this.firstMed == null && !s2.isSample) {
				this.firstMed = s2;
			}
		}
	}
	,removeMed: function(s) {
		s.linkedTo.clear();
		if(this.firstMed == s) {
			this.firstMed = s.next;
		}
		if(this.last == s) {
			this.last = s.prev;
		}
		var hc = s.hashCode;
		var index = hc >= 0 ? hc % this.hashTable.length : -hc % this.hashTable.length;
		if(this.hashTable[index] == s) {
			this.hashTable[index] = s.nextWithHash;
		}
		if(s.next != null) {
			s.next.prev = s.prev;
		}
		if(s.prev != null) {
			s.prev.next = s.next;
		}
		if(s.nextWithHash != null) {
			s.nextWithHash.prevWithHash = s.prevWithHash;
		}
		if(s.prevWithHash != null) {
			s.prevWithHash.nextWithHash = s.nextWithHash;
		}
		this.size--;
		s.next = null;
		s.prev = null;
		s.nextWithHash = null;
		s.prevWithHash = null;
	}
	,finishedAddingSamples: function() {
		if(this.origSeqLen <= 1) {
			throw new js__$Boot_HaxeError("Need at least two sampled sequences!");
		}
		var _g1 = 0;
		var _g = this.origSeqLen;
		while(_g1 < _g) {
			var pos = _g1++;
			var current = this.first.next;
			while(current != null) {
				if(this.first.origSeq.charAt(pos) != current.origSeq.charAt(pos)) {
					this.ipos.add(pos);
					break;
				}
				current = current.next;
			}
		}
		var current1 = this.first;
		while(current1 != null) {
			var ipos = this.ipos;
			var l = new List();
			var _g_head = ipos.h;
			while(_g_head != null) {
				var val = _g_head.item;
				_g_head = _g_head.next;
				var e = val;
				l.add(current1.origSeq.charAt(e));
			}
			current1.redSeq = l.join("");
			var s = current1.redSeq;
			var result = 7;
			var _g11 = 0;
			var _g2 = s.length;
			while(_g11 < _g2) {
				var pos1 = _g11++;
				result = 31 * result + HxOverrides.cca(s,pos1);
			}
			current1.hashCode = result;
			current1 = current1.next;
		}
		var newSize = this.hashTable.length << 1;
		var this1 = new Array(newSize);
		this.hashTable = this1;
		var c = this.first;
		while(c != null) {
			c.nextWithHash = null;
			c.prevWithHash = null;
			var hc = c.hashCode;
			var index = hc >= 0 ? hc % this.hashTable.length : -hc % this.hashTable.length;
			if(this.hashTable[index] == null) {
				this.hashTable[index] = c;
			} else {
				c.nextWithHash = this.hashTable[index];
				this.hashTable[index].prevWithHash = c;
				this.hashTable[index] = c;
			}
			c = c.next;
		}
	}
	,printTxt: function(printer) {
		printer.printString("#Calculated via HaplowebMaker version ");
		printer.printString(mj_MJAlgo.version);
		printer.printString(printer.newline);
		var c = this.first;
		while(c != null) {
			printer.printString(c.isSample ? "SAMPLED_SEQUENCE" : "MEDIAN_VECTOR");
			printer.printString(printer.newline);
			printer.printString(printer.indent);
			printer.printString("ID ");
			printer.printString("" + c.id);
			printer.printString(printer.newline);
			if(c.isSample) {
				printer.printString(printer.indent);
				printer.printString("SPECIES_ID ");
				printer.printString("" + c.spId);
				printer.printString(printer.newline);
			}
			printer.printString(printer.indent);
			printer.printString("SEQUENCE ");
			printer.printString("" + c.origSeq);
			printer.printString(printer.newline);
			if(c.names != null && c.names.length > 0) {
				printer.printString(printer.indent);
				printer.printString("NB_NAMES ");
				printer.printString("" + c.names.length);
				printer.printString(printer.newline);
				printer.printString(printer.indent);
				printer.printString("NAMES");
				printer.printString(printer.newline);
				var _g_head = c.names.h;
				while(_g_head != null) {
					var val = _g_head.item;
					_g_head = _g_head.next;
					var name = val;
					printer.printString(printer.indent);
					printer.printString(printer.indent);
					printer.printString(name);
					printer.printString(printer.newline);
				}
			}
			if(c.connectedTo != null && c.nrConnections > 0) {
				printer.printString(printer.indent);
				printer.printString("CONNECTED_TO ");
				printer.printString(printer.newline);
				var con = c.connectedTo;
				while(con != null) {
					printer.printString(printer.indent);
					printer.printString(printer.indent);
					printer.printString("ID " + con.connectedTo.id);
					printer.printString(" COSTS " + con.dist + " @");
					var _g1 = 0;
					var _g = c.origSeq.length;
					while(_g1 < _g) {
						var pos = _g1++;
						if(c.origSeq.charAt(pos) != con.connectedTo.origSeq.charAt(pos)) {
							printer.printString(" " + (pos + printer.countingOffset));
						}
					}
					printer.printString(printer.newline);
					con = con.next;
				}
			}
			if(c.linkedTo != null && c.linkedTo.length > 0) {
				printer.printString(printer.indent);
				printer.printString("LINKED_TO ");
				printer.printString(printer.newline);
				var _g_head1 = c.linkedTo.h;
				while(_g_head1 != null) {
					var val1 = _g_head1.item;
					_g_head1 = _g_head1.next;
					var link = val1;
					printer.printString(printer.indent);
					printer.printString(printer.indent);
					printer.printString("ID " + link.to.id + " COUNT " + link.names.length);
					printer.printString(printer.newline);
				}
			}
			c = c.next;
		}
		printer.close();
	}
	,printOldTxt: function(printer) {
		printer.printString("+");
		var _g_head = this.ipos.h;
		while(_g_head != null) {
			var val = _g_head.item;
			_g_head = _g_head.next;
			var e = val;
			printer.printString(" " + e);
		}
		printer.printString(printer.newline);
		var c = this.first;
		while(c != null) {
			printer.printString("+NODE " + (c.id - 1) + " " + (c.names == null ? 0 : c.names.length));
			printer.printString(printer.newline);
			if(c.names != null && c.names.length > 0) {
				var _g_head1 = c.names.h;
				while(_g_head1 != null) {
					var val1 = _g_head1.item;
					_g_head1 = _g_head1.next;
					var name = val1;
					printer.printString("NAME ");
					printer.printString(name);
					printer.printString(printer.newline);
				}
			}
			printer.printString("SEQ " + c.origSeq);
			printer.printString(printer.newline);
			c = c.next;
		}
		var c1 = this.first;
		while(c1 != null) {
			if(c1.connectedTo != null && c1.nrConnections > 0) {
				var con = c1.connectedTo;
				while(con != null) {
					if(c1.id < con.connectedTo.id) {
						var l = new List();
						var _g1 = 0;
						var _g = c1.origSeq.length;
						while(_g1 < _g) {
							var pos = _g1++;
							if(c1.origSeq.charAt(pos) != con.connectedTo.origSeq.charAt(pos)) {
								l.add(pos);
							}
						}
						printer.printString("+CON " + (c1.id - 1) + " " + (con.connectedTo.id - 1) + " " + con.dist + " " + l.length);
						printer.printString(printer.newline);
						printer.printString("POS");
						var _g_head2 = l.h;
						while(_g_head2 != null) {
							var val2 = _g_head2.item;
							_g_head2 = _g_head2.next;
							var e1 = val2;
							printer.printString(" " + e1);
						}
						printer.printString(printer.newline);
					}
					con = con.next;
				}
			}
			if(c1.linkedTo != null && c1.linkedTo.length > 0) {
				var _g_head3 = c1.linkedTo.h;
				while(_g_head3 != null) {
					var val3 = _g_head3.item;
					_g_head3 = _g_head3.next;
					var link = val3;
					if(c1.id - 1 > link.to.id - 1) {
						printer.printString("+LINK " + (c1.id - 1) + " " + (link.to.id - 1) + " " + link.names.length + " " + link.names.length + " " + link.names.length);
						printer.printString(printer.newline);
					}
				}
			}
			c1 = c1.next;
		}
	}
};
var util_StdOutPrinter = function() {
	this.indent = "  ";
	this.newline = "\n";
	this.countingOffset = 1;
};
util_StdOutPrinter.__name__ = true;
util_StdOutPrinter.__interfaces__ = [interfaces_Printer];
util_StdOutPrinter.prototype = {
	printString: function(s) {
		console.log(s);
	}
	,close: function() {
	}
};
String.__name__ = true;
Array.__name__ = true;
mj_MJAlgo.version = "1.0.1";
mj_MJAlgo.main();
//})();
